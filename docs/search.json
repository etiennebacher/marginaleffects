[
  {
    "objectID": "CITATION.html",
    "href": "CITATION.html",
    "title": "Citation",
    "section": "",
    "text": "Citation\nTo cite marginaleffects in publications, please use:\n\nArel-Bundock V, Greifer N, Heiss A (Forthcoming). “How to Interpret Statistical Models Using in and .” Journal of Statistical Software. https://marginaleffects.com."
  },
  {
    "objectID": "NEWS.html",
    "href": "NEWS.html",
    "title": "News",
    "section": "",
    "text": "Bugs:\n\nsystemfit models returned no standard errors when the same variables entered in different parts of the model. Thanks to (mronkko?) for report #1233.\n\n\n\n\nBreaking change:\n\nSupport for mlogit is deprecated. The reason is that the data structure for these models is one observation-choice per row. Every other model-fitting package supported by marginaleffects treats rows as individual observations. The observation-choice structure made it harder to track indices and match individual predictions to rows in the original data. This added a lot of complexity to marginaleffects, and the results were not always reliable or safe.\n\nBugs:\n\nImproved glmmTMB support\n\nStandard errors are produced in models with type=\"zprob\". Thanks to (jgeller112?) for issue #1189.\nhypotheses() bug resolved. Thanks to (reikookamoto?) for the code submission.\n\nmultinom_weightit models with insight version 0.20.4 and greater would produce an error. Thanks to Noah Greifer.\nhypotheses(joint = TRUE) would throw an error if sample sizes could not be computed, even if they were not needed. Thanks to Noah Greifer.\nhypotheses(joint = TRUE) respects the vcov argument. Thanks to (kennchua?) for report #1214.\nordbetareg models in glmmTMB are now supported. Thanks to (jgeller112?) for code contribution #1221.\ntidymodels(): Indexing overrode the value of predictors in the output data frame. The numerical estimates were unaffected. Thanks to (agmath?) for report #1209.\n\n\n\n\nBreaking changes:\n\ntype=\"invlink(link)\" is no longer default in avg_predictions() or when calling predictions() with the by argument. It is still default in predictions() without the by argument. The backtransform strategy is still available with by setting type=\"invlink(link)\" explicitly.\nThe type argument in plot_comparisons() now defaults to NULL, which is now consistent with comparisons() and avg_comparisons(). Before, the default was type=\"response\". Thanks to (giakhang1906?) for report #1202.\n\nNew models supported:\n\nstpm2, pstpm2, gsm, and aft models from rstpm2. Thanks to (aghaynes?) and (mclements?).\nglm_weightit, coxph_weightit, multinom_weightit, and ordinal_weightit models from Weightit. Thanks to (ngreifer?).\nglmmgee from the glmtoolbox package. Thanks to (adrianolszewski?) for the request and (lhvanegasp?) for help with implementation.\n\nNew features:\n\nParallel computation with future is more efficient by chunking tasks to avoid passing large objects to every worker for every future. Issue #1158.\nAll columns of newdata are passed to the hypothesis function when newdata is supplied explicitly. Thanks to (gravesti?) for report #1175.\nhypotheses(joint=TRUE): do not call stats::nobs() unless necessary.\nhypotheses() supports formulas in the hypothesis argument: hypotheses(model, hypothesis = ratio ~ reference)\nGlobal option: options(\"marginaleffects_print_omit\" = \"s.value\")\nRound significant digits for labels in plot_predictions(mod, condition = list(x = \"fivenum\"))\nprint() no longer prints contrast and term columns when values are unique. The labels were often very long, and the content is already explicit in the call itself, so there’s no ambiguity.\nNo warning raised when discrete argument is used with mgcv::bam and mgcv::gam models objects. Thanks to (Aariq?) for the request.\ntidymodels support is improved. Users can now directly feed some of them without specifying newdata explicitly. Thanks to (davidkane9?) for the feature request.\n\nBugs:\n\nAverage lift and average comparisons with user-supplied functions could be be calculated incorrectly when all predictors were categorical. Thanks to (Dpananos?) for Issue #1151.\nIndexing bug returned NA for some commands in survey models. Thanks to (weikang9009?) for report #1161.\nRespect default tinytable theme.\nInverted confidence interval bounds with some inverse link functions. Thanks to (strengejacke?) for report #1204.\n\n\n\n\nNew:\n\nhypothesis accepts formulas like: ratio ~ sequential | group\nAllow reverse binary contrasts: comparisons(mod, variables = list(am = 1:0, vs = 0:1)). Thanks to K. Henry for report #1137.\noptions(marginaleffects_safe = FALSE) disables some safety checks and allows unadvisable (but potentially) useful features like many pairwise comparisons. Thanks to D.Locke for the feature request.\nnewdata=\"balanced\" is a shortcut to produce estimates at combinations of all categorical predictors, holding numeric predictors at their means. Equivalent to datagrid(grid_type=\"balanced\")\n\nMisc:\n\nDeprecation warning for specify_hypothesis(). This function was clearly marked as experimental, and has been available only for one release. It was a bad idea. Users should supply a custom function or a formula to the hypothesis argument. The new formula interface, in particular, makes it very easy to conduct group-wise hypothesis tests.\nType checks are a bit looser to accommodate custom models.\n\nBugs:\n\nFix regression in mlogit models due to factor conversion. This raised an error before returning result, so there is no numerical danger.\nsurvey package models work when row.names(model) is not coercible to integers. Thanks to (ngreifer?) for report #1131.\n\n\n\n\n\nThe comparison argument of the comparisons() function is automatically switched to the avg version of the function shortcuts when calling avg_comparisons() or setting by=TRUE. For example, comparison=\"ratio\" becomes comparison=\"ratioavg\" when calling avg_comparisons(). Note that comparison=\"ratioavg\" is equivalent to: comparison = \\(hi,lo) mean(hi)/mean(lo)\nFixed a bug (“non-conformable arguments”) when using survreg objects from survival::survreg().\nFixed bug in inferences() for GLM models and type=\"invlink\", where the wrong scale would be reported for confidence intervals.\n\n\n\n\nBreaking changes:\n\nThe order of the group column is preserved when the original variable is a factor. This may change the order of output, which could have an effect on hypothesis tests using the hypothesis=\"b1=b3\" syntax.\n\nNew:\n\nNew experimental function: specify_hypothesis() returns functions to be used in the hypothesis argument of predictions(), comparisons(), and slopes(). This convenience function can be used to specify complex aggregations and estimands for hypothesis tests (ex: by subgroups or with custom functions).\nhypothesis argument accepts “meandev” and “meanotherdev” to compute deviations from the mean estimate.\nDo not raise extraneous warning for survey package models when the by argument is not used.\nInformative error when hypotheses() is called twice on the same object.\nprint(\"tinytable\") adds footnotes to the table with columns and type information.\n\nBugs:\n\nmlogit predict() method does not play well with data.table. Thanks to (andrewheiss?) for report #1086.\nAvoid merging newdata in predictions() when hypothesis can change the meaning of rows. Avoid Issue #1105 reported by (strengejacke?).\ninferences() did not work with the transform argument. Thanks to Demetri Pananos for report #1115.\n\n\n\n\nBreaking changes:\n\ndatagrid() no longer includes the response variable by default when it is not explicitly specified by the user. Use the new response argument to include it.\ndatagrid(grid_type=\"balanced\") returns factors ordered by level rather than by order of appearance in the original data.\nOrder of some rows in the output may differ when using datagrid(). Necessary to fix issue #1079 (see below).\n\nNew modeling packages supported:\n\nflexsurv: Thanks to (mattwarkentin?) for code contributions in PR #781. https://cran.r-project.org/web/packages/flexsurv/index.html\nREndo: https://cran.r-project.org/web/packages/REndo/index.html\n\nNew:\n\nwts=TRUE tries to retrieves weights used in a weighted fit such as lm() with the weights argument or a model fitted using the survey package. Thanks to (ngreifer?) for feature request\nprint.marginaleffects() supports style=\"tinytable\", which returns a tinytable object. Call print(avg_slopes(model)) to get a nice printed table in Quarto or Rmarkdown documents, via Typst, LaTeX or HTML. Default print format can be set using: options(marginaleffects_print_style=\"tinytable\")\nhypothesis argument accepts a function which takes a marginaleffects data frame and returns a transformed data frame with term and estimate columns.\ndatagrid() gets a response argument (default is FALSE) to control if the response variable is included or excluded from the grid-building process.\nThe base::subset() and dplyr::filter() functions can be called with a single argument in newdata to select a subset of rows from the dataset used to fit the model.\n\nEx: avg_comparisons(fit, variables = “treatment”, newdata = subset(treatment == 1))`\n\nBetter warning for unsupported arguments.\ndf argument in hypotheses() accepts a vector of length 2 to control degrees of freedom in F tests.\nnlme::lme() objects raise a warning about degrees of freedom. Thanks to and (stefgehrig?) and (huftis?) for discussion in Issue #960.\n\nMajor bugs:\n\nSome results could be mislabelled with factor variables used in combination with datagrid() or condition. Thanks to (snhansen?) for report #1079.\nglmmTMB models now report correct standard errors, and raise a warning that these standard errors only account for uncertainty in fixed effect parameters. Thanks to contributors to Issue #1024 and especially to (bbolker?) for discussion and solution.\n\nMinor bugs:\n\nUninformative error when a custom comparison function returns NA in bayesian models. Thanks to (Sandhu-SS?) for report #1017.\ndatagrid() returns an object with full attributes when by is used. Thanks to (Sandhu-SS?) for report #1058.\ninferences(method=\"simulation\") with inferences() function. Thanks to (davidarmstrong?) for report #1054.\n\n\n\n\nThis release represents a major step towards 1.0.0. Some functions are renamed and now raise deprecation warnings. After 1.0.0, the API will become much more stable, and any change will have to be very deliberate with much lead time and deprecation delays.\nBreaking changes:\n\ntidy() no longer takes the average of estimates in the original model object. Users who want an aggregate estimate should call the relevant avg_*() function, or use the by argument explicitly. The previous behavior led to unexpected behavior and increased code complexity a lot.\nsummary() methods are removed. These have never provided any additional information; they just reprinted the output already available with the standard print method. At least the default summary() for data frames (which is now triggered on marginaleffects object) provides a different view on the content of the object.\nplot_cco(), plot_cme(), and plot_cap() were renamed in version 0.9.0, one year ago. They are now fully removed from the package.\n\nNew:\n\ndatagrid(grid_type = \"balanced\") creates a balanced grid with all unique values of categorical predictors. This can be used with predictions() to compute marginal means as in the emmeans package.\nmvgam package support (multivariate generalized additive models)\n\nDeprecation warnings:\n\ndeltamethod() has been named hypotheses() for a while. We now issue a deprecation warning and it will be removed eventually.\ndatagridcf() will eventually be deprecated and removed from the package. We will raise a warning for at least one year before removing the function. Identical results can be obtained with datagrid(..., grid_type=\"counterfactual\")\nmarginal_means() will eventually be deprecated and removed from the package. We will raise a warning for at least one year before removing the function. Identical results can be obtained using the predictions() function and the grid_type=\"balanced\" argument of datagrid(). Examples are in the marginal means vignette on the website.\n\nMinor:\n\nBetter warning messages for unsupported matrix columns, enhancing user experience and troubleshooting.\nVarious improvements to documentation.\nTypos\nRepository hosts model objects for easier testing.\n\nBug fixes:\n\nError on hypotheses(joint = \"string\") for comparisons() objects (no result was returned). Thanks to (BorgeJorge?) for report #981.\nEnhanced support for multi-equation Bayesian models with brms models. Thanks to (winterstat?) for report #1006.\nParameter names with spaces could break standard errors. Thanks to (Lefty2021?) for report #1005.\n\n\n\n\nBreaking changes:\n\nThe comparisons() now uses “forward contrasts” by default for numeric predictors, instead of “centered contrasts”. This can lead to small numerical differences in non-linear models.\nThe variables argument of the comparisons() function no longer accepts numeric vectors unless they are of length 2, specifying the low and high contrast values. This is to avoid ambiguity between the two vector version. Users should supply a data frame or a function instead. This is nearly as easy, and removes ambiguity.\n\nNew supported packages:\n\ndbarts: https://cran.r-project.org/package=dbarts\nmvgam: https://nicholasjclark.github.io/mvgam/ Not available on CRAN yet, but this package maintains its own marginaleffects support function.\nrms::Gls: https://cran.r-project.org/package=rms\n\nMisc:\n\ncomparisons(): The variables argument now accepts functions and data frames for factor, character, and logical variables.\nDeprecation warning for: plot_cap(), plot_cme(), and plot_cco(). These function names will be removed in version 1.0.0.\noptions(modelsummary_factory_default=...) is respected in Quarto and Rmarkdown documents.\n\nBugs:\n\nwts argument now respected in avg_slopes() for binary variables. Thanks to (trose64?) for report #961\nCustom functions in the comparison argument of comparisons() did not supply the correct x vector length for bayesian models when the by argument is used. Thanks to (Sandhu-SS?) for report #931.\nAdd support for two facet variables (through facet_grid) when plotting using condition\ncomparisons(): When variables is a vector of length two and newdata has exactly two columns, there was ambiguity between custom vectors and length two vector of contrasts. Bug reported by C. Rainey on Twitter.\nSuperfluous warning with fixest::fenegbin.\n\n\n\n\nMachine learning support:\n\ntidymodels package\nmlr3 package\n\nMisc:\n\nNew vignettes:\n\nInverse Probability Weighting\nMachine Learning\nMatching\n\nAdd support for hypotheses() to inferences(). Thanks to (Tristan-Siegfried?) for code contribution #908.\nSupport survival::survreg(). Thanks to Carlisle Rainey for Report #911.\ncolumn_names argument in print.marginaleffects() to suppress the printed column names at the bottom of the printout.\nThe function supplied to the comparison argument of the comparisons() function can now operate on x and on newdata directly (e.g., to check the number of observations).\nMore informative errors from predict().\n\nBugs:\n\nSome gamlss models generated an error related to the what argument. Thanks to (DHLocke?) for Issue #933\n\n\n\n\n\nhypotheses(): The FUN argument handles group columns gracefully.\nNative support for Amelia for multiple imputation.\n\nDocumentation:\n\nNew section on “Complex aggregations” in the Hypothesis testing vignette.\n\nBug fix:\n\nResults of the predictions() function could be inaccurate when (a) running version 0.15.0, (b) type is NULL or invlink(link), (c) model is glm(), and (d) the hypothesis argument is non-numeric. Thanks to (strengejacke?) for report #903\n\n\n\n\nNew:\n\nConformal prediction via inferences()\nhypothesis argument now accepts multiple string formulas.\nThe type argument now accepts an explicit invlink(link) value instead of silently back-transforming. Users are no longer pointed to type_dictionary. Instead, they should call their function with a bad type value, and they will obtain a list of valid types. The default type value is printed in the output. This is useful because the default type value is NULL, so the user often does not explicitly decide.\nAllow install with Rcpp 1.0.0 and greater.\n\nSupport new models:\n\nsurvey::svyolr()\n\nMisc:\n\ninferences(method=\"simulation\") uses the original point estimate rather than the mean of the simulation distribution. Issue #851.\nBetter documentation and error messages for newdata=NULL\nSome performance improvements for predictions() and marginalmeans() (#880, #882, (etiennebacher?)).\n\nBug fix:\n\nnewdata=\"median\" returned mean of binary variables. Thanks to (jkhanson1970?) for report #896.\n\n\n\n\nBreaking changes:\n\nRow order of the output changes for some objects. Rows are not sorted alphabetically by term, by, and variables explicitly supplied to datagrid. This can affect hypothesis tests computed using the b1, b2, b3, and other indices.\nNew procedure numderiv argument use a different procedure to select the step size used in the finite difference numeric derivative used to compute standard errors: abs(x) * sqrt(.Machine$double.eps). The numerical results may not be exactly identical to previous versions of marginaleffects, but the step size should be adequate in a broader variety of cases. Note that users can use the numderiv argument for more control on numeric differentiation, as documented.\nbife models are no longer supported pending investigation in weird results in the tests. Looking for volunteers write more thorough tests.\n\nNew:\n\nSupport: logistf package.\nSupport: DCchoice package.\nSupport: stats::nls\nhypotheses() can now accept raw data frame, which gives a lot of flexibility for custom contrasts and functions. See the Hypothesis vignette for an example.\nnumderiv argument allows users to use finite difference (center or forward) or Richardson’s method to compute the numerical derivatives used in the calculation of standard errors.\n\nBug fixes:\n\ninferences() supports the cross argument for comparisons() objects. Thanks to Kirill Solovev for report #856.\nsplines::bs() in formulas could produce incorrect results due to weirdness in stats::model.matrix(). Thanks to (chiungming?) for report #831.\nmgcv with ocat are now supported. Thanks to Lorenzo Fabbri for Issue #844.\nquantreg problem with rowid merge did not affect estimates but did not return the full original data. Issue #829.\nget_modeldata() extracts weights variable when available.\npredictions() is no longer broken in some inferences() calls. Issue #853\nInaccurate averaging with comparison=differenceavg some models where all predictors are categorical. Thanks to Karl Ove Hufthammer for report #865.\n\nMisc:\n\nMajor refactor to simplify the code base and make maintenance easier.\n\n\n\n\nBreaking change:\n\nglmmTMB: Standard errors are no longer supported because they may have been erroneous. Follow Issue #810 on Github for developments: https://github.com/vincentarelbundock/marginaleffects/issues/810\n\nNew:\n\nhypothesis argument accepts wildcards: hypothesis = \"b*=b1\"\ns.value column in all output: Shannon transforms for p values. See Greenland (2019).\nmarginal_means supports mira (mice objects).\ncomparisons(): The variables arguments now accepts arbitrary numeric vectors of length equal to the number of rows in newdata. This allows users to specify fully custom treatment sizes. In the documentation examples, we show how to estimate the difference for a 1 standard deviation shift in a regressor, where the standard deviation is calculated on a group-wise basis.\ncomparisons(): the variables argument now accepts “revpairwise”, “revsequential”, “revreference” for factor and character variables.\ncomparisons(): the comparison argument now accept “lift” and “liftavg”.\n\nPerformance:\n\nComputing elasticities for linear models is now up to 30% faster (#787, (etiennebacher?)).\n\nBug fixes:\n\nBetter handling of environments when newdata is a function call. Thanks to (jcccf?) for report #814 and to (capnrefsmmat?) for the proposed fix using the rlang package.\nDegrees of freedom mismatch for joint hypothesis tests. Thanks to (snhansen?) for report #789.\n\n\n\n\nBreaking change:\n\nRow order of output has changed for many calls, especially those using the by argument. This may break hypothesis tests conducted by indexing b1, b2, etc. This was necessary to fix Issue #776. Thanks to (marcora?) for the report.\n\nNew:\n\nhypotheses(): Joint hypothesis tests (F and Chi-square) with the joint and joint_test arguments.\nvcov.hypotheses method.\nwts is now available in plot_predictions(), plot_comparisons(), and plot_slopes().\n\nBug:\n\nWrong order of rows in bayesian models with by argument. Thanks to (shirdekel?) for report #782.\n\n\n\n\n\nvcov() and coef() methods for marginaleffects objects.\nStrings in wts are accepted with the by argument.\npredictions() and avg_predictions() no longer use an automatic backtransformation for GLM models unless hypothesis is NULL.\nvcov() can be used to retrieve a full variance-covariance matrix from objects produced by comparisons(), slopes(), predictions(), or marginal_means() objects.\nWhen processing objects obtained using mice multiple imputation, the pooled model using mice::pool is attached to the model attribute of the output. This means that functions like modelsummary::modelsummary() will not erroneously report goodness-of-fit statistics from just a single model and will instead appropriately report the statistics for the pooled model. Thanks to (Tristan-Siegfried?) for PR #740.\nMore informative error messages on some prediction problems. Thanks to (andymilne?) for Report #751.\n\nPerformance:\n\ninferences() is now up to 17x faster and much more memory-efficient when method is \"boot\" or \"rsample\" (#770, #771, (etiennebacher?)).\n\nBugs:\n\nbrms models with nl=TRUE and a single predictor generated an error. Thanks to (Tristan-Siegried?) for Report #759.\navg_predictions(): Incorrect group-wise averaging when all predictors are categorical, the variables variable is used, and we are averaging with avg_ or the by argument. Thanks to BorgeJorge for report #766.\nBug when datagrid() when called inside a user-written function. Thanks to (NickCH-K?) for report #769 and to (capnrefsmmat?) for the diagnostics.\n\n\n\n\nBreaking change:\n\nRow orders are now more consistent, but may have changed from previous version. This could affect results from hypothesis with b1, b2, … indexing.\n\nSupport new models:\n\nnlme::lme()\nphylolm::phylolm()\nphylolm::phyloglm()\n\nNew:\n\nVignette on 2x2 experimental designs. Thanks to Demetri Pananos.\ncomparisons() accepts data frames with two numeric columns (“low” and “high”) to specify fully customizable contrasts.\ndatagrid() gets a new by argument to create apply grid-making functions within groups.\nplot_*() gain a newdata argument for use with by.\n\nBug:\n\ncomparisons(comparison = \"lnratioavg\") ignored wts argument. Thanks to Demetri Pananos for report #737.\nordinal::clm(): incorrect standard errors when location and scale parameters are the same. Thanks to MrJerryTAO for report #718.\nIncorrect label for “2sd” comparisons. Thanks to Andy Milne for report #720.\nInvalid factor levels in datagrid() means newdata argument gets ignored. Thanks to Josh Errickson for report #721.\nError in models with only categorical predictors and the by argument. Thanks to Sam Brilleman for report #723.\nElasticities are now supported for ordinal::clm() models. Thanks to MrJerryTAO for report #729.\nglmmTMB models with zero-inflated components are supported. Thanks to (Helsinki-Ronan?) and (strengejacke?) for report #734.\n\n\n\n\nBreaking changes:\n\ntype column is replaced by type attribute.\npredictions() only works with officially supported model types (same list as comparisons() and slopes()).\n\nRenamed arguments (backward compatibility is preserved):\n\ntransform_pre -&gt; comparison\ntransform_post -&gt; transform\n\nNew:\n\np_adjust argument: Adjust p-values for multiple comparisons.\nequivalence argument available everywhere.\n\nPerformance:\n\nMuch faster results in avg_*() functions for models with only categorical predictors and many rows of data, using deduplication and weights instead of unit-level estimates.\nFaster predictions in lm() and glm() models using RcppEigen.\nBayesian models with many rows. Thanks to Etienne Bacher. #694\nFaster predictions, especially with standard errors and large datasets.\n\nBugs:\n\nMultiple imputation with mira objects was not pooling all datasets. Thanks to (Generalized?) for report #711.\nSupport for more models with offsets. Thanks to (mariofiorini?) for report #705.\nError on predictions() with by and wts. Thanks to Noah Greifer for report #695.\nafex: some models generated errors. Thanks to Daniel Lüdecke for report #696.\ngroup column name is always forbidden. Thanks to Daniel Lüdecke for report #697.\nBlank graphs in plot_comparisons() with a list in variables.\ntype=\"link\" produced an error with some categorical brms models. Thanks to (shirdekel?) for report #703.\nError on predictions(variables = ...) for glmmTMB models. Thanks to Daniel Lüdecke for report #707.\nby with user-specified function in comparison and factor predictor did not aggregate correctly. Thanks to (joaotedde?) for report #715.\nordinal::clm: Support cum.prob and linear.predictor prediction types. Thanks to (MrJerryTAO?) for report #717.\n\n\n\n\nPerformance:\n\n2-4x faster execution for many calls. Thanks to Etienne Bacher.\n\nNew models supported:\n\nMCMCglmm::MCMCglmm\nRchoice::hetprob\nRchoice::ivpml\nMultiple imputation using mice and any package which can return a list of imputed data frames (e.g., Amelia, missRanger, etc.)\n\nPlot improvements:\n\nNew by argument to display marginal estimates by subgroup.\nNew rug argument to display tick marks in the margins.\nNew points argument in plot_predictions() to display a scatter plot.\nNew gray argument to plot in grayscale using line types and shapes instead of color.\nThe effect argument is renamed to variables in plot_slopes() and plot_comparisons(). This improves consistency with the analogous slopes() and comparisons() functions.\nThe plotting vignette was re-written.\n\nOther:\n\nSupport multiple imputation with mice mira objects. The multiple imputation vignette was rewritten.\nThe variables_grid argument in marginal_means() is renamed newdata. Backward compatibility is maintained.\navg_*() returns an informative error when vcov is “satterthwaite” or “kenward-roger”\n“satterthwaite” and “kenward-roger” are now supported when newdata is not NULL\nInformative error when hypothesis includes a b# larger than the available number of estimates.\navg_predictions(model, variables = \"x\") computes average counterfactual predictions by subgroups of x\ndatagrid() and plot_*() functions are faster in datasets with many extraneous columns.\nIn predictions(type = NULL) with glm() and Gam() we first make predictions on the link scale and then backtransform them. Setting type=\"response\" explicitly makes predictions directly on the response scale without backtransformation.\nStandard errors now supported for more glmmTMB models.\nUse the numDeriv package for numeric differentiation in the calculation of delta method standard error. A global option can now be passed to numDeriv::jacobian:\n\noptions(marginaleffects_numDeriv = list(method = \"simple\", method.args = list(eps = 1e-6)))\noptions(marginaleffects_numDeriv = list(method = \"Richardson\", method.args = list(eps = 1e-6)))\noptions(marginaleffects_numDeriv = NULL)\n\nPrint:\n\nPrint fewer significant digits.\nprint.marginaleffects now prints all columns supplied to newdata\nLess redundant labels when using hypothesis\n\nMany improvements to documentation.\n\nBugfixes:\n\nStandard errors could be inaccurate in models with non-linear components (and interactions) when some of the coefficients were very small. This was related to the step size used for numerical differentiation for the delta method. Issue #684.\navg_predictions(by =) did not work when the dataset included a column named term. Issue #683.\nbrms models with multivariate outcome collapsed categories in comparisons(). Issue #639.\nhypotheses() now works on lists and in calls to lapply(), purrr::map(), etc. Issue #660.\n\n\n\n\nBreaking changes:\n\nAll functions return an estimate column instead of the function-specific predicted, comparisons, dydx, etc. This change only affects unit-level estimates, and not average estimates, which already used the estimate column name.\nThe transform_avg argument in tidy() deprecated. Use transform_post instead.\nplot_*(draw=FALSE) now return the actual variable names supplied to the condition argument, rather than the opaque “condition1”, “condition2”, etc.\n\nNew models supported:\n\nblme package.\n\nNew features:\n\nNew functions: avg_predictions(), avg_comparisons(), avg_slopes()\nEquivalence, non-inferiority, and non-superiority tests with the hypotheses() function and equivalence argument.\nNew experimental inferences() function: simulation-based inferences and bootstrap using the boot, rsample, and fwb package.\nNew df argument to set degrees of freedom manually for p and CI.\nPretty print() for all objects.\nby argument\n\nTRUE returns average (marginal) predictions, comparisons, or slopes.\nSupports bayesian models.\n\nhypothesis argument\n\nNumeric value sets the null used in calculating Z and p.\nExample: comparisons(mod, transform_pre = \"ratio\", hypothesis = 1)\n\nAll arguments from the main functions are now available through tidy(), and summary(): conf_level, transform_post, etc.\nBayesian posterior distribution summaries (median, mean, HDI, quantiles) can be customized using global options. See ?comparisons\n\nRenamed functions (backward-compatibility is maintained by keeping the old function names as aliases):\n\nmarginaleffects() -&gt; slopes()\nposteriordraws() -&gt; posterior_draws()\nmarginalmeans() -&gt; marginal_means()\nplot_cap() -&gt; plot_predictions()\nplot_cme() -&gt; plot_slopes()\nplot_cco() -&gt; plot_comparisons()\n\nBug fixes:\n\nIncorrect results: In 0.8.1, plot_*() the threenum and minmax labels did not correspond to the correct numeric values.\nFix corner case for slopes when the dataset includes infinite values.\nmlogit error with factors.\nThe vcov argument now accepts functions for most models.\n\nOther:\n\nRemoved major performance bottleneck for slopes()\n\n\n\n\n\ndeltamethod() can run hypothesis tests on objects produced by the comparisons(), marginaleffects(), predictions(), and marginalmeans() functions. This feature relies on match.call(), which means it may not always work when used programmatically, inside functions and nested environments. It is generally safer and more efficient to use the hypothesis argument.\nplot_cme() and plot_cco() accept lists with user-specified values for the regressors, and can display nice labels for shortcut string-functions like “threenum” or “quartile”.\nposterior_draws: new shape argument to return MCMC draws in various formats, including the new rvar structure from the posterior package.\ntransform_avg function gets printed in summary() output.\ntransform_post and transform_avg support string shortcuts: “exp” and “ln”\nAdded support for mlm models from lm(). Thanks to Noah Greifer.\n\nBug fixes:\n\nhypothesis argument with bayesian models and tidy() used to raise an error.\nMissing values for some regressors in the comparisons() output for brms models.\n\n\n\n\nBreaking change:\n\nThe interaction argument is deprecated and replaced by the cross argument. This is to reduce ambiguity with respect to the interaction argument in emmeans, which does something completely different, akin to the difference-in-differences illustrated in the Interactions vignette.\n\n71 classes of models supported, including the new:\n\nrms::ols\nrms::lrm\nrms::orm\n\nNew features:\n\nPlots: plot_cme(), plot_cap(), and plot_cco() are now much more flexible in specifying the comparisons to display. The condition argument accepts lists, functions, and shortcuts for common reference values, such as “minmax”, “threenum”, etc.\nvariables argument of the comparisons() function is more flexible:\n\nAccepts functions to specify custom differences in numeric variables (e.g., forward and backward differencing).\nCan specify pairs of factors to compare in the variables argument of the comparisons function.\n\nvariables argument of the predictions() function is more flexible:\n\nAccepts shortcut strings, functions, and vectors of arbitrary length.\n\nIntegrate out random effects in bayesian brms models (see Bayesian analysis vignette)\n\nNew vignettes:\n\nExperiments\nExtending marginal effects\nIntegrating out random effects in bayesian models\n\nBug fixes and minor improvements:\n\nThe default value of conf_level in summary() and tidy() is now NULL, which inherits the conf_level value in the original comparisons/marginaleffects/predictions calls.\nFix typo in function names for missing “lnratioavgwts”\nInteractions with fixest::i() are parsed properly as categorical variables\nFor betareg objects, inference can now be done on all coefficients using deltamethod(). previously only the location coefficients were available.\nFor objects from crch package, a number of bugs have been fixed; standard errors should now be correct for deltamethod(), marginaleffects(), etc.\nFixed a bug in the tidy() function for glmmTMB models without random effects, which caused all t statistics to be identical.\n\n\n\n\n\nNew supported model class: gamlss. Thanks to Marcio Augusto Diniz.\nmarginalmeans() accepts a wts argument with values: “equal”, “proportional”, “cells”.\nby argument\n\naccepts data frames for complex groupings.\nin marginalmeans only accepts data frames.\naccepts “group” to group by response level.\nworks with bayesian models.\n\nbyfun argument for the predictions() function to aggregate using different functions.\nhypothesis argument\n\nThe matrix column names are used as labels for hypothesis tests.\nBetter labels with “sequential”, “reference”, “pairwise”.\nnew shortcuts “revpairwise”, “revsequential”, “revreference”\n\nwts argument is respected in by argument and with *avg shortcuts in the transform_pre argument.\ntidy.predictions() and tidy.marginalmeans() get a new transform_avg argument.\nNew vignettes:\n\nUnit-level contrasts in logistic regressions. Thanks to (arthur-albuquerque?).\nPython Numpy models in marginaleffects. Thanks to timpipeseek.\nBootstrap example in standard errors vignette.\n\n\n\n\n\nBreaking changes:\n\nby is deprecated in summary() and tidy(). Use the same by argument in the main functions instead: comparisons(), marginaleffects(), predictions()\nCharacter vectors are no longer supported in the variables argument of the predictions() function. Use newdata=\"fivenum\" or “grid”, “mean”, or “median” instead.\n\nCritical bug fix:\n\nContrasts with interactions were incorrect in version 0.6.0. The error should have been obvious to most analysts in most cases (weird-looking alignment). Thanks to (vmikk?).\n\nNew supported packages and models:\n\nsurvival::clogit\nbiglm: The main quantities can be computed, but not the delta method standard errors. See https://github.com/vincentarelbundock/marginaleffects/issues/387\n\nNew vignette:\n\nElasticity\nFrequently Asked Questions\n\nNew features:\n\nElasticity and semi-elasticity using the new slope argument in marginaleffects(): eyex, dyex, eydx\ndatagrid() accepts functions: datagrid(newdata = mtcars, hp = range, mpg = fivenum, wt = sd)\nNew datagridcf() function to create counterfactual datasets. This is a shortcut to the datagrid() function with default to grid_type = \"counterfactual\"\nNew by arguments in predictions(), comparisons(), marginaleffects()\nNew newdata shortcuts: “tukey”, “grid”\nNew string shortcuts for transform_pre in comparisons()\nmarginalmeans() now back transforms confidence intervals when possible.\nvcov argument string shortcuts are now case-insensitive\nThe default contrast in comparisons() for binary predictors is now a difference between 1 and 0, rather than +1 relative to baseline.\ndocumentation improvements\n\n\n\n\nNew supported packages and models:\n\ntidymodels objects of class tidy_model are supported if the fit engine is supported by marginaleffects.\n\nNew function:\n\ndeltamethod(): Hypothesis tests on functions of parameters\nplot_cco(): Plot conditional contrasts\n\nNew arguments:\n\nhypothesis for hypothesis tests and custom contrasts\ntransform_post in predictions()\nwts argument in predictions() only affects average predictions in tidy() or summary().\n\nNew or improved vignettes:\n\nHypothesis Tests and Custom Contrasts using the Delta Method: https://marginaleffects.com/vignettes/hypothesis.html\nMultiple Imputation: https://marginaleffects.com/vignettes/multiple_imputation.html\nCausal Inference with the g-Formula: https://marginaleffects.com/vignettes/gcomputation.html (Thanks to Rohan Kapre for the idea)\n\nDeprecated or renamed arguments:\n\ncontrast_factor and contrast_numeric arguments are deprecated in comparisons(). Use a named list in the variables argument instead. Backward compatibility is maintained.\nThe transform_post argument in tidy() and summary() is renamed to transform_avg to disambiguate against the argument of the same name in comparisons(). Backward compatibility is preserved.\n\nMisc:\n\ntidy.predictions() computes standard errors using the delta method for average predictions\nSupport gam models with matrix columns.\neps in marginaleffects() is now “adaptive” by default: it equals 0.0001 multiplied the range of the predictor variable\ncomparisons() now supports “log of marginal odds ratio” in the transform_pre argument. Thanks to Noah Greifer.\nNew transform_pre shortcuts: dydx, expdydx\ntidy.predictions() computes standard errors and confidence intervals for linear models or GLM on the link scale.\n\n\n\n\nBreaking changes:\n\ntype no longer accepts a character vector. Must be a single string.\nconf.int argument deprecated. Use vcov = FALSE instead.\n\nNew supported packages and models:\n\nmlogit\nmhurdle\ntobit1\nglmmTMB\n\nNew features:\n\ninteraction argument in comparisons() to compute interactions between contrasts (cross-contrasts).\nby argument in tidy() and summary() computes group-average marginal effects and comparisons.\ntransform_pre argument can define custom contrasts between adjusted predictions (e.g., log adjusted risk ratios). Available in comparisons().\ntransform_post argument allows back transformation before returning the final results. Available in comparisons(), marginalmeans(), summary(), tidy().\nThe variables argument of the comparisons() function accepts a named list to specify variable-specific contrast types.\nRobust standard errors with the vcov argument. This requires version 0.17.1 of the insight package.\n\nsandwich package shortcuts: vcov = \"HC3\", \"HC2\", \"NeweyWest\", and more.\nMixed effects models: vcov = \"satterthwaite\" or \"kenward-roger\"\nOne-sided formula to clusters: vcov = ~cluster_variable\nVariance-covariance matrix\nFunction which returns a named squared matrix\n\nmarginalmeans() allows interactions\nBayesian Model Averaging for brms models using type = \"average\". See vignette on the marginaleffects website.\neps argument for step size of numerical derivative\nmarginaleffects and comparisons now report confidence intervals by default.\nNew dependency on the data.table package yields substantial performance improvements.\nMore informative error messages and warnings\nBug fixes and performance improvements\n\nNew pages on the marginaleffects website: https://marginaleffects.com/\n\nAlternative software packages\nRobust standard errors (and more)\nPerformance tips\nTables and plots\nMultinomial Logit and Discrete Choice Models\nGeneralized Additive Models\nMixed effects models (Bayesian and Frequentist)\nTransformations and Custom Contrasts: Adjusted Risk Ratio Example\n\nArgument name changes (backward compatibility is preserved:\n\nEverywhere:\n\nconf.level -&gt; conf_level\n\ndatagrid():\n\nFUN.factor -&gt; FUN_factor (same for related arguments)\ngrid.type -&gt; grid_type\n\n\n\n\n\nNew supported packages and models:\n\nstats::loess\nsampleSelection::selection\nsampleSelection::heckit\n\nMisc:\n\nmgcv::bam models allow exclude argument.\nGam models allow include_smooth argument.\nNew tests\nBug fixes\n\n\n\n\nNew function:\n\ncomparisons() computes contrasts\n\nMisc:\n\nSpeed optimizations\npredictions() and plot_cap() include confidence intervals for linear models\nMore robust handling of in-formula functions: factor(), strata(), mo()\nDo not overwrite user’s ggplot2::theme_set() call\n\n\n\n\n\nBug fixes\n\n\n\n\nNew supported models:\n\nmclogit::mclogit\nrobust::lmRob\nrobustlmm::rlmer\nfixest confidence intervals in predictions\n\nMisc:\n\nSupport modelbased::visualisation_matrix in newdata without having to specify x explicitly.\ntidy.predictions() and summary.predictions() methods.\nDocumentation improvements.\nCRAN test fixes\n\n\n\n\nSupport for new models and packages:\n\nbrglm2::bracl\nmclogit::mblogit\nscam::scam\nlmerTest::lmer\n\nMisc:\n\nDrop numDeriv dependency, but make it available via a global option: options(“marginaleffects_numDeriv” = list(method = “Richardson”, method.args = list(eps = 1e-5, d = 0.0001)))\nBugfixes\nDocumentation improvements\nCRAN tests\n\n\n\n\ndocumentation bugfix\n\n\n\nBreaking changes:\n\npredictions returns predictions for every observation in the original dataset instead of newdata=datagrid().\nmarginalmeans objects have new column names, as do the corresponding tidy and summary outputs.\n\nNew supported packages and models:\n\nbrms::brm\nrstanarm::stanglm\nbrglm2::brmultinom\nMASS::glmmPQL\naod::betabin\n\nMisc:\n\ndatagrid function supersedes typical and counterfactual with the grid.type argument. The typical and counterfactual functions will remain available and exported, but their use is not encouraged.\nposterior_draws function can be applied to a predictions or a marginaleffects object to extract draws from the posterior distribution.\nmarginalmeans standard errors are now computed using the delta method.\npredictions standard errors are now computed using the delta method when they are not available from insight::get_predicted.\nNew vignette on Bayesian models with brms\nNew vignette on Mixed effects models with lme4\nIf the data.table package is installed, marginaleffects will automatically use it to speed things up.\nContrast definition reported in a separate column of marginaleffects output.\nSafer handling of the type argument.\nComprehensive list of supported and tests models on the website.\nMany bug fixes\nMany new tests, including several against emmeans\n\n\n\n\nBreaking change:\n\ndata argument becomes newdata in all functions.\n\nNew supported packages and models:\n\nlme4:glmer.nb\nmgcv::gam\nordinal::clm\nmgcv\n\nmarginalmeans:\n\nNew variables_grid argument\n\npredictions:\n\nSupport mgcv\n\nplot_cap\n\nNew type argument\n\nMisc:\n\nNew validity checks and tests\n\n\n\n\nFirst release. Bravo!\nThanks to Marco Avina Mendoza, Resul Umit, and all those who offered comments and suggestions.",
    "crumbs": [
      "Model to Meaning",
      "News"
    ]
  },
  {
    "objectID": "NEWS.html#development",
    "href": "NEWS.html#development",
    "title": "News",
    "section": "",
    "text": "Bugs:\n\nsystemfit models returned no standard errors when the same variables entered in different parts of the model. Thanks to (mronkko?) for report #1233.",
    "crumbs": [
      "Model to Meaning",
      "News"
    ]
  },
  {
    "objectID": "NEWS.html#section",
    "href": "NEWS.html#section",
    "title": "News",
    "section": "",
    "text": "Breaking change:\n\nSupport for mlogit is deprecated. The reason is that the data structure for these models is one observation-choice per row. Every other model-fitting package supported by marginaleffects treats rows as individual observations. The observation-choice structure made it harder to track indices and match individual predictions to rows in the original data. This added a lot of complexity to marginaleffects, and the results were not always reliable or safe.\n\nBugs:\n\nImproved glmmTMB support\n\nStandard errors are produced in models with type=\"zprob\". Thanks to (jgeller112?) for issue #1189.\nhypotheses() bug resolved. Thanks to (reikookamoto?) for the code submission.\n\nmultinom_weightit models with insight version 0.20.4 and greater would produce an error. Thanks to Noah Greifer.\nhypotheses(joint = TRUE) would throw an error if sample sizes could not be computed, even if they were not needed. Thanks to Noah Greifer.\nhypotheses(joint = TRUE) respects the vcov argument. Thanks to (kennchua?) for report #1214.\nordbetareg models in glmmTMB are now supported. Thanks to (jgeller112?) for code contribution #1221.\ntidymodels(): Indexing overrode the value of predictors in the output data frame. The numerical estimates were unaffected. Thanks to (agmath?) for report #1209.",
    "crumbs": [
      "Model to Meaning",
      "News"
    ]
  },
  {
    "objectID": "NEWS.html#section-1",
    "href": "NEWS.html#section-1",
    "title": "News",
    "section": "",
    "text": "Breaking changes:\n\ntype=\"invlink(link)\" is no longer default in avg_predictions() or when calling predictions() with the by argument. It is still default in predictions() without the by argument. The backtransform strategy is still available with by setting type=\"invlink(link)\" explicitly.\nThe type argument in plot_comparisons() now defaults to NULL, which is now consistent with comparisons() and avg_comparisons(). Before, the default was type=\"response\". Thanks to (giakhang1906?) for report #1202.\n\nNew models supported:\n\nstpm2, pstpm2, gsm, and aft models from rstpm2. Thanks to (aghaynes?) and (mclements?).\nglm_weightit, coxph_weightit, multinom_weightit, and ordinal_weightit models from Weightit. Thanks to (ngreifer?).\nglmmgee from the glmtoolbox package. Thanks to (adrianolszewski?) for the request and (lhvanegasp?) for help with implementation.\n\nNew features:\n\nParallel computation with future is more efficient by chunking tasks to avoid passing large objects to every worker for every future. Issue #1158.\nAll columns of newdata are passed to the hypothesis function when newdata is supplied explicitly. Thanks to (gravesti?) for report #1175.\nhypotheses(joint=TRUE): do not call stats::nobs() unless necessary.\nhypotheses() supports formulas in the hypothesis argument: hypotheses(model, hypothesis = ratio ~ reference)\nGlobal option: options(\"marginaleffects_print_omit\" = \"s.value\")\nRound significant digits for labels in plot_predictions(mod, condition = list(x = \"fivenum\"))\nprint() no longer prints contrast and term columns when values are unique. The labels were often very long, and the content is already explicit in the call itself, so there’s no ambiguity.\nNo warning raised when discrete argument is used with mgcv::bam and mgcv::gam models objects. Thanks to (Aariq?) for the request.\ntidymodels support is improved. Users can now directly feed some of them without specifying newdata explicitly. Thanks to (davidkane9?) for the feature request.\n\nBugs:\n\nAverage lift and average comparisons with user-supplied functions could be be calculated incorrectly when all predictors were categorical. Thanks to (Dpananos?) for Issue #1151.\nIndexing bug returned NA for some commands in survey models. Thanks to (weikang9009?) for report #1161.\nRespect default tinytable theme.\nInverted confidence interval bounds with some inverse link functions. Thanks to (strengejacke?) for report #1204.",
    "crumbs": [
      "Model to Meaning",
      "News"
    ]
  },
  {
    "objectID": "NEWS.html#section-2",
    "href": "NEWS.html#section-2",
    "title": "News",
    "section": "",
    "text": "New:\n\nhypothesis accepts formulas like: ratio ~ sequential | group\nAllow reverse binary contrasts: comparisons(mod, variables = list(am = 1:0, vs = 0:1)). Thanks to K. Henry for report #1137.\noptions(marginaleffects_safe = FALSE) disables some safety checks and allows unadvisable (but potentially) useful features like many pairwise comparisons. Thanks to D.Locke for the feature request.\nnewdata=\"balanced\" is a shortcut to produce estimates at combinations of all categorical predictors, holding numeric predictors at their means. Equivalent to datagrid(grid_type=\"balanced\")\n\nMisc:\n\nDeprecation warning for specify_hypothesis(). This function was clearly marked as experimental, and has been available only for one release. It was a bad idea. Users should supply a custom function or a formula to the hypothesis argument. The new formula interface, in particular, makes it very easy to conduct group-wise hypothesis tests.\nType checks are a bit looser to accommodate custom models.\n\nBugs:\n\nFix regression in mlogit models due to factor conversion. This raised an error before returning result, so there is no numerical danger.\nsurvey package models work when row.names(model) is not coercible to integers. Thanks to (ngreifer?) for report #1131.",
    "crumbs": [
      "Model to Meaning",
      "News"
    ]
  },
  {
    "objectID": "NEWS.html#section-3",
    "href": "NEWS.html#section-3",
    "title": "News",
    "section": "",
    "text": "The comparison argument of the comparisons() function is automatically switched to the avg version of the function shortcuts when calling avg_comparisons() or setting by=TRUE. For example, comparison=\"ratio\" becomes comparison=\"ratioavg\" when calling avg_comparisons(). Note that comparison=\"ratioavg\" is equivalent to: comparison = \\(hi,lo) mean(hi)/mean(lo)\nFixed a bug (“non-conformable arguments”) when using survreg objects from survival::survreg().\nFixed bug in inferences() for GLM models and type=\"invlink\", where the wrong scale would be reported for confidence intervals.",
    "crumbs": [
      "Model to Meaning",
      "News"
    ]
  },
  {
    "objectID": "NEWS.html#section-4",
    "href": "NEWS.html#section-4",
    "title": "News",
    "section": "",
    "text": "Breaking changes:\n\nThe order of the group column is preserved when the original variable is a factor. This may change the order of output, which could have an effect on hypothesis tests using the hypothesis=\"b1=b3\" syntax.\n\nNew:\n\nNew experimental function: specify_hypothesis() returns functions to be used in the hypothesis argument of predictions(), comparisons(), and slopes(). This convenience function can be used to specify complex aggregations and estimands for hypothesis tests (ex: by subgroups or with custom functions).\nhypothesis argument accepts “meandev” and “meanotherdev” to compute deviations from the mean estimate.\nDo not raise extraneous warning for survey package models when the by argument is not used.\nInformative error when hypotheses() is called twice on the same object.\nprint(\"tinytable\") adds footnotes to the table with columns and type information.\n\nBugs:\n\nmlogit predict() method does not play well with data.table. Thanks to (andrewheiss?) for report #1086.\nAvoid merging newdata in predictions() when hypothesis can change the meaning of rows. Avoid Issue #1105 reported by (strengejacke?).\ninferences() did not work with the transform argument. Thanks to Demetri Pananos for report #1115.",
    "crumbs": [
      "Model to Meaning",
      "News"
    ]
  },
  {
    "objectID": "NEWS.html#section-5",
    "href": "NEWS.html#section-5",
    "title": "News",
    "section": "",
    "text": "Breaking changes:\n\ndatagrid() no longer includes the response variable by default when it is not explicitly specified by the user. Use the new response argument to include it.\ndatagrid(grid_type=\"balanced\") returns factors ordered by level rather than by order of appearance in the original data.\nOrder of some rows in the output may differ when using datagrid(). Necessary to fix issue #1079 (see below).\n\nNew modeling packages supported:\n\nflexsurv: Thanks to (mattwarkentin?) for code contributions in PR #781. https://cran.r-project.org/web/packages/flexsurv/index.html\nREndo: https://cran.r-project.org/web/packages/REndo/index.html\n\nNew:\n\nwts=TRUE tries to retrieves weights used in a weighted fit such as lm() with the weights argument or a model fitted using the survey package. Thanks to (ngreifer?) for feature request\nprint.marginaleffects() supports style=\"tinytable\", which returns a tinytable object. Call print(avg_slopes(model)) to get a nice printed table in Quarto or Rmarkdown documents, via Typst, LaTeX or HTML. Default print format can be set using: options(marginaleffects_print_style=\"tinytable\")\nhypothesis argument accepts a function which takes a marginaleffects data frame and returns a transformed data frame with term and estimate columns.\ndatagrid() gets a response argument (default is FALSE) to control if the response variable is included or excluded from the grid-building process.\nThe base::subset() and dplyr::filter() functions can be called with a single argument in newdata to select a subset of rows from the dataset used to fit the model.\n\nEx: avg_comparisons(fit, variables = “treatment”, newdata = subset(treatment == 1))`\n\nBetter warning for unsupported arguments.\ndf argument in hypotheses() accepts a vector of length 2 to control degrees of freedom in F tests.\nnlme::lme() objects raise a warning about degrees of freedom. Thanks to and (stefgehrig?) and (huftis?) for discussion in Issue #960.\n\nMajor bugs:\n\nSome results could be mislabelled with factor variables used in combination with datagrid() or condition. Thanks to (snhansen?) for report #1079.\nglmmTMB models now report correct standard errors, and raise a warning that these standard errors only account for uncertainty in fixed effect parameters. Thanks to contributors to Issue #1024 and especially to (bbolker?) for discussion and solution.\n\nMinor bugs:\n\nUninformative error when a custom comparison function returns NA in bayesian models. Thanks to (Sandhu-SS?) for report #1017.\ndatagrid() returns an object with full attributes when by is used. Thanks to (Sandhu-SS?) for report #1058.\ninferences(method=\"simulation\") with inferences() function. Thanks to (davidarmstrong?) for report #1054.",
    "crumbs": [
      "Model to Meaning",
      "News"
    ]
  },
  {
    "objectID": "NEWS.html#section-6",
    "href": "NEWS.html#section-6",
    "title": "News",
    "section": "",
    "text": "This release represents a major step towards 1.0.0. Some functions are renamed and now raise deprecation warnings. After 1.0.0, the API will become much more stable, and any change will have to be very deliberate with much lead time and deprecation delays.\nBreaking changes:\n\ntidy() no longer takes the average of estimates in the original model object. Users who want an aggregate estimate should call the relevant avg_*() function, or use the by argument explicitly. The previous behavior led to unexpected behavior and increased code complexity a lot.\nsummary() methods are removed. These have never provided any additional information; they just reprinted the output already available with the standard print method. At least the default summary() for data frames (which is now triggered on marginaleffects object) provides a different view on the content of the object.\nplot_cco(), plot_cme(), and plot_cap() were renamed in version 0.9.0, one year ago. They are now fully removed from the package.\n\nNew:\n\ndatagrid(grid_type = \"balanced\") creates a balanced grid with all unique values of categorical predictors. This can be used with predictions() to compute marginal means as in the emmeans package.\nmvgam package support (multivariate generalized additive models)\n\nDeprecation warnings:\n\ndeltamethod() has been named hypotheses() for a while. We now issue a deprecation warning and it will be removed eventually.\ndatagridcf() will eventually be deprecated and removed from the package. We will raise a warning for at least one year before removing the function. Identical results can be obtained with datagrid(..., grid_type=\"counterfactual\")\nmarginal_means() will eventually be deprecated and removed from the package. We will raise a warning for at least one year before removing the function. Identical results can be obtained using the predictions() function and the grid_type=\"balanced\" argument of datagrid(). Examples are in the marginal means vignette on the website.\n\nMinor:\n\nBetter warning messages for unsupported matrix columns, enhancing user experience and troubleshooting.\nVarious improvements to documentation.\nTypos\nRepository hosts model objects for easier testing.\n\nBug fixes:\n\nError on hypotheses(joint = \"string\") for comparisons() objects (no result was returned). Thanks to (BorgeJorge?) for report #981.\nEnhanced support for multi-equation Bayesian models with brms models. Thanks to (winterstat?) for report #1006.\nParameter names with spaces could break standard errors. Thanks to (Lefty2021?) for report #1005.",
    "crumbs": [
      "Model to Meaning",
      "News"
    ]
  },
  {
    "objectID": "NEWS.html#section-7",
    "href": "NEWS.html#section-7",
    "title": "News",
    "section": "",
    "text": "Breaking changes:\n\nThe comparisons() now uses “forward contrasts” by default for numeric predictors, instead of “centered contrasts”. This can lead to small numerical differences in non-linear models.\nThe variables argument of the comparisons() function no longer accepts numeric vectors unless they are of length 2, specifying the low and high contrast values. This is to avoid ambiguity between the two vector version. Users should supply a data frame or a function instead. This is nearly as easy, and removes ambiguity.\n\nNew supported packages:\n\ndbarts: https://cran.r-project.org/package=dbarts\nmvgam: https://nicholasjclark.github.io/mvgam/ Not available on CRAN yet, but this package maintains its own marginaleffects support function.\nrms::Gls: https://cran.r-project.org/package=rms\n\nMisc:\n\ncomparisons(): The variables argument now accepts functions and data frames for factor, character, and logical variables.\nDeprecation warning for: plot_cap(), plot_cme(), and plot_cco(). These function names will be removed in version 1.0.0.\noptions(modelsummary_factory_default=...) is respected in Quarto and Rmarkdown documents.\n\nBugs:\n\nwts argument now respected in avg_slopes() for binary variables. Thanks to (trose64?) for report #961\nCustom functions in the comparison argument of comparisons() did not supply the correct x vector length for bayesian models when the by argument is used. Thanks to (Sandhu-SS?) for report #931.\nAdd support for two facet variables (through facet_grid) when plotting using condition\ncomparisons(): When variables is a vector of length two and newdata has exactly two columns, there was ambiguity between custom vectors and length two vector of contrasts. Bug reported by C. Rainey on Twitter.\nSuperfluous warning with fixest::fenegbin.",
    "crumbs": [
      "Model to Meaning",
      "News"
    ]
  },
  {
    "objectID": "NEWS.html#section-8",
    "href": "NEWS.html#section-8",
    "title": "News",
    "section": "",
    "text": "Machine learning support:\n\ntidymodels package\nmlr3 package\n\nMisc:\n\nNew vignettes:\n\nInverse Probability Weighting\nMachine Learning\nMatching\n\nAdd support for hypotheses() to inferences(). Thanks to (Tristan-Siegfried?) for code contribution #908.\nSupport survival::survreg(). Thanks to Carlisle Rainey for Report #911.\ncolumn_names argument in print.marginaleffects() to suppress the printed column names at the bottom of the printout.\nThe function supplied to the comparison argument of the comparisons() function can now operate on x and on newdata directly (e.g., to check the number of observations).\nMore informative errors from predict().\n\nBugs:\n\nSome gamlss models generated an error related to the what argument. Thanks to (DHLocke?) for Issue #933",
    "crumbs": [
      "Model to Meaning",
      "News"
    ]
  },
  {
    "objectID": "NEWS.html#section-9",
    "href": "NEWS.html#section-9",
    "title": "News",
    "section": "",
    "text": "hypotheses(): The FUN argument handles group columns gracefully.\nNative support for Amelia for multiple imputation.\n\nDocumentation:\n\nNew section on “Complex aggregations” in the Hypothesis testing vignette.\n\nBug fix:\n\nResults of the predictions() function could be inaccurate when (a) running version 0.15.0, (b) type is NULL or invlink(link), (c) model is glm(), and (d) the hypothesis argument is non-numeric. Thanks to (strengejacke?) for report #903",
    "crumbs": [
      "Model to Meaning",
      "News"
    ]
  },
  {
    "objectID": "NEWS.html#section-10",
    "href": "NEWS.html#section-10",
    "title": "News",
    "section": "",
    "text": "New:\n\nConformal prediction via inferences()\nhypothesis argument now accepts multiple string formulas.\nThe type argument now accepts an explicit invlink(link) value instead of silently back-transforming. Users are no longer pointed to type_dictionary. Instead, they should call their function with a bad type value, and they will obtain a list of valid types. The default type value is printed in the output. This is useful because the default type value is NULL, so the user often does not explicitly decide.\nAllow install with Rcpp 1.0.0 and greater.\n\nSupport new models:\n\nsurvey::svyolr()\n\nMisc:\n\ninferences(method=\"simulation\") uses the original point estimate rather than the mean of the simulation distribution. Issue #851.\nBetter documentation and error messages for newdata=NULL\nSome performance improvements for predictions() and marginalmeans() (#880, #882, (etiennebacher?)).\n\nBug fix:\n\nnewdata=\"median\" returned mean of binary variables. Thanks to (jkhanson1970?) for report #896.",
    "crumbs": [
      "Model to Meaning",
      "News"
    ]
  },
  {
    "objectID": "NEWS.html#section-11",
    "href": "NEWS.html#section-11",
    "title": "News",
    "section": "",
    "text": "Breaking changes:\n\nRow order of the output changes for some objects. Rows are not sorted alphabetically by term, by, and variables explicitly supplied to datagrid. This can affect hypothesis tests computed using the b1, b2, b3, and other indices.\nNew procedure numderiv argument use a different procedure to select the step size used in the finite difference numeric derivative used to compute standard errors: abs(x) * sqrt(.Machine$double.eps). The numerical results may not be exactly identical to previous versions of marginaleffects, but the step size should be adequate in a broader variety of cases. Note that users can use the numderiv argument for more control on numeric differentiation, as documented.\nbife models are no longer supported pending investigation in weird results in the tests. Looking for volunteers write more thorough tests.\n\nNew:\n\nSupport: logistf package.\nSupport: DCchoice package.\nSupport: stats::nls\nhypotheses() can now accept raw data frame, which gives a lot of flexibility for custom contrasts and functions. See the Hypothesis vignette for an example.\nnumderiv argument allows users to use finite difference (center or forward) or Richardson’s method to compute the numerical derivatives used in the calculation of standard errors.\n\nBug fixes:\n\ninferences() supports the cross argument for comparisons() objects. Thanks to Kirill Solovev for report #856.\nsplines::bs() in formulas could produce incorrect results due to weirdness in stats::model.matrix(). Thanks to (chiungming?) for report #831.\nmgcv with ocat are now supported. Thanks to Lorenzo Fabbri for Issue #844.\nquantreg problem with rowid merge did not affect estimates but did not return the full original data. Issue #829.\nget_modeldata() extracts weights variable when available.\npredictions() is no longer broken in some inferences() calls. Issue #853\nInaccurate averaging with comparison=differenceavg some models where all predictors are categorical. Thanks to Karl Ove Hufthammer for report #865.\n\nMisc:\n\nMajor refactor to simplify the code base and make maintenance easier.",
    "crumbs": [
      "Model to Meaning",
      "News"
    ]
  },
  {
    "objectID": "NEWS.html#section-12",
    "href": "NEWS.html#section-12",
    "title": "News",
    "section": "",
    "text": "Breaking change:\n\nglmmTMB: Standard errors are no longer supported because they may have been erroneous. Follow Issue #810 on Github for developments: https://github.com/vincentarelbundock/marginaleffects/issues/810\n\nNew:\n\nhypothesis argument accepts wildcards: hypothesis = \"b*=b1\"\ns.value column in all output: Shannon transforms for p values. See Greenland (2019).\nmarginal_means supports mira (mice objects).\ncomparisons(): The variables arguments now accepts arbitrary numeric vectors of length equal to the number of rows in newdata. This allows users to specify fully custom treatment sizes. In the documentation examples, we show how to estimate the difference for a 1 standard deviation shift in a regressor, where the standard deviation is calculated on a group-wise basis.\ncomparisons(): the variables argument now accepts “revpairwise”, “revsequential”, “revreference” for factor and character variables.\ncomparisons(): the comparison argument now accept “lift” and “liftavg”.\n\nPerformance:\n\nComputing elasticities for linear models is now up to 30% faster (#787, (etiennebacher?)).\n\nBug fixes:\n\nBetter handling of environments when newdata is a function call. Thanks to (jcccf?) for report #814 and to (capnrefsmmat?) for the proposed fix using the rlang package.\nDegrees of freedom mismatch for joint hypothesis tests. Thanks to (snhansen?) for report #789.",
    "crumbs": [
      "Model to Meaning",
      "News"
    ]
  },
  {
    "objectID": "NEWS.html#section-13",
    "href": "NEWS.html#section-13",
    "title": "News",
    "section": "",
    "text": "Breaking change:\n\nRow order of output has changed for many calls, especially those using the by argument. This may break hypothesis tests conducted by indexing b1, b2, etc. This was necessary to fix Issue #776. Thanks to (marcora?) for the report.\n\nNew:\n\nhypotheses(): Joint hypothesis tests (F and Chi-square) with the joint and joint_test arguments.\nvcov.hypotheses method.\nwts is now available in plot_predictions(), plot_comparisons(), and plot_slopes().\n\nBug:\n\nWrong order of rows in bayesian models with by argument. Thanks to (shirdekel?) for report #782.",
    "crumbs": [
      "Model to Meaning",
      "News"
    ]
  },
  {
    "objectID": "NEWS.html#section-14",
    "href": "NEWS.html#section-14",
    "title": "News",
    "section": "",
    "text": "vcov() and coef() methods for marginaleffects objects.\nStrings in wts are accepted with the by argument.\npredictions() and avg_predictions() no longer use an automatic backtransformation for GLM models unless hypothesis is NULL.\nvcov() can be used to retrieve a full variance-covariance matrix from objects produced by comparisons(), slopes(), predictions(), or marginal_means() objects.\nWhen processing objects obtained using mice multiple imputation, the pooled model using mice::pool is attached to the model attribute of the output. This means that functions like modelsummary::modelsummary() will not erroneously report goodness-of-fit statistics from just a single model and will instead appropriately report the statistics for the pooled model. Thanks to (Tristan-Siegfried?) for PR #740.\nMore informative error messages on some prediction problems. Thanks to (andymilne?) for Report #751.\n\nPerformance:\n\ninferences() is now up to 17x faster and much more memory-efficient when method is \"boot\" or \"rsample\" (#770, #771, (etiennebacher?)).\n\nBugs:\n\nbrms models with nl=TRUE and a single predictor generated an error. Thanks to (Tristan-Siegried?) for Report #759.\navg_predictions(): Incorrect group-wise averaging when all predictors are categorical, the variables variable is used, and we are averaging with avg_ or the by argument. Thanks to BorgeJorge for report #766.\nBug when datagrid() when called inside a user-written function. Thanks to (NickCH-K?) for report #769 and to (capnrefsmmat?) for the diagnostics.",
    "crumbs": [
      "Model to Meaning",
      "News"
    ]
  },
  {
    "objectID": "NEWS.html#section-15",
    "href": "NEWS.html#section-15",
    "title": "News",
    "section": "",
    "text": "Breaking change:\n\nRow orders are now more consistent, but may have changed from previous version. This could affect results from hypothesis with b1, b2, … indexing.\n\nSupport new models:\n\nnlme::lme()\nphylolm::phylolm()\nphylolm::phyloglm()\n\nNew:\n\nVignette on 2x2 experimental designs. Thanks to Demetri Pananos.\ncomparisons() accepts data frames with two numeric columns (“low” and “high”) to specify fully customizable contrasts.\ndatagrid() gets a new by argument to create apply grid-making functions within groups.\nplot_*() gain a newdata argument for use with by.\n\nBug:\n\ncomparisons(comparison = \"lnratioavg\") ignored wts argument. Thanks to Demetri Pananos for report #737.\nordinal::clm(): incorrect standard errors when location and scale parameters are the same. Thanks to MrJerryTAO for report #718.\nIncorrect label for “2sd” comparisons. Thanks to Andy Milne for report #720.\nInvalid factor levels in datagrid() means newdata argument gets ignored. Thanks to Josh Errickson for report #721.\nError in models with only categorical predictors and the by argument. Thanks to Sam Brilleman for report #723.\nElasticities are now supported for ordinal::clm() models. Thanks to MrJerryTAO for report #729.\nglmmTMB models with zero-inflated components are supported. Thanks to (Helsinki-Ronan?) and (strengejacke?) for report #734.",
    "crumbs": [
      "Model to Meaning",
      "News"
    ]
  },
  {
    "objectID": "NEWS.html#section-16",
    "href": "NEWS.html#section-16",
    "title": "News",
    "section": "",
    "text": "Breaking changes:\n\ntype column is replaced by type attribute.\npredictions() only works with officially supported model types (same list as comparisons() and slopes()).\n\nRenamed arguments (backward compatibility is preserved):\n\ntransform_pre -&gt; comparison\ntransform_post -&gt; transform\n\nNew:\n\np_adjust argument: Adjust p-values for multiple comparisons.\nequivalence argument available everywhere.\n\nPerformance:\n\nMuch faster results in avg_*() functions for models with only categorical predictors and many rows of data, using deduplication and weights instead of unit-level estimates.\nFaster predictions in lm() and glm() models using RcppEigen.\nBayesian models with many rows. Thanks to Etienne Bacher. #694\nFaster predictions, especially with standard errors and large datasets.\n\nBugs:\n\nMultiple imputation with mira objects was not pooling all datasets. Thanks to (Generalized?) for report #711.\nSupport for more models with offsets. Thanks to (mariofiorini?) for report #705.\nError on predictions() with by and wts. Thanks to Noah Greifer for report #695.\nafex: some models generated errors. Thanks to Daniel Lüdecke for report #696.\ngroup column name is always forbidden. Thanks to Daniel Lüdecke for report #697.\nBlank graphs in plot_comparisons() with a list in variables.\ntype=\"link\" produced an error with some categorical brms models. Thanks to (shirdekel?) for report #703.\nError on predictions(variables = ...) for glmmTMB models. Thanks to Daniel Lüdecke for report #707.\nby with user-specified function in comparison and factor predictor did not aggregate correctly. Thanks to (joaotedde?) for report #715.\nordinal::clm: Support cum.prob and linear.predictor prediction types. Thanks to (MrJerryTAO?) for report #717.",
    "crumbs": [
      "Model to Meaning",
      "News"
    ]
  },
  {
    "objectID": "NEWS.html#section-17",
    "href": "NEWS.html#section-17",
    "title": "News",
    "section": "",
    "text": "Performance:\n\n2-4x faster execution for many calls. Thanks to Etienne Bacher.\n\nNew models supported:\n\nMCMCglmm::MCMCglmm\nRchoice::hetprob\nRchoice::ivpml\nMultiple imputation using mice and any package which can return a list of imputed data frames (e.g., Amelia, missRanger, etc.)\n\nPlot improvements:\n\nNew by argument to display marginal estimates by subgroup.\nNew rug argument to display tick marks in the margins.\nNew points argument in plot_predictions() to display a scatter plot.\nNew gray argument to plot in grayscale using line types and shapes instead of color.\nThe effect argument is renamed to variables in plot_slopes() and plot_comparisons(). This improves consistency with the analogous slopes() and comparisons() functions.\nThe plotting vignette was re-written.\n\nOther:\n\nSupport multiple imputation with mice mira objects. The multiple imputation vignette was rewritten.\nThe variables_grid argument in marginal_means() is renamed newdata. Backward compatibility is maintained.\navg_*() returns an informative error when vcov is “satterthwaite” or “kenward-roger”\n“satterthwaite” and “kenward-roger” are now supported when newdata is not NULL\nInformative error when hypothesis includes a b# larger than the available number of estimates.\navg_predictions(model, variables = \"x\") computes average counterfactual predictions by subgroups of x\ndatagrid() and plot_*() functions are faster in datasets with many extraneous columns.\nIn predictions(type = NULL) with glm() and Gam() we first make predictions on the link scale and then backtransform them. Setting type=\"response\" explicitly makes predictions directly on the response scale without backtransformation.\nStandard errors now supported for more glmmTMB models.\nUse the numDeriv package for numeric differentiation in the calculation of delta method standard error. A global option can now be passed to numDeriv::jacobian:\n\noptions(marginaleffects_numDeriv = list(method = \"simple\", method.args = list(eps = 1e-6)))\noptions(marginaleffects_numDeriv = list(method = \"Richardson\", method.args = list(eps = 1e-6)))\noptions(marginaleffects_numDeriv = NULL)\n\nPrint:\n\nPrint fewer significant digits.\nprint.marginaleffects now prints all columns supplied to newdata\nLess redundant labels when using hypothesis\n\nMany improvements to documentation.\n\nBugfixes:\n\nStandard errors could be inaccurate in models with non-linear components (and interactions) when some of the coefficients were very small. This was related to the step size used for numerical differentiation for the delta method. Issue #684.\navg_predictions(by =) did not work when the dataset included a column named term. Issue #683.\nbrms models with multivariate outcome collapsed categories in comparisons(). Issue #639.\nhypotheses() now works on lists and in calls to lapply(), purrr::map(), etc. Issue #660.",
    "crumbs": [
      "Model to Meaning",
      "News"
    ]
  },
  {
    "objectID": "NEWS.html#section-18",
    "href": "NEWS.html#section-18",
    "title": "News",
    "section": "",
    "text": "Breaking changes:\n\nAll functions return an estimate column instead of the function-specific predicted, comparisons, dydx, etc. This change only affects unit-level estimates, and not average estimates, which already used the estimate column name.\nThe transform_avg argument in tidy() deprecated. Use transform_post instead.\nplot_*(draw=FALSE) now return the actual variable names supplied to the condition argument, rather than the opaque “condition1”, “condition2”, etc.\n\nNew models supported:\n\nblme package.\n\nNew features:\n\nNew functions: avg_predictions(), avg_comparisons(), avg_slopes()\nEquivalence, non-inferiority, and non-superiority tests with the hypotheses() function and equivalence argument.\nNew experimental inferences() function: simulation-based inferences and bootstrap using the boot, rsample, and fwb package.\nNew df argument to set degrees of freedom manually for p and CI.\nPretty print() for all objects.\nby argument\n\nTRUE returns average (marginal) predictions, comparisons, or slopes.\nSupports bayesian models.\n\nhypothesis argument\n\nNumeric value sets the null used in calculating Z and p.\nExample: comparisons(mod, transform_pre = \"ratio\", hypothesis = 1)\n\nAll arguments from the main functions are now available through tidy(), and summary(): conf_level, transform_post, etc.\nBayesian posterior distribution summaries (median, mean, HDI, quantiles) can be customized using global options. See ?comparisons\n\nRenamed functions (backward-compatibility is maintained by keeping the old function names as aliases):\n\nmarginaleffects() -&gt; slopes()\nposteriordraws() -&gt; posterior_draws()\nmarginalmeans() -&gt; marginal_means()\nplot_cap() -&gt; plot_predictions()\nplot_cme() -&gt; plot_slopes()\nplot_cco() -&gt; plot_comparisons()\n\nBug fixes:\n\nIncorrect results: In 0.8.1, plot_*() the threenum and minmax labels did not correspond to the correct numeric values.\nFix corner case for slopes when the dataset includes infinite values.\nmlogit error with factors.\nThe vcov argument now accepts functions for most models.\n\nOther:\n\nRemoved major performance bottleneck for slopes()",
    "crumbs": [
      "Model to Meaning",
      "News"
    ]
  },
  {
    "objectID": "NEWS.html#section-19",
    "href": "NEWS.html#section-19",
    "title": "News",
    "section": "",
    "text": "deltamethod() can run hypothesis tests on objects produced by the comparisons(), marginaleffects(), predictions(), and marginalmeans() functions. This feature relies on match.call(), which means it may not always work when used programmatically, inside functions and nested environments. It is generally safer and more efficient to use the hypothesis argument.\nplot_cme() and plot_cco() accept lists with user-specified values for the regressors, and can display nice labels for shortcut string-functions like “threenum” or “quartile”.\nposterior_draws: new shape argument to return MCMC draws in various formats, including the new rvar structure from the posterior package.\ntransform_avg function gets printed in summary() output.\ntransform_post and transform_avg support string shortcuts: “exp” and “ln”\nAdded support for mlm models from lm(). Thanks to Noah Greifer.\n\nBug fixes:\n\nhypothesis argument with bayesian models and tidy() used to raise an error.\nMissing values for some regressors in the comparisons() output for brms models.",
    "crumbs": [
      "Model to Meaning",
      "News"
    ]
  },
  {
    "objectID": "NEWS.html#section-20",
    "href": "NEWS.html#section-20",
    "title": "News",
    "section": "",
    "text": "Breaking change:\n\nThe interaction argument is deprecated and replaced by the cross argument. This is to reduce ambiguity with respect to the interaction argument in emmeans, which does something completely different, akin to the difference-in-differences illustrated in the Interactions vignette.\n\n71 classes of models supported, including the new:\n\nrms::ols\nrms::lrm\nrms::orm\n\nNew features:\n\nPlots: plot_cme(), plot_cap(), and plot_cco() are now much more flexible in specifying the comparisons to display. The condition argument accepts lists, functions, and shortcuts for common reference values, such as “minmax”, “threenum”, etc.\nvariables argument of the comparisons() function is more flexible:\n\nAccepts functions to specify custom differences in numeric variables (e.g., forward and backward differencing).\nCan specify pairs of factors to compare in the variables argument of the comparisons function.\n\nvariables argument of the predictions() function is more flexible:\n\nAccepts shortcut strings, functions, and vectors of arbitrary length.\n\nIntegrate out random effects in bayesian brms models (see Bayesian analysis vignette)\n\nNew vignettes:\n\nExperiments\nExtending marginal effects\nIntegrating out random effects in bayesian models\n\nBug fixes and minor improvements:\n\nThe default value of conf_level in summary() and tidy() is now NULL, which inherits the conf_level value in the original comparisons/marginaleffects/predictions calls.\nFix typo in function names for missing “lnratioavgwts”\nInteractions with fixest::i() are parsed properly as categorical variables\nFor betareg objects, inference can now be done on all coefficients using deltamethod(). previously only the location coefficients were available.\nFor objects from crch package, a number of bugs have been fixed; standard errors should now be correct for deltamethod(), marginaleffects(), etc.\nFixed a bug in the tidy() function for glmmTMB models without random effects, which caused all t statistics to be identical.",
    "crumbs": [
      "Model to Meaning",
      "News"
    ]
  },
  {
    "objectID": "NEWS.html#section-21",
    "href": "NEWS.html#section-21",
    "title": "News",
    "section": "",
    "text": "New supported model class: gamlss. Thanks to Marcio Augusto Diniz.\nmarginalmeans() accepts a wts argument with values: “equal”, “proportional”, “cells”.\nby argument\n\naccepts data frames for complex groupings.\nin marginalmeans only accepts data frames.\naccepts “group” to group by response level.\nworks with bayesian models.\n\nbyfun argument for the predictions() function to aggregate using different functions.\nhypothesis argument\n\nThe matrix column names are used as labels for hypothesis tests.\nBetter labels with “sequential”, “reference”, “pairwise”.\nnew shortcuts “revpairwise”, “revsequential”, “revreference”\n\nwts argument is respected in by argument and with *avg shortcuts in the transform_pre argument.\ntidy.predictions() and tidy.marginalmeans() get a new transform_avg argument.\nNew vignettes:\n\nUnit-level contrasts in logistic regressions. Thanks to (arthur-albuquerque?).\nPython Numpy models in marginaleffects. Thanks to timpipeseek.\nBootstrap example in standard errors vignette.",
    "crumbs": [
      "Model to Meaning",
      "News"
    ]
  },
  {
    "objectID": "NEWS.html#section-22",
    "href": "NEWS.html#section-22",
    "title": "News",
    "section": "",
    "text": "Breaking changes:\n\nby is deprecated in summary() and tidy(). Use the same by argument in the main functions instead: comparisons(), marginaleffects(), predictions()\nCharacter vectors are no longer supported in the variables argument of the predictions() function. Use newdata=\"fivenum\" or “grid”, “mean”, or “median” instead.\n\nCritical bug fix:\n\nContrasts with interactions were incorrect in version 0.6.0. The error should have been obvious to most analysts in most cases (weird-looking alignment). Thanks to (vmikk?).\n\nNew supported packages and models:\n\nsurvival::clogit\nbiglm: The main quantities can be computed, but not the delta method standard errors. See https://github.com/vincentarelbundock/marginaleffects/issues/387\n\nNew vignette:\n\nElasticity\nFrequently Asked Questions\n\nNew features:\n\nElasticity and semi-elasticity using the new slope argument in marginaleffects(): eyex, dyex, eydx\ndatagrid() accepts functions: datagrid(newdata = mtcars, hp = range, mpg = fivenum, wt = sd)\nNew datagridcf() function to create counterfactual datasets. This is a shortcut to the datagrid() function with default to grid_type = \"counterfactual\"\nNew by arguments in predictions(), comparisons(), marginaleffects()\nNew newdata shortcuts: “tukey”, “grid”\nNew string shortcuts for transform_pre in comparisons()\nmarginalmeans() now back transforms confidence intervals when possible.\nvcov argument string shortcuts are now case-insensitive\nThe default contrast in comparisons() for binary predictors is now a difference between 1 and 0, rather than +1 relative to baseline.\ndocumentation improvements",
    "crumbs": [
      "Model to Meaning",
      "News"
    ]
  },
  {
    "objectID": "NEWS.html#section-23",
    "href": "NEWS.html#section-23",
    "title": "News",
    "section": "",
    "text": "New supported packages and models:\n\ntidymodels objects of class tidy_model are supported if the fit engine is supported by marginaleffects.\n\nNew function:\n\ndeltamethod(): Hypothesis tests on functions of parameters\nplot_cco(): Plot conditional contrasts\n\nNew arguments:\n\nhypothesis for hypothesis tests and custom contrasts\ntransform_post in predictions()\nwts argument in predictions() only affects average predictions in tidy() or summary().\n\nNew or improved vignettes:\n\nHypothesis Tests and Custom Contrasts using the Delta Method: https://marginaleffects.com/vignettes/hypothesis.html\nMultiple Imputation: https://marginaleffects.com/vignettes/multiple_imputation.html\nCausal Inference with the g-Formula: https://marginaleffects.com/vignettes/gcomputation.html (Thanks to Rohan Kapre for the idea)\n\nDeprecated or renamed arguments:\n\ncontrast_factor and contrast_numeric arguments are deprecated in comparisons(). Use a named list in the variables argument instead. Backward compatibility is maintained.\nThe transform_post argument in tidy() and summary() is renamed to transform_avg to disambiguate against the argument of the same name in comparisons(). Backward compatibility is preserved.\n\nMisc:\n\ntidy.predictions() computes standard errors using the delta method for average predictions\nSupport gam models with matrix columns.\neps in marginaleffects() is now “adaptive” by default: it equals 0.0001 multiplied the range of the predictor variable\ncomparisons() now supports “log of marginal odds ratio” in the transform_pre argument. Thanks to Noah Greifer.\nNew transform_pre shortcuts: dydx, expdydx\ntidy.predictions() computes standard errors and confidence intervals for linear models or GLM on the link scale.",
    "crumbs": [
      "Model to Meaning",
      "News"
    ]
  },
  {
    "objectID": "NEWS.html#section-24",
    "href": "NEWS.html#section-24",
    "title": "News",
    "section": "",
    "text": "Breaking changes:\n\ntype no longer accepts a character vector. Must be a single string.\nconf.int argument deprecated. Use vcov = FALSE instead.\n\nNew supported packages and models:\n\nmlogit\nmhurdle\ntobit1\nglmmTMB\n\nNew features:\n\ninteraction argument in comparisons() to compute interactions between contrasts (cross-contrasts).\nby argument in tidy() and summary() computes group-average marginal effects and comparisons.\ntransform_pre argument can define custom contrasts between adjusted predictions (e.g., log adjusted risk ratios). Available in comparisons().\ntransform_post argument allows back transformation before returning the final results. Available in comparisons(), marginalmeans(), summary(), tidy().\nThe variables argument of the comparisons() function accepts a named list to specify variable-specific contrast types.\nRobust standard errors with the vcov argument. This requires version 0.17.1 of the insight package.\n\nsandwich package shortcuts: vcov = \"HC3\", \"HC2\", \"NeweyWest\", and more.\nMixed effects models: vcov = \"satterthwaite\" or \"kenward-roger\"\nOne-sided formula to clusters: vcov = ~cluster_variable\nVariance-covariance matrix\nFunction which returns a named squared matrix\n\nmarginalmeans() allows interactions\nBayesian Model Averaging for brms models using type = \"average\". See vignette on the marginaleffects website.\neps argument for step size of numerical derivative\nmarginaleffects and comparisons now report confidence intervals by default.\nNew dependency on the data.table package yields substantial performance improvements.\nMore informative error messages and warnings\nBug fixes and performance improvements\n\nNew pages on the marginaleffects website: https://marginaleffects.com/\n\nAlternative software packages\nRobust standard errors (and more)\nPerformance tips\nTables and plots\nMultinomial Logit and Discrete Choice Models\nGeneralized Additive Models\nMixed effects models (Bayesian and Frequentist)\nTransformations and Custom Contrasts: Adjusted Risk Ratio Example\n\nArgument name changes (backward compatibility is preserved:\n\nEverywhere:\n\nconf.level -&gt; conf_level\n\ndatagrid():\n\nFUN.factor -&gt; FUN_factor (same for related arguments)\ngrid.type -&gt; grid_type",
    "crumbs": [
      "Model to Meaning",
      "News"
    ]
  },
  {
    "objectID": "NEWS.html#section-25",
    "href": "NEWS.html#section-25",
    "title": "News",
    "section": "",
    "text": "New supported packages and models:\n\nstats::loess\nsampleSelection::selection\nsampleSelection::heckit\n\nMisc:\n\nmgcv::bam models allow exclude argument.\nGam models allow include_smooth argument.\nNew tests\nBug fixes",
    "crumbs": [
      "Model to Meaning",
      "News"
    ]
  },
  {
    "objectID": "NEWS.html#section-26",
    "href": "NEWS.html#section-26",
    "title": "News",
    "section": "",
    "text": "New function:\n\ncomparisons() computes contrasts\n\nMisc:\n\nSpeed optimizations\npredictions() and plot_cap() include confidence intervals for linear models\nMore robust handling of in-formula functions: factor(), strata(), mo()\nDo not overwrite user’s ggplot2::theme_set() call",
    "crumbs": [
      "Model to Meaning",
      "News"
    ]
  },
  {
    "objectID": "NEWS.html#section-27",
    "href": "NEWS.html#section-27",
    "title": "News",
    "section": "",
    "text": "Bug fixes",
    "crumbs": [
      "Model to Meaning",
      "News"
    ]
  },
  {
    "objectID": "NEWS.html#section-28",
    "href": "NEWS.html#section-28",
    "title": "News",
    "section": "",
    "text": "New supported models:\n\nmclogit::mclogit\nrobust::lmRob\nrobustlmm::rlmer\nfixest confidence intervals in predictions\n\nMisc:\n\nSupport modelbased::visualisation_matrix in newdata without having to specify x explicitly.\ntidy.predictions() and summary.predictions() methods.\nDocumentation improvements.\nCRAN test fixes",
    "crumbs": [
      "Model to Meaning",
      "News"
    ]
  },
  {
    "objectID": "NEWS.html#section-29",
    "href": "NEWS.html#section-29",
    "title": "News",
    "section": "",
    "text": "Support for new models and packages:\n\nbrglm2::bracl\nmclogit::mblogit\nscam::scam\nlmerTest::lmer\n\nMisc:\n\nDrop numDeriv dependency, but make it available via a global option: options(“marginaleffects_numDeriv” = list(method = “Richardson”, method.args = list(eps = 1e-5, d = 0.0001)))\nBugfixes\nDocumentation improvements\nCRAN tests",
    "crumbs": [
      "Model to Meaning",
      "News"
    ]
  },
  {
    "objectID": "NEWS.html#section-30",
    "href": "NEWS.html#section-30",
    "title": "News",
    "section": "",
    "text": "documentation bugfix",
    "crumbs": [
      "Model to Meaning",
      "News"
    ]
  },
  {
    "objectID": "NEWS.html#section-31",
    "href": "NEWS.html#section-31",
    "title": "News",
    "section": "",
    "text": "Breaking changes:\n\npredictions returns predictions for every observation in the original dataset instead of newdata=datagrid().\nmarginalmeans objects have new column names, as do the corresponding tidy and summary outputs.\n\nNew supported packages and models:\n\nbrms::brm\nrstanarm::stanglm\nbrglm2::brmultinom\nMASS::glmmPQL\naod::betabin\n\nMisc:\n\ndatagrid function supersedes typical and counterfactual with the grid.type argument. The typical and counterfactual functions will remain available and exported, but their use is not encouraged.\nposterior_draws function can be applied to a predictions or a marginaleffects object to extract draws from the posterior distribution.\nmarginalmeans standard errors are now computed using the delta method.\npredictions standard errors are now computed using the delta method when they are not available from insight::get_predicted.\nNew vignette on Bayesian models with brms\nNew vignette on Mixed effects models with lme4\nIf the data.table package is installed, marginaleffects will automatically use it to speed things up.\nContrast definition reported in a separate column of marginaleffects output.\nSafer handling of the type argument.\nComprehensive list of supported and tests models on the website.\nMany bug fixes\nMany new tests, including several against emmeans",
    "crumbs": [
      "Model to Meaning",
      "News"
    ]
  },
  {
    "objectID": "NEWS.html#section-32",
    "href": "NEWS.html#section-32",
    "title": "News",
    "section": "",
    "text": "Breaking change:\n\ndata argument becomes newdata in all functions.\n\nNew supported packages and models:\n\nlme4:glmer.nb\nmgcv::gam\nordinal::clm\nmgcv\n\nmarginalmeans:\n\nNew variables_grid argument\n\npredictions:\n\nSupport mgcv\n\nplot_cap\n\nNew type argument\n\nMisc:\n\nNew validity checks and tests",
    "crumbs": [
      "Model to Meaning",
      "News"
    ]
  },
  {
    "objectID": "NEWS.html#section-33",
    "href": "NEWS.html#section-33",
    "title": "News",
    "section": "",
    "text": "First release. Bravo!\nThanks to Marco Avina Mendoza, Resul Umit, and all those who offered comments and suggestions.",
    "crumbs": [
      "Model to Meaning",
      "News"
    ]
  },
  {
    "objectID": "vignettes/citation.html",
    "href": "vignettes/citation.html",
    "title": "Citation and License",
    "section": "",
    "text": "Citation and License\nTo cite marginaleffects in publications, please use:\n\nArel-Bundock V, Greifer N, Heiss A (Forthcoming). “How to Interpret Statistical Models Using marginaleffects in R and Python.” Journal of Statistical Software.\n\n@Article{,\n    title = {How to Interpret Statistical Models Using {marginaleffects} in {R} and {Python}},\n    author = {Vincent Arel-Bundock and Noah Greifer and Andrew Heiss},\n    year = {Forthcoming},\n    journal = {Journal of Statistical Software},\n}\nThe marginaleffects software code is licenced under the GPLv3\nThe contents of this website and the Model to Meaning book are copyrighted and may not be reproduced without permission.\n© 2024 Vincent Arel-Bundock. All Rights Reserved.",
    "crumbs": [
      "Model to Meaning",
      "Citation and License"
    ]
  },
  {
    "objectID": "man/predictions.html",
    "href": "man/predictions.html",
    "title": "",
    "section": "",
    "text": "Outcome predicted by a fitted model on a specified scale for a given combination of values of the predictor variables, such as their observed values, their means, or factor levels (a.k.a. \"reference grid\").\n\n\npredictions(): unit-level (conditional) estimates.\n\n\navg_predictions(): average (marginal) estimates.\n\n\nThe newdata argument and the datagrid() function can be used to control where statistics are evaluated in the predictor space: \"at observed values\", \"at the mean\", \"at representative values\", etc.\nSee the predictions vignette and package website for worked examples and case studies:\n\n\nhttps://marginaleffects.com/vignettes/predictions.html\n\n\nhttps://marginaleffects.com/\n\n\npredictions(\n  model,\n  newdata = NULL,\n  variables = NULL,\n  vcov = TRUE,\n  conf_level = 0.95,\n  type = NULL,\n  by = FALSE,\n  byfun = NULL,\n  wts = FALSE,\n  transform = NULL,\n  hypothesis = NULL,\n  equivalence = NULL,\n  p_adjust = NULL,\n  df = Inf,\n  numderiv = \"fdforward\",\n  ...\n)\n\navg_predictions(\n  model,\n  newdata = NULL,\n  variables = NULL,\n  vcov = TRUE,\n  conf_level = 0.95,\n  type = NULL,\n  by = TRUE,\n  byfun = NULL,\n  wts = FALSE,\n  transform = NULL,\n  hypothesis = NULL,\n  equivalence = NULL,\n  p_adjust = NULL,\n  df = Inf,\n  numderiv = \"fdforward\",\n  ...\n)\n\n\n\n\n\nmodel\n\n\nModel object\n\n\n\n\nnewdata\n\n\nGrid of predictor values at which we evaluate predictions.\n\n\nWarning: Please avoid modifying your dataset between fitting the model and calling a marginaleffects function. This can sometimes lead to unexpected results.\n\n\nNULL (default): Unit-level predictions for each observed value in the dataset (empirical distribution). The dataset is retrieved using insight::get_data(), which tries to extract data from the environment. This may produce unexpected results if the original data frame has been altered since fitting the model.\n\n\nstring:\n\n\n\"mean\": Predictions evaluated when each predictor is held at its mean or mode.\n\n\n\"median\": Predictions evaluated when each predictor is held at its median or mode.\n\n\n\"balanced\": Predictions evaluated on a balanced grid with every combination of categories and numeric variables held at their means.\n\n\n\"tukey\": Predictions evaluated at Tukey’s 5 numbers.\n\n\n\"grid\": Predictions evaluated on a grid of representative numbers (Tukey’s 5 numbers and unique values of categorical predictors).\n\n\n\n\ndatagrid() call to specify a custom grid of regressors. For example:\n\n\nnewdata = datagrid(cyl = c(4, 6)): cyl variable equal to 4 and 6 and other regressors fixed at their means or modes.\n\n\nSee the Examples section and the datagrid() documentation.\n\n\n\n\nsubset() call with a single argument to select a subset of the dataset used to fit the model, ex: newdata = subset(treatment == 1)\n\n\ndplyr::filter() call with a single argument to select a subset of the dataset used to fit the model, ex: newdata = filter(treatment == 1)\n\n\n\n\n\n\nvariables\n\n\nCounterfactual variables.\n\n\nOutput:\n\n\npredictions(): The entire dataset is replicated once for each unique combination of variables, and predictions are made.\n\n\navg_predictions(): The entire dataset is replicated, predictions are made, and they are marginalized by variables categories.\n\n\nWarning: This can be expensive in large datasets.\n\n\nWarning: Users who need \"conditional\" predictions should use the newdata argument instead of variables.\n\n\n\n\nInput:\n\n\nNULL: computes one prediction per row of newdata\n\n\nCharacter vector: the dataset is replicated once of every combination of unique values of the variables identified in variables.\n\n\nNamed list: names identify the subset of variables of interest and their values. For numeric variables, the variables argument supports functions and string shortcuts:\n\n\nA function which returns a numeric value\n\n\nNumeric vector: Contrast between the 2nd element and the 1st element of the x vector.\n\n\n\"iqr\": Contrast across the interquartile range of the regressor.\n\n\n\"sd\": Contrast across one standard deviation around the regressor mean.\n\n\n\"2sd\": Contrast across two standard deviations around the regressor mean.\n\n\n\"minmax\": Contrast between the maximum and the minimum values of the regressor.\n\n\n\"threenum\": mean and 1 standard deviation on both sides\n\n\n\"fivenum\": Tukey’s five numbers\n\n\n\n\n\n\n\n\n\n\nvcov\n\n\nType of uncertainty estimates to report (e.g., for robust standard errors). Acceptable values:\n\n\nFALSE: Do not compute standard errors. This can speed up computation considerably.\n\n\nTRUE: Unit-level standard errors using the default vcov(model) variance-covariance matrix.\n\n\nString which indicates the kind of uncertainty estimates to return.\n\n\nHeteroskedasticity-consistent: “HC”, “HC0”, “HC1”, “HC2”, “HC3”, “HC4”, “HC4m”, “HC5”. See ?sandwich::vcovHC\n\n\nHeteroskedasticity and autocorrelation consistent: “HAC”\n\n\nMixed-Models degrees of freedom: \"satterthwaite\", \"kenward-roger\"\n\n\nOther: “NeweyWest”, “KernHAC”, “OPG”. See the sandwich package documentation.\n\n\n\n\nOne-sided formula which indicates the name of cluster variables (e.g., ~unit_id). This formula is passed to the cluster argument of the sandwich::vcovCL function.\n\n\nSquare covariance matrix\n\n\nFunction which returns a covariance matrix (e.g., stats::vcov(model))\n\n\n\n\n\n\nconf_level\n\n\nnumeric value between 0 and 1. Confidence level to use to build a confidence interval.\n\n\n\n\ntype\n\n\nstring indicates the type (scale) of the predictions used to compute contrasts or slopes. This can differ based on the model type, but will typically be a string such as: \"response\", \"link\", \"probs\", or \"zero\". When an unsupported string is entered, the model-specific list of acceptable values is returned in an error message. When type is NULL, the first entry in the error message is used by default.\n\n\n\n\nby\n\n\nAggregate unit-level estimates (aka, marginalize, average over). Valid inputs:\n\n\nFALSE: return the original unit-level estimates.\n\n\nTRUE: aggregate estimates for each term.\n\n\nCharacter vector of column names in newdata or in the data frame produced by calling the function without the by argument.\n\n\nData frame with a by column of group labels, and merging columns shared by newdata or the data frame produced by calling the same function without the by argument.\n\n\nSee examples below.\n\n\nFor more complex aggregations, you can use the FUN argument of the hypotheses() function. See that function’s documentation and the Hypothesis Test vignettes on the marginaleffects website.\n\n\n\n\n\n\nbyfun\n\n\nA function such as mean() or sum() used to aggregate estimates within the subgroups defined by the by argument. NULL uses the mean() function. Must accept a numeric vector and return a single numeric value. This is sometimes used to take the sum or mean of predicted probabilities across outcome or predictor levels. See examples section.\n\n\n\n\nwts\n\n\nlogical, string or numeric: weights to use when computing average predictions, contrasts or slopes. These weights only affect the averaging in avg_*() or with the by argument, and not unit-level estimates. See ?weighted.mean\n\n\nstring: column name of the weights variable in newdata. When supplying a column name to wts, it is recommended to supply the original data (including the weights variable) explicitly to newdata.\n\n\nnumeric: vector of length equal to the number of rows in the original data or in newdata (if supplied).\n\n\nFALSE: Equal weights.\n\n\nTRUE: Extract weights from the fitted object with insight::find_weights() and use them when taking weighted averages of estimates. Warning: newdata=datagrid() returns a single average weight, which is equivalent to using wts=FALSE\n\n\n\n\n\n\ntransform\n\n\nA function applied to unit-level adjusted predictions and confidence intervals just before the function returns results. For bayesian models, this function is applied to individual draws from the posterior distribution, before computing summaries.\n\n\n\n\nhypothesis\n\n\nspecify a hypothesis test or custom contrast using a numeric value, vector, or matrix; a string equation; string; a formula, or a function.\n\n\nNumeric:\n\n\nSingle value: the null hypothesis used in the computation of Z and p (before applying transform).\n\n\nVector: Weights to compute a linear combination of (custom contrast between) estimates. Length equal to the number of rows generated by the same function call, but without the hypothesis argument.\n\n\nMatrix: Each column is a vector of weights, as describe above, used to compute a distinct linear combination of (contrast between) estimates. The column names of the matrix are used as labels in the output.\n\n\n\n\nString equation to specify linear or non-linear hypothesis tests. If the term column uniquely identifies rows, terms can be used in the formula. Otherwise, use b1, b2, etc. to identify the position of each parameter. The b* wildcard can be used to test hypotheses on all estimates. If a named vector is used, the names are used as labels in the output. Examples:\n\n\nhp = drat\n\n\nhp + drat = 12\n\n\nb1 + b2 + b3 = 0\n\n\nb* / b1 = 1\n\n\n\n\nString:\n\n\n\"pairwise\": pairwise differences between estimates in each row.\n\n\n\"reference\": differences between the estimates in each row and the estimate in the first row.\n\n\n\"sequential\": difference between an estimate and the estimate in the next row.\n\n\n\"meandev\": difference between an estimate and the mean of all estimates.\n\n\n\"meanotherdev\": difference between an estimate and the mean of all other estimates, excluding the current one.\n\n\n\"revpairwise\", \"revreference\", \"revsequential\": inverse of the corresponding hypotheses, as described above.\n\n\n\n\nFormula:\n\n\ncomparison ~ pairs | group\n\n\nLeft-hand side determines the type of comparison to conduct: difference or ratio. If the left-hand side is empty, difference is chosen.\n\n\nRight-hand side determines the pairs of estimates to compare: reference, sequential, or meandev\n\n\nOptional: Users can supply grouping variables after a vertical bar to conduct comparisons withing subsets.\n\n\nExamples:\n\n\n~ reference\n\n\nratio ~ pairwise\n\n\ndifference ~ pairwise | groupid\n\n\n\n\n\n\nFunction:\n\n\nAccepts an argument x: object produced by a marginaleffects function or a data frame with column rowid and estimate\n\n\nReturns a data frame with columns term and estimate (mandatory) and rowid (optional).\n\n\nThe function can also accept optional input arguments: newdata, by, draws.\n\n\nThis function approach will not work for Bayesian models or with bootstrapping. In those cases, it is easy to use posterior_draws() to extract and manipulate the draws directly.\n\n\n\n\nSee the Examples section below and the vignette: https://marginaleffects.com/vignettes/hypothesis.html\n\n\n\n\n\n\nequivalence\n\n\nNumeric vector of length 2: bounds used for the two-one-sided test (TOST) of equivalence, and for the non-inferiority and non-superiority tests. See Details section below.\n\n\n\n\np_adjust\n\n\nAdjust p-values for multiple comparisons: \"holm\", \"hochberg\", \"hommel\", \"bonferroni\", \"BH\", \"BY\", or \"fdr\". See stats::p.adjust\n\n\n\n\ndf\n\n\nDegrees of freedom used to compute p values and confidence intervals. A single numeric value between 1 and Inf. When df is Inf, the normal distribution is used. When df is finite, the t distribution is used. See insight::get_df for a convenient function to extract degrees of freedom. Ex: slopes(model, df = insight::get_df(model))\n\n\n\n\nnumderiv\n\n\nstring or list of strings indicating the method to use to for the numeric differentiation used in to compute delta method standard errors.\n\n\n\"fdforward\": finite difference method with forward differences\n\n\n\"fdcenter\": finite difference method with central differences (default)\n\n\n\"richardson\": Richardson extrapolation method\n\n\nExtra arguments can be specified by passing a list to the numDeriv argument, with the name of the method first and named arguments following, ex: numderiv=list(“fdcenter”, eps = 1e-5). When an unknown argument is used, marginaleffects prints the list of valid arguments for each method.\n\n\n\n\n\n\n…\n\n\nAdditional arguments are passed to the predict() method supplied by the modeling package.These arguments are particularly useful for mixed-effects or bayesian models (see the online vignettes on the marginaleffects website). Available arguments can vary from model to model, depending on the range of supported arguments by each modeling package. See the \"Model-Specific Arguments\" section of the ?slopes documentation for a non-exhaustive list of available arguments.\n\n\n\nA data.frame with one row per observation and several columns:\n\n\nrowid: row number of the newdata data frame\n\n\ntype: prediction type, as defined by the type argument\n\n\ngroup: (optional) value of the grouped outcome (e.g., categorical outcome models)\n\n\nestimate: predicted outcome\n\n\nstd.error: standard errors computed using the delta method.\n\n\np.value: p value associated to the estimate column. The null is determined by the hypothesis argument (0 by default), and p values are computed before applying the transform argument. For models of class feglm, Gam, glm and negbin, p values are computed on the link scale by default unless the type argument is specified explicitly.\n\n\ns.value: Shannon information transforms of p values. How many consecutive \"heads\" tosses would provide the same amount of evidence (or \"surprise\") against the null hypothesis that the coin is fair? The purpose of S is to calibrate the analyst’s intuition about the strength of evidence encoded in p against a well-known physical phenomenon. See Greenland (2019) and Cole et al. (2020).\n\n\nconf.low: lower bound of the confidence interval (or equal-tailed interval for bayesian models)\n\n\nconf.high: upper bound of the confidence interval (or equal-tailed interval for bayesian models)\n\n\nSee ?print.marginaleffects for printing options.\n\n\n\navg_predictions(): Average predictions\n\n\nStandard errors for all quantities estimated by marginaleffects can be obtained via the delta method. This requires differentiating a function with respect to the coefficients in the model using a finite difference approach. In some models, the delta method standard errors can be sensitive to various aspects of the numeric differentiation strategy, including the step size. By default, the step size is set to 1e-8, or to 1e-4 times the smallest absolute model coefficient, whichever is largest.\nmarginaleffects can delegate numeric differentiation to the numDeriv package, which allows more flexibility. To do this, users can pass arguments to the numDeriv::jacobian function through a global option. For example:\n\n\noptions(marginaleffects_numDeriv = list(method = “simple”, method.args = list(eps = 1e-6)))\n\n\noptions(marginaleffects_numDeriv = list(method = “Richardson”, method.args = list(eps = 1e-5)))\n\n\noptions(marginaleffects_numDeriv = NULL)\n\n\nSee the \"Standard Errors and Confidence Intervals\" vignette on the marginaleffects website for more details on the computation of standard errors:\nhttps://marginaleffects.com/vignettes/uncertainty.html\nNote that the inferences() function can be used to compute uncertainty estimates using a bootstrap or simulation-based inference. See the vignette:\nhttps://marginaleffects.com/vignettes/bootstrap.html\n\nSome model types allow model-specific arguments to modify the nature of marginal effects, predictions, marginal means, and contrasts. Please report other package-specific predict() arguments on Github so we can add them to the table below.\nhttps://github.com/vincentarelbundock/marginaleffects/issues\n\n\n\nPackage\n\n\nClass\n\n\nArgument\n\n\nDocumentation\n\n\n\n\nbrms\n\n\nbrmsfit\n\n\nndraws\n\n\nbrms::posterior_predict\n\n\n\n\n\n\n\n\nre_formula\n\n\nbrms::posterior_predict\n\n\n\n\nlme4\n\n\nmerMod\n\n\nre.form\n\n\nlme4::predict.merMod\n\n\n\n\n\n\n\n\nallow.new.levels\n\n\nlme4::predict.merMod\n\n\n\n\nglmmTMB\n\n\nglmmTMB\n\n\nre.form\n\n\nglmmTMB::predict.glmmTMB\n\n\n\n\n\n\n\n\nallow.new.levels\n\n\nglmmTMB::predict.glmmTMB\n\n\n\n\n\n\n\n\nzitype\n\n\nglmmTMB::predict.glmmTMB\n\n\n\n\nmgcv\n\n\nbam\n\n\nexclude\n\n\nmgcv::predict.bam\n\n\n\n\n\n\ngam\n\n\nexclude\n\n\nmgcv::predict.gam\n\n\n\n\nrobustlmm\n\n\nrlmerMod\n\n\nre.form\n\n\nrobustlmm::predict.rlmerMod\n\n\n\n\n\n\n\n\nallow.new.levels\n\n\nrobustlmm::predict.rlmerMod\n\n\n\n\nMCMCglmm\n\n\nMCMCglmm\n\n\nndraws\n\n\n\n\n\n\nsampleSelection\n\n\nselection\n\n\npart\n\n\nsampleSelection::predict.selection\n\n\n\n\n\n\n\nBy default, credible intervals in bayesian models are built as equal-tailed intervals. This can be changed to a highest density interval by setting a global option:\noptions(“marginaleffects_posterior_interval” = “eti”)\noptions(“marginaleffects_posterior_interval” = “hdi”)\nBy default, the center of the posterior distribution in bayesian models is identified by the median. Users can use a different summary function by setting a global option:\noptions(“marginaleffects_posterior_center” = “mean”)\noptions(“marginaleffects_posterior_center” = “median”)\nWhen estimates are averaged using the by argument, the tidy() function, or the summary() function, the posterior distribution is marginalized twice over. First, we take the average across units but within each iteration of the MCMC chain, according to what the user requested in by argument or tidy()/summary() functions. Then, we identify the center of the resulting posterior using the function supplied to the “marginaleffects_posterior_center” option (the median by default).\n\n\\(\\theta\\) is an estimate, \\(\\sigma_\\theta\\) its estimated standard error, and \\([a, b]\\) are the bounds of the interval supplied to the equivalence argument.\nNon-inferiority:\n\n\n\\(H_0\\): \\(\\theta \\leq a\\)\n\n\n\\(H_1\\): \\(\\theta &gt; a\\)\n\n\n\\(t=(\\theta - a)/\\sigma_\\theta\\)\n\n\np: Upper-tail probability\n\n\nNon-superiority:\n\n\n\\(H_0\\): \\(\\theta \\geq b\\)\n\n\n\\(H_1\\): \\(\\theta &lt; b\\)\n\n\n\\(t=(\\theta - b)/\\sigma_\\theta\\)\n\n\np: Lower-tail probability\n\n\nEquivalence: Two One-Sided Tests (TOST)\n\n\np: Maximum of the non-inferiority and non-superiority p values.\n\n\nThanks to Russell V. Lenth for the excellent emmeans package and documentation which inspired this feature.\n\nThe type argument determines the scale of the predictions used to compute quantities of interest with functions from the marginaleffects package. Admissible values for type depend on the model object. When users specify an incorrect value for type, marginaleffects will raise an informative error with a list of valid type values for the specific model object. The first entry in the list in that error message is the default type.\nThe invlink(link) is a special type defined by marginaleffects. It is available for some (but not all) models, and only for the predictions() function. With this link type, we first compute predictions on the link scale, then we use the inverse link function to backtransform the predictions to the response scale. This is useful for models with non-linear link functions as it can ensure that confidence intervals stay within desirable bounds, ex: 0 to 1 for a logit model. Note that an average of estimates with type=“invlink(link)” will not always be equivalent to the average of estimates with type=“response”. This type is default when calling predictions(). It is available—but not default—when calling avg_predictions() or predictions() with the by argument.\nSome of the most common type values are:\nresponse, link, E, Ep, average, class, conditional, count, cum.prob, cumhaz, cumprob, density, detection, disp, ev, expected, expvalue, fitted, hazard, invlink(link), latent, latent_N, linear, linear.predictor, linpred, location, lp, mean, numeric, p, ppd, pr, precision, prediction, prob, probability, probs, quantile, risk, rmst, scale, survival, unconditional, utility, variance, xb, zero, zlink, zprob\n\nBehind the scenes, the arguments of marginaleffects functions are evaluated in this order:\n\n\nnewdata\n\n\nvariables\n\n\ncomparison and slopes\n\n\nby\n\n\nvcov\n\n\nhypothesis\n\n\ntransform\n\n\nThe slopes() and comparisons() functions can use parallelism to speed up computation. Operations are parallelized for the computation of standard errors, at the model coefficient level. There is always considerable overhead when using parallel computation, mainly involved in passing the whole dataset to the different processes. Thus, parallel computation is most likely to be useful when the model includes many parameters and the dataset is relatively small.\nWarning: In many cases, parallel processing will not be useful at all.\nTo activate parallel computation, users must load the future.apply package, call plan() function, and set a global option. For example:\n\nlibrary(future.apply)\nplan(\"multicore\", workers = 4)\noptions(marginaleffects_parallel = TRUE)\n\nslopes(model)\n\n\nTo disable parallelism in marginaleffects altogether, you can set a global option:\n\noptions(marginaleffects_parallel = FALSE)\n\n\n\nThe behavior of marginaleffects functions can be modified by setting global options.\nDisable some safety checks:\n\noptions(marginaleffects_safe = FALSE)\n\n\nOmit some columns from the printed output:\n\noptions(marginaleffects_print_omit = c(\"p.value\", \"s.value\"))`\n\n\n\n\n\nGreenland S. 2019. \"Valid P-Values Behave Exactly as They Should: Some Misleading Criticisms of P-Values and Their Resolution With S-Values.\" The American Statistician. 73(S1): 106–114.\n\n\nCole, Stephen R, Jessie K Edwards, and Sander Greenland. 2020. \"Surprise!\" American Journal of Epidemiology 190 (2): 191–93. https://doi.org/10.1093/aje/kwaa136\n\n\n\nlibrary(\"marginaleffects\")\n\n\n\n# Adjusted Prediction for every row of the original dataset\nmod &lt;- lm(mpg ~ hp + factor(cyl), data = mtcars)\npred &lt;- predictions(mod)\nhead(pred)\n\n# Adjusted Predictions at User-Specified Values of the Regressors\npredictions(mod, newdata = datagrid(hp = c(100, 120), cyl = 4))\n\nm &lt;- lm(mpg ~ hp + drat + factor(cyl) + factor(am), data = mtcars)\npredictions(m, newdata = datagrid(FUN_factor = unique, FUN_numeric = median))\n\n# Average Adjusted Predictions (AAP)\nlibrary(dplyr)\nmod &lt;- lm(mpg ~ hp * am * vs, mtcars)\n\navg_predictions(mod)\n\npredictions(mod, by = \"am\")\n\n# Conditional Adjusted Predictions\nplot_predictions(mod, condition = \"hp\")\n\n# Counterfactual predictions with the `variables` argument\n# the `mtcars` dataset has 32 rows\n\nmod &lt;- lm(mpg ~ hp + am, data = mtcars)\np &lt;- predictions(mod)\nhead(p)\nnrow(p)\n\n# average counterfactual predictions\navg_predictions(mod, variables = \"am\")\n\n# counterfactual predictions obtained by replicating the entire for different\n# values of the predictors\np &lt;- predictions(mod, variables = list(hp = c(90, 110)))\nnrow(p)\n\n\n# hypothesis test: is the prediction in the 1st row equal to the prediction in the 2nd row\nmod &lt;- lm(mpg ~ wt + drat, data = mtcars)\n\npredictions(\n    mod,\n    newdata = datagrid(wt = 2:3),\n    hypothesis = \"b1 = b2\")\n\n# same hypothesis test using row indices\npredictions(\n    mod,\n    newdata = datagrid(wt = 2:3),\n    hypothesis = \"b1 - b2 = 0\")\n\n# same hypothesis test using numeric vector of weights\npredictions(\n    mod,\n    newdata = datagrid(wt = 2:3),\n    hypothesis = c(1, -1))\n\n# two custom contrasts using a matrix of weights\nlc &lt;- matrix(c(\n    1, -1,\n    2, 3),\n    ncol = 2)\npredictions(\n    mod,\n    newdata = datagrid(wt = 2:3),\n    hypothesis = lc)\n\n\n# `by` argument\nmod &lt;- lm(mpg ~ hp * am * vs, data = mtcars)\npredictions(mod, by = c(\"am\", \"vs\"))\n\nlibrary(nnet)\nnom &lt;- multinom(factor(gear) ~ mpg + am * vs, data = mtcars, trace = FALSE)\n\n# first 5 raw predictions\npredictions(nom, type = \"probs\") |&gt; head()\n\n# average predictions\navg_predictions(nom, type = \"probs\", by = \"group\")\n\nby &lt;- data.frame(\n    group = c(\"3\", \"4\", \"5\"),\n    by = c(\"3,4\", \"3,4\", \"5\"))\n\npredictions(nom, type = \"probs\", by = by)\n\n# sum of predicted probabilities for combined response levels\nmod &lt;- multinom(factor(cyl) ~ mpg + am, data = mtcars, trace = FALSE)\nby &lt;- data.frame(\n    by = c(\"4,6\", \"4,6\", \"8\"),\n    group = as.character(c(4, 6, 8)))\npredictions(mod, newdata = \"mean\", byfun = sum, by = by)",
    "crumbs": [
      "Model to Meaning",
      "Functions",
      "`predictions`"
    ]
  },
  {
    "objectID": "man/predictions.html#predictions",
    "href": "man/predictions.html#predictions",
    "title": "",
    "section": "",
    "text": "Outcome predicted by a fitted model on a specified scale for a given combination of values of the predictor variables, such as their observed values, their means, or factor levels (a.k.a. \"reference grid\").\n\n\npredictions(): unit-level (conditional) estimates.\n\n\navg_predictions(): average (marginal) estimates.\n\n\nThe newdata argument and the datagrid() function can be used to control where statistics are evaluated in the predictor space: \"at observed values\", \"at the mean\", \"at representative values\", etc.\nSee the predictions vignette and package website for worked examples and case studies:\n\n\nhttps://marginaleffects.com/vignettes/predictions.html\n\n\nhttps://marginaleffects.com/\n\n\npredictions(\n  model,\n  newdata = NULL,\n  variables = NULL,\n  vcov = TRUE,\n  conf_level = 0.95,\n  type = NULL,\n  by = FALSE,\n  byfun = NULL,\n  wts = FALSE,\n  transform = NULL,\n  hypothesis = NULL,\n  equivalence = NULL,\n  p_adjust = NULL,\n  df = Inf,\n  numderiv = \"fdforward\",\n  ...\n)\n\navg_predictions(\n  model,\n  newdata = NULL,\n  variables = NULL,\n  vcov = TRUE,\n  conf_level = 0.95,\n  type = NULL,\n  by = TRUE,\n  byfun = NULL,\n  wts = FALSE,\n  transform = NULL,\n  hypothesis = NULL,\n  equivalence = NULL,\n  p_adjust = NULL,\n  df = Inf,\n  numderiv = \"fdforward\",\n  ...\n)\n\n\n\n\n\nmodel\n\n\nModel object\n\n\n\n\nnewdata\n\n\nGrid of predictor values at which we evaluate predictions.\n\n\nWarning: Please avoid modifying your dataset between fitting the model and calling a marginaleffects function. This can sometimes lead to unexpected results.\n\n\nNULL (default): Unit-level predictions for each observed value in the dataset (empirical distribution). The dataset is retrieved using insight::get_data(), which tries to extract data from the environment. This may produce unexpected results if the original data frame has been altered since fitting the model.\n\n\nstring:\n\n\n\"mean\": Predictions evaluated when each predictor is held at its mean or mode.\n\n\n\"median\": Predictions evaluated when each predictor is held at its median or mode.\n\n\n\"balanced\": Predictions evaluated on a balanced grid with every combination of categories and numeric variables held at their means.\n\n\n\"tukey\": Predictions evaluated at Tukey’s 5 numbers.\n\n\n\"grid\": Predictions evaluated on a grid of representative numbers (Tukey’s 5 numbers and unique values of categorical predictors).\n\n\n\n\ndatagrid() call to specify a custom grid of regressors. For example:\n\n\nnewdata = datagrid(cyl = c(4, 6)): cyl variable equal to 4 and 6 and other regressors fixed at their means or modes.\n\n\nSee the Examples section and the datagrid() documentation.\n\n\n\n\nsubset() call with a single argument to select a subset of the dataset used to fit the model, ex: newdata = subset(treatment == 1)\n\n\ndplyr::filter() call with a single argument to select a subset of the dataset used to fit the model, ex: newdata = filter(treatment == 1)\n\n\n\n\n\n\nvariables\n\n\nCounterfactual variables.\n\n\nOutput:\n\n\npredictions(): The entire dataset is replicated once for each unique combination of variables, and predictions are made.\n\n\navg_predictions(): The entire dataset is replicated, predictions are made, and they are marginalized by variables categories.\n\n\nWarning: This can be expensive in large datasets.\n\n\nWarning: Users who need \"conditional\" predictions should use the newdata argument instead of variables.\n\n\n\n\nInput:\n\n\nNULL: computes one prediction per row of newdata\n\n\nCharacter vector: the dataset is replicated once of every combination of unique values of the variables identified in variables.\n\n\nNamed list: names identify the subset of variables of interest and their values. For numeric variables, the variables argument supports functions and string shortcuts:\n\n\nA function which returns a numeric value\n\n\nNumeric vector: Contrast between the 2nd element and the 1st element of the x vector.\n\n\n\"iqr\": Contrast across the interquartile range of the regressor.\n\n\n\"sd\": Contrast across one standard deviation around the regressor mean.\n\n\n\"2sd\": Contrast across two standard deviations around the regressor mean.\n\n\n\"minmax\": Contrast between the maximum and the minimum values of the regressor.\n\n\n\"threenum\": mean and 1 standard deviation on both sides\n\n\n\"fivenum\": Tukey’s five numbers\n\n\n\n\n\n\n\n\n\n\nvcov\n\n\nType of uncertainty estimates to report (e.g., for robust standard errors). Acceptable values:\n\n\nFALSE: Do not compute standard errors. This can speed up computation considerably.\n\n\nTRUE: Unit-level standard errors using the default vcov(model) variance-covariance matrix.\n\n\nString which indicates the kind of uncertainty estimates to return.\n\n\nHeteroskedasticity-consistent: “HC”, “HC0”, “HC1”, “HC2”, “HC3”, “HC4”, “HC4m”, “HC5”. See ?sandwich::vcovHC\n\n\nHeteroskedasticity and autocorrelation consistent: “HAC”\n\n\nMixed-Models degrees of freedom: \"satterthwaite\", \"kenward-roger\"\n\n\nOther: “NeweyWest”, “KernHAC”, “OPG”. See the sandwich package documentation.\n\n\n\n\nOne-sided formula which indicates the name of cluster variables (e.g., ~unit_id). This formula is passed to the cluster argument of the sandwich::vcovCL function.\n\n\nSquare covariance matrix\n\n\nFunction which returns a covariance matrix (e.g., stats::vcov(model))\n\n\n\n\n\n\nconf_level\n\n\nnumeric value between 0 and 1. Confidence level to use to build a confidence interval.\n\n\n\n\ntype\n\n\nstring indicates the type (scale) of the predictions used to compute contrasts or slopes. This can differ based on the model type, but will typically be a string such as: \"response\", \"link\", \"probs\", or \"zero\". When an unsupported string is entered, the model-specific list of acceptable values is returned in an error message. When type is NULL, the first entry in the error message is used by default.\n\n\n\n\nby\n\n\nAggregate unit-level estimates (aka, marginalize, average over). Valid inputs:\n\n\nFALSE: return the original unit-level estimates.\n\n\nTRUE: aggregate estimates for each term.\n\n\nCharacter vector of column names in newdata or in the data frame produced by calling the function without the by argument.\n\n\nData frame with a by column of group labels, and merging columns shared by newdata or the data frame produced by calling the same function without the by argument.\n\n\nSee examples below.\n\n\nFor more complex aggregations, you can use the FUN argument of the hypotheses() function. See that function’s documentation and the Hypothesis Test vignettes on the marginaleffects website.\n\n\n\n\n\n\nbyfun\n\n\nA function such as mean() or sum() used to aggregate estimates within the subgroups defined by the by argument. NULL uses the mean() function. Must accept a numeric vector and return a single numeric value. This is sometimes used to take the sum or mean of predicted probabilities across outcome or predictor levels. See examples section.\n\n\n\n\nwts\n\n\nlogical, string or numeric: weights to use when computing average predictions, contrasts or slopes. These weights only affect the averaging in avg_*() or with the by argument, and not unit-level estimates. See ?weighted.mean\n\n\nstring: column name of the weights variable in newdata. When supplying a column name to wts, it is recommended to supply the original data (including the weights variable) explicitly to newdata.\n\n\nnumeric: vector of length equal to the number of rows in the original data or in newdata (if supplied).\n\n\nFALSE: Equal weights.\n\n\nTRUE: Extract weights from the fitted object with insight::find_weights() and use them when taking weighted averages of estimates. Warning: newdata=datagrid() returns a single average weight, which is equivalent to using wts=FALSE\n\n\n\n\n\n\ntransform\n\n\nA function applied to unit-level adjusted predictions and confidence intervals just before the function returns results. For bayesian models, this function is applied to individual draws from the posterior distribution, before computing summaries.\n\n\n\n\nhypothesis\n\n\nspecify a hypothesis test or custom contrast using a numeric value, vector, or matrix; a string equation; string; a formula, or a function.\n\n\nNumeric:\n\n\nSingle value: the null hypothesis used in the computation of Z and p (before applying transform).\n\n\nVector: Weights to compute a linear combination of (custom contrast between) estimates. Length equal to the number of rows generated by the same function call, but without the hypothesis argument.\n\n\nMatrix: Each column is a vector of weights, as describe above, used to compute a distinct linear combination of (contrast between) estimates. The column names of the matrix are used as labels in the output.\n\n\n\n\nString equation to specify linear or non-linear hypothesis tests. If the term column uniquely identifies rows, terms can be used in the formula. Otherwise, use b1, b2, etc. to identify the position of each parameter. The b* wildcard can be used to test hypotheses on all estimates. If a named vector is used, the names are used as labels in the output. Examples:\n\n\nhp = drat\n\n\nhp + drat = 12\n\n\nb1 + b2 + b3 = 0\n\n\nb* / b1 = 1\n\n\n\n\nString:\n\n\n\"pairwise\": pairwise differences between estimates in each row.\n\n\n\"reference\": differences between the estimates in each row and the estimate in the first row.\n\n\n\"sequential\": difference between an estimate and the estimate in the next row.\n\n\n\"meandev\": difference between an estimate and the mean of all estimates.\n\n\n\"meanotherdev\": difference between an estimate and the mean of all other estimates, excluding the current one.\n\n\n\"revpairwise\", \"revreference\", \"revsequential\": inverse of the corresponding hypotheses, as described above.\n\n\n\n\nFormula:\n\n\ncomparison ~ pairs | group\n\n\nLeft-hand side determines the type of comparison to conduct: difference or ratio. If the left-hand side is empty, difference is chosen.\n\n\nRight-hand side determines the pairs of estimates to compare: reference, sequential, or meandev\n\n\nOptional: Users can supply grouping variables after a vertical bar to conduct comparisons withing subsets.\n\n\nExamples:\n\n\n~ reference\n\n\nratio ~ pairwise\n\n\ndifference ~ pairwise | groupid\n\n\n\n\n\n\nFunction:\n\n\nAccepts an argument x: object produced by a marginaleffects function or a data frame with column rowid and estimate\n\n\nReturns a data frame with columns term and estimate (mandatory) and rowid (optional).\n\n\nThe function can also accept optional input arguments: newdata, by, draws.\n\n\nThis function approach will not work for Bayesian models or with bootstrapping. In those cases, it is easy to use posterior_draws() to extract and manipulate the draws directly.\n\n\n\n\nSee the Examples section below and the vignette: https://marginaleffects.com/vignettes/hypothesis.html\n\n\n\n\n\n\nequivalence\n\n\nNumeric vector of length 2: bounds used for the two-one-sided test (TOST) of equivalence, and for the non-inferiority and non-superiority tests. See Details section below.\n\n\n\n\np_adjust\n\n\nAdjust p-values for multiple comparisons: \"holm\", \"hochberg\", \"hommel\", \"bonferroni\", \"BH\", \"BY\", or \"fdr\". See stats::p.adjust\n\n\n\n\ndf\n\n\nDegrees of freedom used to compute p values and confidence intervals. A single numeric value between 1 and Inf. When df is Inf, the normal distribution is used. When df is finite, the t distribution is used. See insight::get_df for a convenient function to extract degrees of freedom. Ex: slopes(model, df = insight::get_df(model))\n\n\n\n\nnumderiv\n\n\nstring or list of strings indicating the method to use to for the numeric differentiation used in to compute delta method standard errors.\n\n\n\"fdforward\": finite difference method with forward differences\n\n\n\"fdcenter\": finite difference method with central differences (default)\n\n\n\"richardson\": Richardson extrapolation method\n\n\nExtra arguments can be specified by passing a list to the numDeriv argument, with the name of the method first and named arguments following, ex: numderiv=list(“fdcenter”, eps = 1e-5). When an unknown argument is used, marginaleffects prints the list of valid arguments for each method.\n\n\n\n\n\n\n…\n\n\nAdditional arguments are passed to the predict() method supplied by the modeling package.These arguments are particularly useful for mixed-effects or bayesian models (see the online vignettes on the marginaleffects website). Available arguments can vary from model to model, depending on the range of supported arguments by each modeling package. See the \"Model-Specific Arguments\" section of the ?slopes documentation for a non-exhaustive list of available arguments.\n\n\n\nA data.frame with one row per observation and several columns:\n\n\nrowid: row number of the newdata data frame\n\n\ntype: prediction type, as defined by the type argument\n\n\ngroup: (optional) value of the grouped outcome (e.g., categorical outcome models)\n\n\nestimate: predicted outcome\n\n\nstd.error: standard errors computed using the delta method.\n\n\np.value: p value associated to the estimate column. The null is determined by the hypothesis argument (0 by default), and p values are computed before applying the transform argument. For models of class feglm, Gam, glm and negbin, p values are computed on the link scale by default unless the type argument is specified explicitly.\n\n\ns.value: Shannon information transforms of p values. How many consecutive \"heads\" tosses would provide the same amount of evidence (or \"surprise\") against the null hypothesis that the coin is fair? The purpose of S is to calibrate the analyst’s intuition about the strength of evidence encoded in p against a well-known physical phenomenon. See Greenland (2019) and Cole et al. (2020).\n\n\nconf.low: lower bound of the confidence interval (or equal-tailed interval for bayesian models)\n\n\nconf.high: upper bound of the confidence interval (or equal-tailed interval for bayesian models)\n\n\nSee ?print.marginaleffects for printing options.\n\n\n\navg_predictions(): Average predictions\n\n\nStandard errors for all quantities estimated by marginaleffects can be obtained via the delta method. This requires differentiating a function with respect to the coefficients in the model using a finite difference approach. In some models, the delta method standard errors can be sensitive to various aspects of the numeric differentiation strategy, including the step size. By default, the step size is set to 1e-8, or to 1e-4 times the smallest absolute model coefficient, whichever is largest.\nmarginaleffects can delegate numeric differentiation to the numDeriv package, which allows more flexibility. To do this, users can pass arguments to the numDeriv::jacobian function through a global option. For example:\n\n\noptions(marginaleffects_numDeriv = list(method = “simple”, method.args = list(eps = 1e-6)))\n\n\noptions(marginaleffects_numDeriv = list(method = “Richardson”, method.args = list(eps = 1e-5)))\n\n\noptions(marginaleffects_numDeriv = NULL)\n\n\nSee the \"Standard Errors and Confidence Intervals\" vignette on the marginaleffects website for more details on the computation of standard errors:\nhttps://marginaleffects.com/vignettes/uncertainty.html\nNote that the inferences() function can be used to compute uncertainty estimates using a bootstrap or simulation-based inference. See the vignette:\nhttps://marginaleffects.com/vignettes/bootstrap.html\n\nSome model types allow model-specific arguments to modify the nature of marginal effects, predictions, marginal means, and contrasts. Please report other package-specific predict() arguments on Github so we can add them to the table below.\nhttps://github.com/vincentarelbundock/marginaleffects/issues\n\n\n\nPackage\n\n\nClass\n\n\nArgument\n\n\nDocumentation\n\n\n\n\nbrms\n\n\nbrmsfit\n\n\nndraws\n\n\nbrms::posterior_predict\n\n\n\n\n\n\n\n\nre_formula\n\n\nbrms::posterior_predict\n\n\n\n\nlme4\n\n\nmerMod\n\n\nre.form\n\n\nlme4::predict.merMod\n\n\n\n\n\n\n\n\nallow.new.levels\n\n\nlme4::predict.merMod\n\n\n\n\nglmmTMB\n\n\nglmmTMB\n\n\nre.form\n\n\nglmmTMB::predict.glmmTMB\n\n\n\n\n\n\n\n\nallow.new.levels\n\n\nglmmTMB::predict.glmmTMB\n\n\n\n\n\n\n\n\nzitype\n\n\nglmmTMB::predict.glmmTMB\n\n\n\n\nmgcv\n\n\nbam\n\n\nexclude\n\n\nmgcv::predict.bam\n\n\n\n\n\n\ngam\n\n\nexclude\n\n\nmgcv::predict.gam\n\n\n\n\nrobustlmm\n\n\nrlmerMod\n\n\nre.form\n\n\nrobustlmm::predict.rlmerMod\n\n\n\n\n\n\n\n\nallow.new.levels\n\n\nrobustlmm::predict.rlmerMod\n\n\n\n\nMCMCglmm\n\n\nMCMCglmm\n\n\nndraws\n\n\n\n\n\n\nsampleSelection\n\n\nselection\n\n\npart\n\n\nsampleSelection::predict.selection\n\n\n\n\n\n\n\nBy default, credible intervals in bayesian models are built as equal-tailed intervals. This can be changed to a highest density interval by setting a global option:\noptions(“marginaleffects_posterior_interval” = “eti”)\noptions(“marginaleffects_posterior_interval” = “hdi”)\nBy default, the center of the posterior distribution in bayesian models is identified by the median. Users can use a different summary function by setting a global option:\noptions(“marginaleffects_posterior_center” = “mean”)\noptions(“marginaleffects_posterior_center” = “median”)\nWhen estimates are averaged using the by argument, the tidy() function, or the summary() function, the posterior distribution is marginalized twice over. First, we take the average across units but within each iteration of the MCMC chain, according to what the user requested in by argument or tidy()/summary() functions. Then, we identify the center of the resulting posterior using the function supplied to the “marginaleffects_posterior_center” option (the median by default).\n\n\\(\\theta\\) is an estimate, \\(\\sigma_\\theta\\) its estimated standard error, and \\([a, b]\\) are the bounds of the interval supplied to the equivalence argument.\nNon-inferiority:\n\n\n\\(H_0\\): \\(\\theta \\leq a\\)\n\n\n\\(H_1\\): \\(\\theta &gt; a\\)\n\n\n\\(t=(\\theta - a)/\\sigma_\\theta\\)\n\n\np: Upper-tail probability\n\n\nNon-superiority:\n\n\n\\(H_0\\): \\(\\theta \\geq b\\)\n\n\n\\(H_1\\): \\(\\theta &lt; b\\)\n\n\n\\(t=(\\theta - b)/\\sigma_\\theta\\)\n\n\np: Lower-tail probability\n\n\nEquivalence: Two One-Sided Tests (TOST)\n\n\np: Maximum of the non-inferiority and non-superiority p values.\n\n\nThanks to Russell V. Lenth for the excellent emmeans package and documentation which inspired this feature.\n\nThe type argument determines the scale of the predictions used to compute quantities of interest with functions from the marginaleffects package. Admissible values for type depend on the model object. When users specify an incorrect value for type, marginaleffects will raise an informative error with a list of valid type values for the specific model object. The first entry in the list in that error message is the default type.\nThe invlink(link) is a special type defined by marginaleffects. It is available for some (but not all) models, and only for the predictions() function. With this link type, we first compute predictions on the link scale, then we use the inverse link function to backtransform the predictions to the response scale. This is useful for models with non-linear link functions as it can ensure that confidence intervals stay within desirable bounds, ex: 0 to 1 for a logit model. Note that an average of estimates with type=“invlink(link)” will not always be equivalent to the average of estimates with type=“response”. This type is default when calling predictions(). It is available—but not default—when calling avg_predictions() or predictions() with the by argument.\nSome of the most common type values are:\nresponse, link, E, Ep, average, class, conditional, count, cum.prob, cumhaz, cumprob, density, detection, disp, ev, expected, expvalue, fitted, hazard, invlink(link), latent, latent_N, linear, linear.predictor, linpred, location, lp, mean, numeric, p, ppd, pr, precision, prediction, prob, probability, probs, quantile, risk, rmst, scale, survival, unconditional, utility, variance, xb, zero, zlink, zprob\n\nBehind the scenes, the arguments of marginaleffects functions are evaluated in this order:\n\n\nnewdata\n\n\nvariables\n\n\ncomparison and slopes\n\n\nby\n\n\nvcov\n\n\nhypothesis\n\n\ntransform\n\n\nThe slopes() and comparisons() functions can use parallelism to speed up computation. Operations are parallelized for the computation of standard errors, at the model coefficient level. There is always considerable overhead when using parallel computation, mainly involved in passing the whole dataset to the different processes. Thus, parallel computation is most likely to be useful when the model includes many parameters and the dataset is relatively small.\nWarning: In many cases, parallel processing will not be useful at all.\nTo activate parallel computation, users must load the future.apply package, call plan() function, and set a global option. For example:\n\nlibrary(future.apply)\nplan(\"multicore\", workers = 4)\noptions(marginaleffects_parallel = TRUE)\n\nslopes(model)\n\n\nTo disable parallelism in marginaleffects altogether, you can set a global option:\n\noptions(marginaleffects_parallel = FALSE)\n\n\n\nThe behavior of marginaleffects functions can be modified by setting global options.\nDisable some safety checks:\n\noptions(marginaleffects_safe = FALSE)\n\n\nOmit some columns from the printed output:\n\noptions(marginaleffects_print_omit = c(\"p.value\", \"s.value\"))`\n\n\n\n\n\nGreenland S. 2019. \"Valid P-Values Behave Exactly as They Should: Some Misleading Criticisms of P-Values and Their Resolution With S-Values.\" The American Statistician. 73(S1): 106–114.\n\n\nCole, Stephen R, Jessie K Edwards, and Sander Greenland. 2020. \"Surprise!\" American Journal of Epidemiology 190 (2): 191–93. https://doi.org/10.1093/aje/kwaa136\n\n\n\nlibrary(\"marginaleffects\")\n\n\n\n# Adjusted Prediction for every row of the original dataset\nmod &lt;- lm(mpg ~ hp + factor(cyl), data = mtcars)\npred &lt;- predictions(mod)\nhead(pred)\n\n# Adjusted Predictions at User-Specified Values of the Regressors\npredictions(mod, newdata = datagrid(hp = c(100, 120), cyl = 4))\n\nm &lt;- lm(mpg ~ hp + drat + factor(cyl) + factor(am), data = mtcars)\npredictions(m, newdata = datagrid(FUN_factor = unique, FUN_numeric = median))\n\n# Average Adjusted Predictions (AAP)\nlibrary(dplyr)\nmod &lt;- lm(mpg ~ hp * am * vs, mtcars)\n\navg_predictions(mod)\n\npredictions(mod, by = \"am\")\n\n# Conditional Adjusted Predictions\nplot_predictions(mod, condition = \"hp\")\n\n# Counterfactual predictions with the `variables` argument\n# the `mtcars` dataset has 32 rows\n\nmod &lt;- lm(mpg ~ hp + am, data = mtcars)\np &lt;- predictions(mod)\nhead(p)\nnrow(p)\n\n# average counterfactual predictions\navg_predictions(mod, variables = \"am\")\n\n# counterfactual predictions obtained by replicating the entire for different\n# values of the predictors\np &lt;- predictions(mod, variables = list(hp = c(90, 110)))\nnrow(p)\n\n\n# hypothesis test: is the prediction in the 1st row equal to the prediction in the 2nd row\nmod &lt;- lm(mpg ~ wt + drat, data = mtcars)\n\npredictions(\n    mod,\n    newdata = datagrid(wt = 2:3),\n    hypothesis = \"b1 = b2\")\n\n# same hypothesis test using row indices\npredictions(\n    mod,\n    newdata = datagrid(wt = 2:3),\n    hypothesis = \"b1 - b2 = 0\")\n\n# same hypothesis test using numeric vector of weights\npredictions(\n    mod,\n    newdata = datagrid(wt = 2:3),\n    hypothesis = c(1, -1))\n\n# two custom contrasts using a matrix of weights\nlc &lt;- matrix(c(\n    1, -1,\n    2, 3),\n    ncol = 2)\npredictions(\n    mod,\n    newdata = datagrid(wt = 2:3),\n    hypothesis = lc)\n\n\n# `by` argument\nmod &lt;- lm(mpg ~ hp * am * vs, data = mtcars)\npredictions(mod, by = c(\"am\", \"vs\"))\n\nlibrary(nnet)\nnom &lt;- multinom(factor(gear) ~ mpg + am * vs, data = mtcars, trace = FALSE)\n\n# first 5 raw predictions\npredictions(nom, type = \"probs\") |&gt; head()\n\n# average predictions\navg_predictions(nom, type = \"probs\", by = \"group\")\n\nby &lt;- data.frame(\n    group = c(\"3\", \"4\", \"5\"),\n    by = c(\"3,4\", \"3,4\", \"5\"))\n\npredictions(nom, type = \"probs\", by = by)\n\n# sum of predicted probabilities for combined response levels\nmod &lt;- multinom(factor(cyl) ~ mpg + am, data = mtcars, trace = FALSE)\nby &lt;- data.frame(\n    by = c(\"4,6\", \"4,6\", \"8\"),\n    group = as.character(c(4, 6, 8)))\npredictions(mod, newdata = \"mean\", byfun = sum, by = by)",
    "crumbs": [
      "Model to Meaning",
      "Functions",
      "`predictions`"
    ]
  },
  {
    "objectID": "man/datagrid.html",
    "href": "man/datagrid.html",
    "title": "",
    "section": "",
    "text": "Generate a data grid of user-specified values for use in the newdata argument of the predictions(), comparisons(), and slopes() functions. This is useful to define where in the predictor space we want to evaluate the quantities of interest. Ex: the predicted outcome or slope for a 37 year old college graduate.\n\ndatagrid(\n  ...,\n  model = NULL,\n  newdata = NULL,\n  by = NULL,\n  grid_type = \"mean_or_mode\",\n  response = FALSE,\n  FUN_character = NULL,\n  FUN_factor = NULL,\n  FUN_logical = NULL,\n  FUN_numeric = NULL,\n  FUN_integer = NULL,\n  FUN_binary = NULL,\n  FUN_other = NULL\n)\n\n\n\n\n\n…\n\n\nnamed arguments with vectors of values or functions for user-specified variables.\n\n\nFunctions are applied to the variable in the model dataset or newdata, and must return a vector of the appropriate type.\n\n\nCharacter vectors are automatically transformed to factors if necessary. +The output will include all combinations of these variables (see Examples below.)\n\n\n\n\n\n\nmodel\n\n\nModel object\n\n\n\n\nnewdata\n\n\ndata.frame (one and only one of the model and newdata arguments can be used.)\n\n\n\n\nby\n\n\ncharacter vector with grouping variables within which FUN_* functions are applied to create \"sub-grids\" with unspecified variables.\n\n\n\n\ngrid_type\n\n\ncharacter. Determines the functions to apply to each variable. The defaults can be overridden by defining individual variables explicitly in …, or by supplying a function to one of the FUN_* arguments.\n\n\n\"mean_or_mode\": Character, factor, logical, and binary variables are set to their modes. Numeric, integer, and other variables are set to their means.\n\n\n\"balanced\": Each unique level of character, factor, logical, and binary variables are preserved. Numeric, integer, and other variables are set to their means. Warning: When there are many variables and many levels per variable, a balanced grid can be very large. In those cases, it is better to use grid_type=“mean_or_mode” and to specify the unique levels of a subset of named variables explicitly.\n\n\n\"counterfactual\": the entire dataset is duplicated for each combination of the variable values specified in …. Variables not explicitly supplied to datagrid() are set to their observed values in the original dataset.\n\n\n\n\n\n\nresponse\n\n\nLogical should the response variable be included in the grid, even if it is not specified explicitly.\n\n\n\n\nFUN_character\n\n\nthe function to be applied to character variables.\n\n\n\n\nFUN_factor\n\n\nthe function to be applied to factor variables. This only applies if the variable in the original data is a factor. For variables converted to factor in a model-fitting formula, for example, FUN_character is used.\n\n\n\n\nFUN_logical\n\n\nthe function to be applied to logical variables.\n\n\n\n\nFUN_numeric\n\n\nthe function to be applied to numeric variables.\n\n\n\n\nFUN_integer\n\n\nthe function to be applied to integer variables.\n\n\n\n\nFUN_binary\n\n\nthe function to be applied to binary variables.\n\n\n\n\nFUN_other\n\n\nthe function to be applied to other variable types.\n\n\n\nIf datagrid is used in a predictions(), comparisons(), or slopes() call as the newdata argument, the model is automatically inserted in the model argument of datagrid() call, and users do not need to specify either the model or newdata arguments. The same behavior will occur when the value supplied to newdata= is a function call which starts with \"datagrid\". This is intended to allow users to create convenience shortcuts like:\nlibrary(marginaleffects)\nmod &lt;- lm(mpg ~ am + vs + factor(cyl) + hp, mtcars)\ndatagrid_bal &lt;- function(...) datagrid(..., grid_type = \"balanced\")\npredictions(model, newdata = datagrid_bal(cyl = 4))\n\nIf users supply a model, the data used to fit that model is retrieved using the insight::get_data function.\n\nA data.frame in which each row corresponds to one combination of the named predictors supplied by the user via the … dots. Variables which are not explicitly defined are held at their mean or mode.\n\n\nlibrary(\"marginaleffects\")\n\n# The output only has 2 rows, and all the variables except `hp` are at their\n# mean or mode.\ndatagrid(newdata = mtcars, hp = c(100, 110))\n\n       mpg    cyl     disp     drat      wt     qsec vs am   gear   carb  hp\n1 20.09062 6.1875 230.7219 3.596563 3.21725 17.84875  0  0 3.6875 2.8125 100\n2 20.09062 6.1875 230.7219 3.596563 3.21725 17.84875  0  0 3.6875 2.8125 110\n  rowid\n1     1\n2     2\n\n# We get the same result by feeding a model instead of a data.frame\nmod &lt;- lm(mpg ~ hp, mtcars)\ndatagrid(model = mod, hp = c(100, 110))\n\n   hp rowid\n1 100     1\n2 110     2\n\n# Use in `marginaleffects` to compute \"Typical Marginal Effects\". When used\n# in `slopes()` or `predictions()` we do not need to specify the\n#`model` or `newdata` arguments.\nslopes(mod, newdata = datagrid(hp = c(100, 110)))\n\n\n Term  hp Estimate Std. Error     z Pr(&gt;|z|)    S   2.5 %  97.5 %\n   hp 100  -0.0682     0.0101 -6.74   &lt;0.001 35.9 -0.0881 -0.0484\n   hp 110  -0.0682     0.0101 -6.74   &lt;0.001 35.9 -0.0881 -0.0484\n\nType:  response \nColumns: rowid, term, estimate, std.error, statistic, p.value, s.value, conf.low, conf.high, hp, predicted_lo, predicted_hi, predicted, mpg \n\n# datagrid accepts functions\ndatagrid(hp = range, cyl = unique, newdata = mtcars)\n\n       mpg     disp     drat      wt     qsec vs am   gear   carb  hp cyl rowid\n1 20.09062 230.7219 3.596563 3.21725 17.84875  0  0 3.6875 2.8125  52   6     1\n2 20.09062 230.7219 3.596563 3.21725 17.84875  0  0 3.6875 2.8125  52   4     2\n3 20.09062 230.7219 3.596563 3.21725 17.84875  0  0 3.6875 2.8125  52   8     3\n4 20.09062 230.7219 3.596563 3.21725 17.84875  0  0 3.6875 2.8125 335   6     4\n5 20.09062 230.7219 3.596563 3.21725 17.84875  0  0 3.6875 2.8125 335   4     5\n6 20.09062 230.7219 3.596563 3.21725 17.84875  0  0 3.6875 2.8125 335   8     6\n\ncomparisons(mod, newdata = datagrid(hp = fivenum))\n\n\n Term  hp Estimate Std. Error     z Pr(&gt;|z|)    S   2.5 %  97.5 %\n   hp  52  -0.0682     0.0101 -6.74   &lt;0.001 35.9 -0.0881 -0.0484\n   hp  96  -0.0682     0.0101 -6.74   &lt;0.001 35.9 -0.0881 -0.0484\n   hp 123  -0.0682     0.0101 -6.74   &lt;0.001 35.9 -0.0881 -0.0484\n   hp 180  -0.0682     0.0101 -6.74   &lt;0.001 35.9 -0.0881 -0.0484\n   hp 335  -0.0682     0.0101 -6.74   &lt;0.001 35.9 -0.0881 -0.0484\n\nType:  response \nComparison: +1\nColumns: rowid, term, contrast, estimate, std.error, statistic, p.value, s.value, conf.low, conf.high, hp, predicted_lo, predicted_hi, predicted, mpg \n\n# The full dataset is duplicated with each observation given counterfactual\n# values of 100 and 110 for the `hp` variable. The original `mtcars` includes\n# 32 rows, so the resulting dataset includes 64 rows.\ndg &lt;- datagrid(newdata = mtcars, hp = c(100, 110), grid_type = \"counterfactual\")\nnrow(dg)\n\n[1] 64\n\n# We get the same result by feeding a model instead of a data.frame\nmod &lt;- lm(mpg ~ hp, mtcars)\ndg &lt;- datagrid(model = mod, hp = c(100, 110), grid_type = \"counterfactual\")\nnrow(dg)\n\n[1] 64",
    "crumbs": [
      "Model to Meaning",
      "Functions",
      "`datagrid`"
    ]
  },
  {
    "objectID": "man/datagrid.html#data-grids",
    "href": "man/datagrid.html#data-grids",
    "title": "",
    "section": "",
    "text": "Generate a data grid of user-specified values for use in the newdata argument of the predictions(), comparisons(), and slopes() functions. This is useful to define where in the predictor space we want to evaluate the quantities of interest. Ex: the predicted outcome or slope for a 37 year old college graduate.\n\ndatagrid(\n  ...,\n  model = NULL,\n  newdata = NULL,\n  by = NULL,\n  grid_type = \"mean_or_mode\",\n  response = FALSE,\n  FUN_character = NULL,\n  FUN_factor = NULL,\n  FUN_logical = NULL,\n  FUN_numeric = NULL,\n  FUN_integer = NULL,\n  FUN_binary = NULL,\n  FUN_other = NULL\n)\n\n\n\n\n\n…\n\n\nnamed arguments with vectors of values or functions for user-specified variables.\n\n\nFunctions are applied to the variable in the model dataset or newdata, and must return a vector of the appropriate type.\n\n\nCharacter vectors are automatically transformed to factors if necessary. +The output will include all combinations of these variables (see Examples below.)\n\n\n\n\n\n\nmodel\n\n\nModel object\n\n\n\n\nnewdata\n\n\ndata.frame (one and only one of the model and newdata arguments can be used.)\n\n\n\n\nby\n\n\ncharacter vector with grouping variables within which FUN_* functions are applied to create \"sub-grids\" with unspecified variables.\n\n\n\n\ngrid_type\n\n\ncharacter. Determines the functions to apply to each variable. The defaults can be overridden by defining individual variables explicitly in …, or by supplying a function to one of the FUN_* arguments.\n\n\n\"mean_or_mode\": Character, factor, logical, and binary variables are set to their modes. Numeric, integer, and other variables are set to their means.\n\n\n\"balanced\": Each unique level of character, factor, logical, and binary variables are preserved. Numeric, integer, and other variables are set to their means. Warning: When there are many variables and many levels per variable, a balanced grid can be very large. In those cases, it is better to use grid_type=“mean_or_mode” and to specify the unique levels of a subset of named variables explicitly.\n\n\n\"counterfactual\": the entire dataset is duplicated for each combination of the variable values specified in …. Variables not explicitly supplied to datagrid() are set to their observed values in the original dataset.\n\n\n\n\n\n\nresponse\n\n\nLogical should the response variable be included in the grid, even if it is not specified explicitly.\n\n\n\n\nFUN_character\n\n\nthe function to be applied to character variables.\n\n\n\n\nFUN_factor\n\n\nthe function to be applied to factor variables. This only applies if the variable in the original data is a factor. For variables converted to factor in a model-fitting formula, for example, FUN_character is used.\n\n\n\n\nFUN_logical\n\n\nthe function to be applied to logical variables.\n\n\n\n\nFUN_numeric\n\n\nthe function to be applied to numeric variables.\n\n\n\n\nFUN_integer\n\n\nthe function to be applied to integer variables.\n\n\n\n\nFUN_binary\n\n\nthe function to be applied to binary variables.\n\n\n\n\nFUN_other\n\n\nthe function to be applied to other variable types.\n\n\n\nIf datagrid is used in a predictions(), comparisons(), or slopes() call as the newdata argument, the model is automatically inserted in the model argument of datagrid() call, and users do not need to specify either the model or newdata arguments. The same behavior will occur when the value supplied to newdata= is a function call which starts with \"datagrid\". This is intended to allow users to create convenience shortcuts like:\nlibrary(marginaleffects)\nmod &lt;- lm(mpg ~ am + vs + factor(cyl) + hp, mtcars)\ndatagrid_bal &lt;- function(...) datagrid(..., grid_type = \"balanced\")\npredictions(model, newdata = datagrid_bal(cyl = 4))\n\nIf users supply a model, the data used to fit that model is retrieved using the insight::get_data function.\n\nA data.frame in which each row corresponds to one combination of the named predictors supplied by the user via the … dots. Variables which are not explicitly defined are held at their mean or mode.\n\n\nlibrary(\"marginaleffects\")\n\n# The output only has 2 rows, and all the variables except `hp` are at their\n# mean or mode.\ndatagrid(newdata = mtcars, hp = c(100, 110))\n\n       mpg    cyl     disp     drat      wt     qsec vs am   gear   carb  hp\n1 20.09062 6.1875 230.7219 3.596563 3.21725 17.84875  0  0 3.6875 2.8125 100\n2 20.09062 6.1875 230.7219 3.596563 3.21725 17.84875  0  0 3.6875 2.8125 110\n  rowid\n1     1\n2     2\n\n# We get the same result by feeding a model instead of a data.frame\nmod &lt;- lm(mpg ~ hp, mtcars)\ndatagrid(model = mod, hp = c(100, 110))\n\n   hp rowid\n1 100     1\n2 110     2\n\n# Use in `marginaleffects` to compute \"Typical Marginal Effects\". When used\n# in `slopes()` or `predictions()` we do not need to specify the\n#`model` or `newdata` arguments.\nslopes(mod, newdata = datagrid(hp = c(100, 110)))\n\n\n Term  hp Estimate Std. Error     z Pr(&gt;|z|)    S   2.5 %  97.5 %\n   hp 100  -0.0682     0.0101 -6.74   &lt;0.001 35.9 -0.0881 -0.0484\n   hp 110  -0.0682     0.0101 -6.74   &lt;0.001 35.9 -0.0881 -0.0484\n\nType:  response \nColumns: rowid, term, estimate, std.error, statistic, p.value, s.value, conf.low, conf.high, hp, predicted_lo, predicted_hi, predicted, mpg \n\n# datagrid accepts functions\ndatagrid(hp = range, cyl = unique, newdata = mtcars)\n\n       mpg     disp     drat      wt     qsec vs am   gear   carb  hp cyl rowid\n1 20.09062 230.7219 3.596563 3.21725 17.84875  0  0 3.6875 2.8125  52   6     1\n2 20.09062 230.7219 3.596563 3.21725 17.84875  0  0 3.6875 2.8125  52   4     2\n3 20.09062 230.7219 3.596563 3.21725 17.84875  0  0 3.6875 2.8125  52   8     3\n4 20.09062 230.7219 3.596563 3.21725 17.84875  0  0 3.6875 2.8125 335   6     4\n5 20.09062 230.7219 3.596563 3.21725 17.84875  0  0 3.6875 2.8125 335   4     5\n6 20.09062 230.7219 3.596563 3.21725 17.84875  0  0 3.6875 2.8125 335   8     6\n\ncomparisons(mod, newdata = datagrid(hp = fivenum))\n\n\n Term  hp Estimate Std. Error     z Pr(&gt;|z|)    S   2.5 %  97.5 %\n   hp  52  -0.0682     0.0101 -6.74   &lt;0.001 35.9 -0.0881 -0.0484\n   hp  96  -0.0682     0.0101 -6.74   &lt;0.001 35.9 -0.0881 -0.0484\n   hp 123  -0.0682     0.0101 -6.74   &lt;0.001 35.9 -0.0881 -0.0484\n   hp 180  -0.0682     0.0101 -6.74   &lt;0.001 35.9 -0.0881 -0.0484\n   hp 335  -0.0682     0.0101 -6.74   &lt;0.001 35.9 -0.0881 -0.0484\n\nType:  response \nComparison: +1\nColumns: rowid, term, contrast, estimate, std.error, statistic, p.value, s.value, conf.low, conf.high, hp, predicted_lo, predicted_hi, predicted, mpg \n\n# The full dataset is duplicated with each observation given counterfactual\n# values of 100 and 110 for the `hp` variable. The original `mtcars` includes\n# 32 rows, so the resulting dataset includes 64 rows.\ndg &lt;- datagrid(newdata = mtcars, hp = c(100, 110), grid_type = \"counterfactual\")\nnrow(dg)\n\n[1] 64\n\n# We get the same result by feeding a model instead of a data.frame\nmod &lt;- lm(mpg ~ hp, mtcars)\ndg &lt;- datagrid(model = mod, hp = c(100, 110), grid_type = \"counterfactual\")\nnrow(dg)\n\n[1] 64",
    "crumbs": [
      "Model to Meaning",
      "Functions",
      "`datagrid`"
    ]
  },
  {
    "objectID": "man/posterior_draws.html",
    "href": "man/posterior_draws.html",
    "title": "",
    "section": "",
    "text": "Extract Posterior Draws or Bootstrap Resamples from marginaleffects Objects\n\n\n\nposterior_draws(x, shape = \"long\")\n\n\n\n\n\n\n\nx\n\n\nAn object produced by a marginaleffects package function, such as predictions(), avg_slopes(), hypotheses(), etc.\n\n\n\n\nshape\n\n\nstring indicating the shape of the output format:\n\n\n\"long\": long format data frame\n\n\n\"DxP\": Matrix with draws as rows and parameters as columns\n\n\n\"PxD\": Matrix with draws as rows and parameters as columns\n\n\n\"rvar\": Random variable datatype (see posterior package documentation).\n\n\n\n\n\n\n\n\nA data.frame with drawid and draw columns.",
    "crumbs": [
      "Model to Meaning",
      "Functions",
      "`posterior_draws`"
    ]
  },
  {
    "objectID": "man/posterior_draws.html#extract-posterior-draws-or-bootstrap-resamples-from-marginaleffects-objects",
    "href": "man/posterior_draws.html#extract-posterior-draws-or-bootstrap-resamples-from-marginaleffects-objects",
    "title": "",
    "section": "",
    "text": "Extract Posterior Draws or Bootstrap Resamples from marginaleffects Objects\n\n\n\nposterior_draws(x, shape = \"long\")\n\n\n\n\n\n\n\nx\n\n\nAn object produced by a marginaleffects package function, such as predictions(), avg_slopes(), hypotheses(), etc.\n\n\n\n\nshape\n\n\nstring indicating the shape of the output format:\n\n\n\"long\": long format data frame\n\n\n\"DxP\": Matrix with draws as rows and parameters as columns\n\n\n\"PxD\": Matrix with draws as rows and parameters as columns\n\n\n\"rvar\": Random variable datatype (see posterior package documentation).\n\n\n\n\n\n\n\n\nA data.frame with drawid and draw columns.",
    "crumbs": [
      "Model to Meaning",
      "Functions",
      "`posterior_draws`"
    ]
  },
  {
    "objectID": "man/plot_comparisons.html",
    "href": "man/plot_comparisons.html",
    "title": "",
    "section": "",
    "text": "Plot comparisons on the y-axis against values of one or more predictors (x-axis, colors/shapes, and facets).\nThe by argument is used to plot marginal comparisons, that is, comparisons made on the original data, but averaged by subgroups. This is analogous to using the by argument in the comparisons() function.\nThe condition argument is used to plot conditional comparisons, that is, comparisons made on a user-specified grid. This is analogous to using the newdata argument and datagrid() function in a comparisons() call. All variables whose values are not specified explicitly are treated as usual by datagrid(), that is, they are held at their mean or mode (or rounded mean for integers). This includes grouping variables in mixed-effects models, so analysts who fit such models may want to specify the groups of interest using the condition argument, or supply model-specific arguments to compute population-level estimates. See details below.\nSee the \"Plots\" vignette and website for tutorials and information on how to customize plots:\n\n\nhttps://marginaleffects.com/vignettes/plot.html\n\n\nhttps://marginaleffects.com\n\n\nplot_comparisons(\n  model,\n  variables = NULL,\n  condition = NULL,\n  by = NULL,\n  newdata = NULL,\n  type = NULL,\n  vcov = NULL,\n  conf_level = 0.95,\n  wts = FALSE,\n  comparison = \"difference\",\n  transform = NULL,\n  rug = FALSE,\n  gray = FALSE,\n  draw = TRUE,\n  ...\n)\n\n\n\n\n\nmodel\n\n\nModel object\n\n\n\n\nvariables\n\n\nName of the variable whose contrast we want to plot on the y-axis.\n\n\n\n\ncondition\n\n\nConditional slopes\n\n\nCharacter vector (max length 4): Names of the predictors to display.\n\n\nNamed list (max length 4): List names correspond to predictors. List elements can be:\n\n\nNumeric vector\n\n\nFunction which returns a numeric vector or a set of unique categorical values\n\n\nShortcut strings for common reference values: \"minmax\", \"quartile\", \"threenum\"\n\n\n\n\n1: x-axis. 2: color/shape. 3: facet (wrap if no fourth variable, otherwise cols of grid). 4: facet (rows of grid).\n\n\nNumeric variables in positions 2 and 3 are summarized by Tukey’s five numbers ?stats::fivenum.\n\n\n\n\n\n\nby\n\n\nAggregate unit-level estimates (aka, marginalize, average over). Valid inputs:\n\n\nFALSE: return the original unit-level estimates.\n\n\nTRUE: aggregate estimates for each term.\n\n\nCharacter vector of column names in newdata or in the data frame produced by calling the function without the by argument.\n\n\nData frame with a by column of group labels, and merging columns shared by newdata or the data frame produced by calling the same function without the by argument.\n\n\nSee examples below.\n\n\nFor more complex aggregations, you can use the FUN argument of the hypotheses() function. See that function’s documentation and the Hypothesis Test vignettes on the marginaleffects website.\n\n\n\n\n\n\nnewdata\n\n\nWhen newdata is NULL, the grid is determined by the condition argument. When newdata is not NULL, the argument behaves in the same way as in the comparisons() function.\n\n\n\n\ntype\n\n\nstring indicates the type (scale) of the predictions used to compute contrasts or slopes. This can differ based on the model type, but will typically be a string such as: \"response\", \"link\", \"probs\", or \"zero\". When an unsupported string is entered, the model-specific list of acceptable values is returned in an error message. When type is NULL, the first entry in the error message is used by default.\n\n\n\n\nvcov\n\n\nType of uncertainty estimates to report (e.g., for robust standard errors). Acceptable values:\n\n\nFALSE: Do not compute standard errors. This can speed up computation considerably.\n\n\nTRUE: Unit-level standard errors using the default vcov(model) variance-covariance matrix.\n\n\nString which indicates the kind of uncertainty estimates to return.\n\n\nHeteroskedasticity-consistent: “HC”, “HC0”, “HC1”, “HC2”, “HC3”, “HC4”, “HC4m”, “HC5”. See ?sandwich::vcovHC\n\n\nHeteroskedasticity and autocorrelation consistent: “HAC”\n\n\nMixed-Models degrees of freedom: \"satterthwaite\", \"kenward-roger\"\n\n\nOther: “NeweyWest”, “KernHAC”, “OPG”. See the sandwich package documentation.\n\n\n\n\nOne-sided formula which indicates the name of cluster variables (e.g., ~unit_id). This formula is passed to the cluster argument of the sandwich::vcovCL function.\n\n\nSquare covariance matrix\n\n\nFunction which returns a covariance matrix (e.g., stats::vcov(model))\n\n\n\n\n\n\nconf_level\n\n\nnumeric value between 0 and 1. Confidence level to use to build a confidence interval.\n\n\n\n\nwts\n\n\nlogical, string or numeric: weights to use when computing average predictions, contrasts or slopes. These weights only affect the averaging in avg_*() or with the by argument, and not unit-level estimates. See ?weighted.mean\n\n\nstring: column name of the weights variable in newdata. When supplying a column name to wts, it is recommended to supply the original data (including the weights variable) explicitly to newdata.\n\n\nnumeric: vector of length equal to the number of rows in the original data or in newdata (if supplied).\n\n\nFALSE: Equal weights.\n\n\nTRUE: Extract weights from the fitted object with insight::find_weights() and use them when taking weighted averages of estimates. Warning: newdata=datagrid() returns a single average weight, which is equivalent to using wts=FALSE\n\n\n\n\n\n\ncomparison\n\n\nHow should pairs of predictions be compared? Difference, ratio, odds ratio, or user-defined functions.\n\n\nstring: shortcuts to common contrast functions.\n\n\nSupported shortcuts strings: difference, differenceavg, differenceavgwts, dydx, eyex, eydx, dyex, dydxavg, eyexavg, eydxavg, dyexavg, dydxavgwts, eyexavgwts, eydxavgwts, dyexavgwts, ratio, ratioavg, ratioavgwts, lnratio, lnratioavg, lnratioavgwts, lnor, lnoravg, lnoravgwts, lift, liftavg, liftavgwts, expdydx, expdydxavg, expdydxavgwts\n\n\nSee the Comparisons section below for definitions of each transformation.\n\n\n\n\nfunction: accept two equal-length numeric vectors of adjusted predictions (hi and lo) and returns a vector of contrasts of the same length, or a unique numeric value.\n\n\nSee the Transformations section below for examples of valid functions.\n\n\n\n\n\n\n\n\ntransform\n\n\nstring or function. Transformation applied to unit-level estimates and confidence intervals just before the function returns results. Functions must accept a vector and return a vector of the same length. Support string shortcuts: \"exp\", \"ln\"\n\n\n\n\nrug\n\n\nTRUE displays tick marks on the axes to mark the distribution of raw data.\n\n\n\n\ngray\n\n\nFALSE grayscale or color plot\n\n\n\n\ndraw\n\n\nTRUE returns a ggplot2 plot. FALSE returns a data.frame of the underlying data.\n\n\n\n\n…\n\n\nAdditional arguments are passed to the predict() method supplied by the modeling package.These arguments are particularly useful for mixed-effects or bayesian models (see the online vignettes on the marginaleffects website). Available arguments can vary from model to model, depending on the range of supported arguments by each modeling package. See the \"Model-Specific Arguments\" section of the ?slopes documentation for a non-exhaustive list of available arguments.\n\n\n\nA ggplot2 object\n\nSome model types allow model-specific arguments to modify the nature of marginal effects, predictions, marginal means, and contrasts. Please report other package-specific predict() arguments on Github so we can add them to the table below.\nhttps://github.com/vincentarelbundock/marginaleffects/issues\n\n\n\nPackage\n\n\nClass\n\n\nArgument\n\n\nDocumentation\n\n\n\n\nbrms\n\n\nbrmsfit\n\n\nndraws\n\n\nbrms::posterior_predict\n\n\n\n\n\n\n\n\nre_formula\n\n\nbrms::posterior_predict\n\n\n\n\nlme4\n\n\nmerMod\n\n\nre.form\n\n\nlme4::predict.merMod\n\n\n\n\n\n\n\n\nallow.new.levels\n\n\nlme4::predict.merMod\n\n\n\n\nglmmTMB\n\n\nglmmTMB\n\n\nre.form\n\n\nglmmTMB::predict.glmmTMB\n\n\n\n\n\n\n\n\nallow.new.levels\n\n\nglmmTMB::predict.glmmTMB\n\n\n\n\n\n\n\n\nzitype\n\n\nglmmTMB::predict.glmmTMB\n\n\n\n\nmgcv\n\n\nbam\n\n\nexclude\n\n\nmgcv::predict.bam\n\n\n\n\n\n\ngam\n\n\nexclude\n\n\nmgcv::predict.gam\n\n\n\n\nrobustlmm\n\n\nrlmerMod\n\n\nre.form\n\n\nrobustlmm::predict.rlmerMod\n\n\n\n\n\n\n\n\nallow.new.levels\n\n\nrobustlmm::predict.rlmerMod\n\n\n\n\nMCMCglmm\n\n\nMCMCglmm\n\n\nndraws\n\n\n\n\n\n\nsampleSelection\n\n\nselection\n\n\npart\n\n\nsampleSelection::predict.selection\n\n\n\n\n\n\n\n\nlibrary(\"marginaleffects\")\n\nmod &lt;- lm(mpg ~ hp * drat * factor(am), data = mtcars)\n\nplot_comparisons(mod, variables = \"hp\", condition = \"drat\")\n\n\n\n\n\n\nplot_comparisons(mod, variables = \"hp\", condition = c(\"drat\", \"am\"))\n\n\n\n\n\n\nplot_comparisons(mod, variables = \"hp\", condition = list(\"am\", \"drat\" = 3:5))\n\n\n\n\n\n\nplot_comparisons(mod, variables = \"am\", condition = list(\"hp\", \"drat\" = range))\n\n\n\n\n\n\nplot_comparisons(mod, variables = \"am\", condition = list(\"hp\", \"drat\" = \"threenum\"))",
    "crumbs": [
      "Model to Meaning",
      "Functions",
      "`plot_comparisons`"
    ]
  },
  {
    "objectID": "man/plot_comparisons.html#plot-conditional-or-marginal-comparisons",
    "href": "man/plot_comparisons.html#plot-conditional-or-marginal-comparisons",
    "title": "",
    "section": "",
    "text": "Plot comparisons on the y-axis against values of one or more predictors (x-axis, colors/shapes, and facets).\nThe by argument is used to plot marginal comparisons, that is, comparisons made on the original data, but averaged by subgroups. This is analogous to using the by argument in the comparisons() function.\nThe condition argument is used to plot conditional comparisons, that is, comparisons made on a user-specified grid. This is analogous to using the newdata argument and datagrid() function in a comparisons() call. All variables whose values are not specified explicitly are treated as usual by datagrid(), that is, they are held at their mean or mode (or rounded mean for integers). This includes grouping variables in mixed-effects models, so analysts who fit such models may want to specify the groups of interest using the condition argument, or supply model-specific arguments to compute population-level estimates. See details below.\nSee the \"Plots\" vignette and website for tutorials and information on how to customize plots:\n\n\nhttps://marginaleffects.com/vignettes/plot.html\n\n\nhttps://marginaleffects.com\n\n\nplot_comparisons(\n  model,\n  variables = NULL,\n  condition = NULL,\n  by = NULL,\n  newdata = NULL,\n  type = NULL,\n  vcov = NULL,\n  conf_level = 0.95,\n  wts = FALSE,\n  comparison = \"difference\",\n  transform = NULL,\n  rug = FALSE,\n  gray = FALSE,\n  draw = TRUE,\n  ...\n)\n\n\n\n\n\nmodel\n\n\nModel object\n\n\n\n\nvariables\n\n\nName of the variable whose contrast we want to plot on the y-axis.\n\n\n\n\ncondition\n\n\nConditional slopes\n\n\nCharacter vector (max length 4): Names of the predictors to display.\n\n\nNamed list (max length 4): List names correspond to predictors. List elements can be:\n\n\nNumeric vector\n\n\nFunction which returns a numeric vector or a set of unique categorical values\n\n\nShortcut strings for common reference values: \"minmax\", \"quartile\", \"threenum\"\n\n\n\n\n1: x-axis. 2: color/shape. 3: facet (wrap if no fourth variable, otherwise cols of grid). 4: facet (rows of grid).\n\n\nNumeric variables in positions 2 and 3 are summarized by Tukey’s five numbers ?stats::fivenum.\n\n\n\n\n\n\nby\n\n\nAggregate unit-level estimates (aka, marginalize, average over). Valid inputs:\n\n\nFALSE: return the original unit-level estimates.\n\n\nTRUE: aggregate estimates for each term.\n\n\nCharacter vector of column names in newdata or in the data frame produced by calling the function without the by argument.\n\n\nData frame with a by column of group labels, and merging columns shared by newdata or the data frame produced by calling the same function without the by argument.\n\n\nSee examples below.\n\n\nFor more complex aggregations, you can use the FUN argument of the hypotheses() function. See that function’s documentation and the Hypothesis Test vignettes on the marginaleffects website.\n\n\n\n\n\n\nnewdata\n\n\nWhen newdata is NULL, the grid is determined by the condition argument. When newdata is not NULL, the argument behaves in the same way as in the comparisons() function.\n\n\n\n\ntype\n\n\nstring indicates the type (scale) of the predictions used to compute contrasts or slopes. This can differ based on the model type, but will typically be a string such as: \"response\", \"link\", \"probs\", or \"zero\". When an unsupported string is entered, the model-specific list of acceptable values is returned in an error message. When type is NULL, the first entry in the error message is used by default.\n\n\n\n\nvcov\n\n\nType of uncertainty estimates to report (e.g., for robust standard errors). Acceptable values:\n\n\nFALSE: Do not compute standard errors. This can speed up computation considerably.\n\n\nTRUE: Unit-level standard errors using the default vcov(model) variance-covariance matrix.\n\n\nString which indicates the kind of uncertainty estimates to return.\n\n\nHeteroskedasticity-consistent: “HC”, “HC0”, “HC1”, “HC2”, “HC3”, “HC4”, “HC4m”, “HC5”. See ?sandwich::vcovHC\n\n\nHeteroskedasticity and autocorrelation consistent: “HAC”\n\n\nMixed-Models degrees of freedom: \"satterthwaite\", \"kenward-roger\"\n\n\nOther: “NeweyWest”, “KernHAC”, “OPG”. See the sandwich package documentation.\n\n\n\n\nOne-sided formula which indicates the name of cluster variables (e.g., ~unit_id). This formula is passed to the cluster argument of the sandwich::vcovCL function.\n\n\nSquare covariance matrix\n\n\nFunction which returns a covariance matrix (e.g., stats::vcov(model))\n\n\n\n\n\n\nconf_level\n\n\nnumeric value between 0 and 1. Confidence level to use to build a confidence interval.\n\n\n\n\nwts\n\n\nlogical, string or numeric: weights to use when computing average predictions, contrasts or slopes. These weights only affect the averaging in avg_*() or with the by argument, and not unit-level estimates. See ?weighted.mean\n\n\nstring: column name of the weights variable in newdata. When supplying a column name to wts, it is recommended to supply the original data (including the weights variable) explicitly to newdata.\n\n\nnumeric: vector of length equal to the number of rows in the original data or in newdata (if supplied).\n\n\nFALSE: Equal weights.\n\n\nTRUE: Extract weights from the fitted object with insight::find_weights() and use them when taking weighted averages of estimates. Warning: newdata=datagrid() returns a single average weight, which is equivalent to using wts=FALSE\n\n\n\n\n\n\ncomparison\n\n\nHow should pairs of predictions be compared? Difference, ratio, odds ratio, or user-defined functions.\n\n\nstring: shortcuts to common contrast functions.\n\n\nSupported shortcuts strings: difference, differenceavg, differenceavgwts, dydx, eyex, eydx, dyex, dydxavg, eyexavg, eydxavg, dyexavg, dydxavgwts, eyexavgwts, eydxavgwts, dyexavgwts, ratio, ratioavg, ratioavgwts, lnratio, lnratioavg, lnratioavgwts, lnor, lnoravg, lnoravgwts, lift, liftavg, liftavgwts, expdydx, expdydxavg, expdydxavgwts\n\n\nSee the Comparisons section below for definitions of each transformation.\n\n\n\n\nfunction: accept two equal-length numeric vectors of adjusted predictions (hi and lo) and returns a vector of contrasts of the same length, or a unique numeric value.\n\n\nSee the Transformations section below for examples of valid functions.\n\n\n\n\n\n\n\n\ntransform\n\n\nstring or function. Transformation applied to unit-level estimates and confidence intervals just before the function returns results. Functions must accept a vector and return a vector of the same length. Support string shortcuts: \"exp\", \"ln\"\n\n\n\n\nrug\n\n\nTRUE displays tick marks on the axes to mark the distribution of raw data.\n\n\n\n\ngray\n\n\nFALSE grayscale or color plot\n\n\n\n\ndraw\n\n\nTRUE returns a ggplot2 plot. FALSE returns a data.frame of the underlying data.\n\n\n\n\n…\n\n\nAdditional arguments are passed to the predict() method supplied by the modeling package.These arguments are particularly useful for mixed-effects or bayesian models (see the online vignettes on the marginaleffects website). Available arguments can vary from model to model, depending on the range of supported arguments by each modeling package. See the \"Model-Specific Arguments\" section of the ?slopes documentation for a non-exhaustive list of available arguments.\n\n\n\nA ggplot2 object\n\nSome model types allow model-specific arguments to modify the nature of marginal effects, predictions, marginal means, and contrasts. Please report other package-specific predict() arguments on Github so we can add them to the table below.\nhttps://github.com/vincentarelbundock/marginaleffects/issues\n\n\n\nPackage\n\n\nClass\n\n\nArgument\n\n\nDocumentation\n\n\n\n\nbrms\n\n\nbrmsfit\n\n\nndraws\n\n\nbrms::posterior_predict\n\n\n\n\n\n\n\n\nre_formula\n\n\nbrms::posterior_predict\n\n\n\n\nlme4\n\n\nmerMod\n\n\nre.form\n\n\nlme4::predict.merMod\n\n\n\n\n\n\n\n\nallow.new.levels\n\n\nlme4::predict.merMod\n\n\n\n\nglmmTMB\n\n\nglmmTMB\n\n\nre.form\n\n\nglmmTMB::predict.glmmTMB\n\n\n\n\n\n\n\n\nallow.new.levels\n\n\nglmmTMB::predict.glmmTMB\n\n\n\n\n\n\n\n\nzitype\n\n\nglmmTMB::predict.glmmTMB\n\n\n\n\nmgcv\n\n\nbam\n\n\nexclude\n\n\nmgcv::predict.bam\n\n\n\n\n\n\ngam\n\n\nexclude\n\n\nmgcv::predict.gam\n\n\n\n\nrobustlmm\n\n\nrlmerMod\n\n\nre.form\n\n\nrobustlmm::predict.rlmerMod\n\n\n\n\n\n\n\n\nallow.new.levels\n\n\nrobustlmm::predict.rlmerMod\n\n\n\n\nMCMCglmm\n\n\nMCMCglmm\n\n\nndraws\n\n\n\n\n\n\nsampleSelection\n\n\nselection\n\n\npart\n\n\nsampleSelection::predict.selection\n\n\n\n\n\n\n\n\nlibrary(\"marginaleffects\")\n\nmod &lt;- lm(mpg ~ hp * drat * factor(am), data = mtcars)\n\nplot_comparisons(mod, variables = \"hp\", condition = \"drat\")\n\n\n\n\n\n\nplot_comparisons(mod, variables = \"hp\", condition = c(\"drat\", \"am\"))\n\n\n\n\n\n\nplot_comparisons(mod, variables = \"hp\", condition = list(\"am\", \"drat\" = 3:5))\n\n\n\n\n\n\nplot_comparisons(mod, variables = \"am\", condition = list(\"hp\", \"drat\" = range))\n\n\n\n\n\n\nplot_comparisons(mod, variables = \"am\", condition = list(\"hp\", \"drat\" = \"threenum\"))",
    "crumbs": [
      "Model to Meaning",
      "Functions",
      "`plot_comparisons`"
    ]
  },
  {
    "objectID": "man/comparisons.html",
    "href": "man/comparisons.html",
    "title": "",
    "section": "",
    "text": "Predict the outcome variable at different regressor values (e.g., college graduates vs. others), and compare those predictions by computing a difference, ratio, or some other function. comparisons() can return many quantities of interest, such as contrasts, differences, risk ratios, changes in log odds, lift, slopes, elasticities, etc.\n\n\ncomparisons(): unit-level (conditional) estimates.\n\n\navg_comparisons(): average (marginal) estimates.\n\n\nvariables identifies the focal regressors whose \"effect\" we are interested in. comparison determines how predictions with different regressor values are compared (difference, ratio, odds, etc.). The newdata argument and the datagrid() function control where statistics are evaluated in the predictor space: \"at observed values\", \"at the mean\", \"at representative values\", etc.\nSee the comparisons vignette and package website for worked examples and case studies:\n\n\nhttps://marginaleffects.com/vignettes/comparisons.html\n\n\nhttps://marginaleffects.com/\n\n\ncomparisons(\n  model,\n  newdata = NULL,\n  variables = NULL,\n  comparison = \"difference\",\n  type = NULL,\n  vcov = TRUE,\n  by = FALSE,\n  conf_level = 0.95,\n  transform = NULL,\n  cross = FALSE,\n  wts = FALSE,\n  hypothesis = NULL,\n  equivalence = NULL,\n  p_adjust = NULL,\n  df = Inf,\n  eps = NULL,\n  numderiv = \"fdforward\",\n  ...\n)\n\navg_comparisons(\n  model,\n  newdata = NULL,\n  variables = NULL,\n  type = NULL,\n  vcov = TRUE,\n  by = TRUE,\n  conf_level = 0.95,\n  comparison = \"difference\",\n  transform = NULL,\n  cross = FALSE,\n  wts = FALSE,\n  hypothesis = NULL,\n  equivalence = NULL,\n  p_adjust = NULL,\n  df = Inf,\n  eps = NULL,\n  numderiv = \"fdforward\",\n  ...\n)\n\n\n\n\n\nmodel\n\n\nModel object\n\n\n\n\nnewdata\n\n\nGrid of predictor values at which we evaluate the comparisons.\n\n\nWarning: Avoid modifying your dataset between fitting the model and calling a marginaleffects function. This can sometimes lead to unexpected results.\n\n\nNULL (default): Unit-level contrasts for each observed value in the dataset (empirical distribution). The dataset is retrieved using insight::get_data(), which tries to extract data from the environment. This may produce unexpected results if the original data frame has been altered since fitting the model.\n\n\ndata frame: Unit-level contrasts for each row of the newdata data frame.\n\n\nstring:\n\n\n\"mean\": Contrasts at the Mean. Contrasts when each predictor is held at its mean or mode.\n\n\n\"median\": Contrasts at the Median. Contrasts when each predictor is held at its median or mode.\n\n\n\"balanced\": Contrasts evaluated on a balanced grid with every combination of categories and numeric variables held at their means.\n\n\n\"tukey\": Contrasts at Tukey’s 5 numbers.\n\n\n\"grid\": Contrasts on a grid of representative numbers (Tukey’s 5 numbers and unique values of categorical predictors).\n\n\n\n\ndatagrid() call to specify a custom grid of regressors. For example:\n\n\nnewdata = datagrid(cyl = c(4, 6)): cyl variable equal to 4 and 6 and other regressors fixed at their means or modes.\n\n\nnewdata = datagrid(mpg = fivenum): mpg variable held at Tukey’s five numbers (using the fivenum function), and other regressors fixed at their means or modes.\n\n\nSee the Examples section and the datagrid documentation.\n\n\n\n\nsubset() call with a single argument to select a subset of the dataset used to fit the model, ex: newdata = subset(treatment == 1)\n\n\ndplyr::filter() call with a single argument to select a subset of the dataset used to fit the model, ex: newdata = filter(treatment == 1)\n\n\n\n\n\n\nvariables\n\n\nFocal variables\n\n\nNULL: compute comparisons for all the variables in the model object (can be slow).\n\n\nCharacter vector: subset of variables (usually faster).\n\n\nNamed list: names identify the subset of variables of interest, and values define the type of contrast to compute. Acceptable values depend on the variable type:\n\n\nFactor or character variables:\n\n\n\"reference\": Each factor level is compared to the factor reference (base) level\n\n\n\"all\": All combinations of observed levels\n\n\n\"sequential\": Each factor level is compared to the previous factor level\n\n\n\"pairwise\": Each factor level is compared to all other levels\n\n\n\"minmax\": The highest and lowest levels of a factor.\n\n\n\"revpairwise\", \"revreference\", \"revsequential\": inverse of the corresponding hypotheses.\n\n\nVector of length 2 with the two values to compare.\n\n\nData frame with the same number of rows as newdata, with two columns of \"lo\" and \"hi\" values to compare.\n\n\nFunction that accepts a vector and returns a data frame with two columns of \"lo\" and \"hi\" values to compare. See examples below.\n\n\n\n\nLogical variables:\n\n\nNULL: contrast between TRUE and FALSE\n\n\nData frame with the same number of rows as newdata, with two columns of \"lo\" and \"hi\" values to compare.\n\n\nFunction that accepts a vector and returns a data frame with two columns of \"lo\" and \"hi\" values to compare. See examples below.\n\n\n\n\nNumeric variables:\n\n\nNumeric of length 1: Forward contrast for a gap of x, computed between the observed value and the observed value plus x. Users can set a global option to get a \"center\" or \"backward\" contrast instead: options(marginaleffects_contrast_direction=“center”)\n\n\nNumeric vector of length 2: Contrast between the largest and the smallest elements of the x vector.\n\n\nData frame with the same number of rows as newdata, with two columns of \"lo\" and \"hi\" values to compare.\n\n\nFunction that accepts a vector and returns a data frame with two columns of \"lo\" and \"hi\" values to compare. See examples below.\n\n\n\"iqr\": Contrast across the interquartile range of the regressor.\n\n\n\"sd\": Contrast across one standard deviation around the regressor mean.\n\n\n\"2sd\": Contrast across two standard deviations around the regressor mean.\n\n\n\"minmax\": Contrast between the maximum and the minimum values of the regressor.\n\n\n\n\nExamples:\n\n\nvariables = list(gear = “pairwise”, hp = 10)\n\n\nvariables = list(gear = “sequential”, hp = c(100, 120))\n\n\nvariables = list(hp = (x) data.frame(low = x - 5, high = x + 10))\n\n\nSee the Examples section below for more.\n\n\n\n\n\n\n\n\n\n\ncomparison\n\n\nHow should pairs of predictions be compared? Difference, ratio, odds ratio, or user-defined functions.\n\n\nstring: shortcuts to common contrast functions.\n\n\nSupported shortcuts strings: difference, differenceavg, differenceavgwts, dydx, eyex, eydx, dyex, dydxavg, eyexavg, eydxavg, dyexavg, dydxavgwts, eyexavgwts, eydxavgwts, dyexavgwts, ratio, ratioavg, ratioavgwts, lnratio, lnratioavg, lnratioavgwts, lnor, lnoravg, lnoravgwts, lift, liftavg, liftavgwts, expdydx, expdydxavg, expdydxavgwts\n\n\nSee the Comparisons section below for definitions of each transformation.\n\n\n\n\nfunction: accept two equal-length numeric vectors of adjusted predictions (hi and lo) and returns a vector of contrasts of the same length, or a unique numeric value.\n\n\nSee the Transformations section below for examples of valid functions.\n\n\n\n\n\n\n\n\ntype\n\n\nstring indicates the type (scale) of the predictions used to compute contrasts or slopes. This can differ based on the model type, but will typically be a string such as: \"response\", \"link\", \"probs\", or \"zero\". When an unsupported string is entered, the model-specific list of acceptable values is returned in an error message. When type is NULL, the first entry in the error message is used by default.\n\n\n\n\nvcov\n\n\nType of uncertainty estimates to report (e.g., for robust standard errors). Acceptable values:\n\n\nFALSE: Do not compute standard errors. This can speed up computation considerably.\n\n\nTRUE: Unit-level standard errors using the default vcov(model) variance-covariance matrix.\n\n\nString which indicates the kind of uncertainty estimates to return.\n\n\nHeteroskedasticity-consistent: “HC”, “HC0”, “HC1”, “HC2”, “HC3”, “HC4”, “HC4m”, “HC5”. See ?sandwich::vcovHC\n\n\nHeteroskedasticity and autocorrelation consistent: “HAC”\n\n\nMixed-Models degrees of freedom: \"satterthwaite\", \"kenward-roger\"\n\n\nOther: “NeweyWest”, “KernHAC”, “OPG”. See the sandwich package documentation.\n\n\n\n\nOne-sided formula which indicates the name of cluster variables (e.g., ~unit_id). This formula is passed to the cluster argument of the sandwich::vcovCL function.\n\n\nSquare covariance matrix\n\n\nFunction which returns a covariance matrix (e.g., stats::vcov(model))\n\n\n\n\n\n\nby\n\n\nAggregate unit-level estimates (aka, marginalize, average over). Valid inputs:\n\n\nFALSE: return the original unit-level estimates.\n\n\nTRUE: aggregate estimates for each term.\n\n\nCharacter vector of column names in newdata or in the data frame produced by calling the function without the by argument.\n\n\nData frame with a by column of group labels, and merging columns shared by newdata or the data frame produced by calling the same function without the by argument.\n\n\nSee examples below.\n\n\nFor more complex aggregations, you can use the FUN argument of the hypotheses() function. See that function’s documentation and the Hypothesis Test vignettes on the marginaleffects website.\n\n\n\n\n\n\nconf_level\n\n\nnumeric value between 0 and 1. Confidence level to use to build a confidence interval.\n\n\n\n\ntransform\n\n\nstring or function. Transformation applied to unit-level estimates and confidence intervals just before the function returns results. Functions must accept a vector and return a vector of the same length. Support string shortcuts: \"exp\", \"ln\"\n\n\n\n\ncross\n\n\n\n\nFALSE: Contrasts represent the change in adjusted predictions when one predictor changes and all other variables are held constant.\n\n\nTRUE: Contrasts represent the changes in adjusted predictions when all the predictors specified in the variables argument are manipulated simultaneously (a \"cross-contrast\").\n\n\n\n\n\n\nwts\n\n\nlogical, string or numeric: weights to use when computing average predictions, contrasts or slopes. These weights only affect the averaging in avg_*() or with the by argument, and not unit-level estimates. See ?weighted.mean\n\n\nstring: column name of the weights variable in newdata. When supplying a column name to wts, it is recommended to supply the original data (including the weights variable) explicitly to newdata.\n\n\nnumeric: vector of length equal to the number of rows in the original data or in newdata (if supplied).\n\n\nFALSE: Equal weights.\n\n\nTRUE: Extract weights from the fitted object with insight::find_weights() and use them when taking weighted averages of estimates. Warning: newdata=datagrid() returns a single average weight, which is equivalent to using wts=FALSE\n\n\n\n\n\n\nhypothesis\n\n\nspecify a hypothesis test or custom contrast using a numeric value, vector, or matrix; a string equation; string; a formula, or a function.\n\n\nNumeric:\n\n\nSingle value: the null hypothesis used in the computation of Z and p (before applying transform).\n\n\nVector: Weights to compute a linear combination of (custom contrast between) estimates. Length equal to the number of rows generated by the same function call, but without the hypothesis argument.\n\n\nMatrix: Each column is a vector of weights, as describe above, used to compute a distinct linear combination of (contrast between) estimates. The column names of the matrix are used as labels in the output.\n\n\n\n\nString equation to specify linear or non-linear hypothesis tests. If the term column uniquely identifies rows, terms can be used in the formula. Otherwise, use b1, b2, etc. to identify the position of each parameter. The b* wildcard can be used to test hypotheses on all estimates. If a named vector is used, the names are used as labels in the output. Examples:\n\n\nhp = drat\n\n\nhp + drat = 12\n\n\nb1 + b2 + b3 = 0\n\n\nb* / b1 = 1\n\n\n\n\nString:\n\n\n\"pairwise\": pairwise differences between estimates in each row.\n\n\n\"reference\": differences between the estimates in each row and the estimate in the first row.\n\n\n\"sequential\": difference between an estimate and the estimate in the next row.\n\n\n\"meandev\": difference between an estimate and the mean of all estimates.\n\n\n\"meanotherdev\": difference between an estimate and the mean of all other estimates, excluding the current one.\n\n\n\"revpairwise\", \"revreference\", \"revsequential\": inverse of the corresponding hypotheses, as described above.\n\n\n\n\nFormula:\n\n\ncomparison ~ pairs | group\n\n\nLeft-hand side determines the type of comparison to conduct: difference or ratio. If the left-hand side is empty, difference is chosen.\n\n\nRight-hand side determines the pairs of estimates to compare: reference, sequential, or meandev\n\n\nOptional: Users can supply grouping variables after a vertical bar to conduct comparisons withing subsets.\n\n\nExamples:\n\n\n~ reference\n\n\nratio ~ pairwise\n\n\ndifference ~ pairwise | groupid\n\n\n\n\n\n\nFunction:\n\n\nAccepts an argument x: object produced by a marginaleffects function or a data frame with column rowid and estimate\n\n\nReturns a data frame with columns term and estimate (mandatory) and rowid (optional).\n\n\nThe function can also accept optional input arguments: newdata, by, draws.\n\n\nThis function approach will not work for Bayesian models or with bootstrapping. In those cases, it is easy to use posterior_draws() to extract and manipulate the draws directly.\n\n\n\n\nSee the Examples section below and the vignette: https://marginaleffects.com/vignettes/hypothesis.html\n\n\n\n\n\n\nequivalence\n\n\nNumeric vector of length 2: bounds used for the two-one-sided test (TOST) of equivalence, and for the non-inferiority and non-superiority tests. See Details section below.\n\n\n\n\np_adjust\n\n\nAdjust p-values for multiple comparisons: \"holm\", \"hochberg\", \"hommel\", \"bonferroni\", \"BH\", \"BY\", or \"fdr\". See stats::p.adjust\n\n\n\n\ndf\n\n\nDegrees of freedom used to compute p values and confidence intervals. A single numeric value between 1 and Inf. When df is Inf, the normal distribution is used. When df is finite, the t distribution is used. See insight::get_df for a convenient function to extract degrees of freedom. Ex: slopes(model, df = insight::get_df(model))\n\n\n\n\neps\n\n\nNULL or numeric value which determines the step size to use when calculating numerical derivatives: (f(x+eps)-f(x))/eps. When eps is NULL, the step size is 0.0001 multiplied by the difference between the maximum and minimum values of the variable with respect to which we are taking the derivative. Changing eps may be necessary to avoid numerical problems in certain models.\n\n\n\n\nnumderiv\n\n\nstring or list of strings indicating the method to use to for the numeric differentiation used in to compute delta method standard errors.\n\n\n\"fdforward\": finite difference method with forward differences\n\n\n\"fdcenter\": finite difference method with central differences (default)\n\n\n\"richardson\": Richardson extrapolation method\n\n\nExtra arguments can be specified by passing a list to the numDeriv argument, with the name of the method first and named arguments following, ex: numderiv=list(“fdcenter”, eps = 1e-5). When an unknown argument is used, marginaleffects prints the list of valid arguments for each method.\n\n\n\n\n\n\n…\n\n\nAdditional arguments are passed to the predict() method supplied by the modeling package.These arguments are particularly useful for mixed-effects or bayesian models (see the online vignettes on the marginaleffects website). Available arguments can vary from model to model, depending on the range of supported arguments by each modeling package. See the \"Model-Specific Arguments\" section of the ?slopes documentation for a non-exhaustive list of available arguments.\n\n\n\nA data.frame with one row per observation (per term/group) and several columns:\n\n\nrowid: row number of the newdata data frame\n\n\ntype: prediction type, as defined by the type argument\n\n\ngroup: (optional) value of the grouped outcome (e.g., categorical outcome models)\n\n\nterm: the variable whose marginal effect is computed\n\n\ndydx: slope of the outcome with respect to the term, for a given combination of predictor values\n\n\nstd.error: standard errors computed by via the delta method.\n\n\np.value: p value associated to the estimate column. The null is determined by the hypothesis argument (0 by default), and p values are computed before applying the transform argument.\n\n\ns.value: Shannon information transforms of p values. How many consecutive \"heads\" tosses would provide the same amount of evidence (or \"surprise\") against the null hypothesis that the coin is fair? The purpose of S is to calibrate the analyst’s intuition about the strength of evidence encoded in p against a well-known physical phenomenon. See Greenland (2019) and Cole et al. (2020).\n\n\nconf.low: lower bound of the confidence interval (or equal-tailed interval for bayesian models)\n\n\nconf.high: upper bound of the confidence interval (or equal-tailed interval for bayesian models)\n\n\nSee ?print.marginaleffects for printing options.\n\n\n\navg_comparisons(): Average comparisons\n\n\nStandard errors for all quantities estimated by marginaleffects can be obtained via the delta method. This requires differentiating a function with respect to the coefficients in the model using a finite difference approach. In some models, the delta method standard errors can be sensitive to various aspects of the numeric differentiation strategy, including the step size. By default, the step size is set to 1e-8, or to 1e-4 times the smallest absolute model coefficient, whichever is largest.\nmarginaleffects can delegate numeric differentiation to the numDeriv package, which allows more flexibility. To do this, users can pass arguments to the numDeriv::jacobian function through a global option. For example:\n\n\noptions(marginaleffects_numDeriv = list(method = “simple”, method.args = list(eps = 1e-6)))\n\n\noptions(marginaleffects_numDeriv = list(method = “Richardson”, method.args = list(eps = 1e-5)))\n\n\noptions(marginaleffects_numDeriv = NULL)\n\n\nSee the \"Standard Errors and Confidence Intervals\" vignette on the marginaleffects website for more details on the computation of standard errors:\nhttps://marginaleffects.com/vignettes/uncertainty.html\nNote that the inferences() function can be used to compute uncertainty estimates using a bootstrap or simulation-based inference. See the vignette:\nhttps://marginaleffects.com/vignettes/bootstrap.html\n\nSome model types allow model-specific arguments to modify the nature of marginal effects, predictions, marginal means, and contrasts. Please report other package-specific predict() arguments on Github so we can add them to the table below.\nhttps://github.com/vincentarelbundock/marginaleffects/issues\n\n\n\nPackage\n\n\nClass\n\n\nArgument\n\n\nDocumentation\n\n\n\n\nbrms\n\n\nbrmsfit\n\n\nndraws\n\n\nbrms::posterior_predict\n\n\n\n\n\n\n\n\nre_formula\n\n\nbrms::posterior_predict\n\n\n\n\nlme4\n\n\nmerMod\n\n\nre.form\n\n\nlme4::predict.merMod\n\n\n\n\n\n\n\n\nallow.new.levels\n\n\nlme4::predict.merMod\n\n\n\n\nglmmTMB\n\n\nglmmTMB\n\n\nre.form\n\n\nglmmTMB::predict.glmmTMB\n\n\n\n\n\n\n\n\nallow.new.levels\n\n\nglmmTMB::predict.glmmTMB\n\n\n\n\n\n\n\n\nzitype\n\n\nglmmTMB::predict.glmmTMB\n\n\n\n\nmgcv\n\n\nbam\n\n\nexclude\n\n\nmgcv::predict.bam\n\n\n\n\n\n\ngam\n\n\nexclude\n\n\nmgcv::predict.gam\n\n\n\n\nrobustlmm\n\n\nrlmerMod\n\n\nre.form\n\n\nrobustlmm::predict.rlmerMod\n\n\n\n\n\n\n\n\nallow.new.levels\n\n\nrobustlmm::predict.rlmerMod\n\n\n\n\nMCMCglmm\n\n\nMCMCglmm\n\n\nndraws\n\n\n\n\n\n\nsampleSelection\n\n\nselection\n\n\npart\n\n\nsampleSelection::predict.selection\n\n\n\n\n\n\n\nThe following transformations can be applied by supplying one of the shortcut strings to the comparison argument. hi is a vector of adjusted predictions for the \"high\" side of the contrast. lo is a vector of adjusted predictions for the \"low\" side of the contrast. y is a vector of adjusted predictions for the original data. x is the predictor in the original data. eps is the step size to use to compute derivatives and elasticities.\n\n\n\nShortcut\n\n\nFunction\n\n\n\n\ndifference\n\n\n(hi, lo) hi - lo\n\n\n\n\ndifferenceavg\n\n\n(hi, lo) mean(hi - lo)\n\n\n\n\ndydx\n\n\n(hi, lo, eps) (hi - lo)/eps\n\n\n\n\neyex\n\n\n(hi, lo, eps, y, x) (hi - lo)/eps * (x/y)\n\n\n\n\neydx\n\n\n(hi, lo, eps, y, x) ((hi - lo)/eps)/y\n\n\n\n\ndyex\n\n\n(hi, lo, eps, x) ((hi - lo)/eps) * x\n\n\n\n\ndydxavg\n\n\n(hi, lo, eps) mean((hi - lo)/eps)\n\n\n\n\neyexavg\n\n\n(hi, lo, eps, y, x) mean((hi - lo)/eps * (x/y))\n\n\n\n\neydxavg\n\n\n(hi, lo, eps, y, x) mean(((hi - lo)/eps)/y)\n\n\n\n\ndyexavg\n\n\n(hi, lo, eps, x) mean(((hi - lo)/eps) * x)\n\n\n\n\nratio\n\n\n(hi, lo) hi/lo\n\n\n\n\nratioavg\n\n\n(hi, lo) mean(hi)/mean(lo)\n\n\n\n\nlnratio\n\n\n(hi, lo) log(hi/lo)\n\n\n\n\nlnratioavg\n\n\n(hi, lo) log(mean(hi)/mean(lo))\n\n\n\n\nlnor\n\n\n(hi, lo) log((hi/(1 - hi))/(lo/(1 - lo)))\n\n\n\n\nlnoravg\n\n\n(hi, lo) log((mean(hi)/(1 - mean(hi)))/(mean(lo)/(1 - mean(lo))))\n\n\n\n\nlift\n\n\n(hi, lo) (hi - lo)/lo\n\n\n\n\nliftavg\n\n\n(hi, lo) (mean(hi - lo))/mean(lo)\n\n\n\n\nexpdydx\n\n\n(hi, lo, eps) ((exp(hi) - exp(lo))/exp(eps))/eps\n\n\n\n\nexpdydxavg\n\n\n(hi, lo, eps) mean(((exp(hi) - exp(lo))/exp(eps))/eps)\n\n\n\n\n\n\n\nBy default, credible intervals in bayesian models are built as equal-tailed intervals. This can be changed to a highest density interval by setting a global option:\noptions(“marginaleffects_posterior_interval” = “eti”)\noptions(“marginaleffects_posterior_interval” = “hdi”)\nBy default, the center of the posterior distribution in bayesian models is identified by the median. Users can use a different summary function by setting a global option:\noptions(“marginaleffects_posterior_center” = “mean”)\noptions(“marginaleffects_posterior_center” = “median”)\nWhen estimates are averaged using the by argument, the tidy() function, or the summary() function, the posterior distribution is marginalized twice over. First, we take the average across units but within each iteration of the MCMC chain, according to what the user requested in by argument or tidy()/summary() functions. Then, we identify the center of the resulting posterior using the function supplied to the “marginaleffects_posterior_center” option (the median by default).\n\n\\(\\theta\\) is an estimate, \\(\\sigma_\\theta\\) its estimated standard error, and \\([a, b]\\) are the bounds of the interval supplied to the equivalence argument.\nNon-inferiority:\n\n\n\\(H_0\\): \\(\\theta \\leq a\\)\n\n\n\\(H_1\\): \\(\\theta &gt; a\\)\n\n\n\\(t=(\\theta - a)/\\sigma_\\theta\\)\n\n\np: Upper-tail probability\n\n\nNon-superiority:\n\n\n\\(H_0\\): \\(\\theta \\geq b\\)\n\n\n\\(H_1\\): \\(\\theta &lt; b\\)\n\n\n\\(t=(\\theta - b)/\\sigma_\\theta\\)\n\n\np: Lower-tail probability\n\n\nEquivalence: Two One-Sided Tests (TOST)\n\n\np: Maximum of the non-inferiority and non-superiority p values.\n\n\nThanks to Russell V. Lenth for the excellent emmeans package and documentation which inspired this feature.\n\nThe type argument determines the scale of the predictions used to compute quantities of interest with functions from the marginaleffects package. Admissible values for type depend on the model object. When users specify an incorrect value for type, marginaleffects will raise an informative error with a list of valid type values for the specific model object. The first entry in the list in that error message is the default type.\nThe invlink(link) is a special type defined by marginaleffects. It is available for some (but not all) models, and only for the predictions() function. With this link type, we first compute predictions on the link scale, then we use the inverse link function to backtransform the predictions to the response scale. This is useful for models with non-linear link functions as it can ensure that confidence intervals stay within desirable bounds, ex: 0 to 1 for a logit model. Note that an average of estimates with type=“invlink(link)” will not always be equivalent to the average of estimates with type=“response”. This type is default when calling predictions(). It is available—but not default—when calling avg_predictions() or predictions() with the by argument.\nSome of the most common type values are:\nresponse, link, E, Ep, average, class, conditional, count, cum.prob, cumhaz, cumprob, density, detection, disp, ev, expected, expvalue, fitted, hazard, invlink(link), latent, latent_N, linear, linear.predictor, linpred, location, lp, mean, numeric, p, ppd, pr, precision, prediction, prob, probability, probs, quantile, risk, rmst, scale, survival, unconditional, utility, variance, xb, zero, zlink, zprob\n\nBehind the scenes, the arguments of marginaleffects functions are evaluated in this order:\n\n\nnewdata\n\n\nvariables\n\n\ncomparison and slopes\n\n\nby\n\n\nvcov\n\n\nhypothesis\n\n\ntransform\n\n\nThe slopes() and comparisons() functions can use parallelism to speed up computation. Operations are parallelized for the computation of standard errors, at the model coefficient level. There is always considerable overhead when using parallel computation, mainly involved in passing the whole dataset to the different processes. Thus, parallel computation is most likely to be useful when the model includes many parameters and the dataset is relatively small.\nWarning: In many cases, parallel processing will not be useful at all.\nTo activate parallel computation, users must load the future.apply package, call plan() function, and set a global option. For example:\n\nlibrary(future.apply)\nplan(\"multicore\", workers = 4)\noptions(marginaleffects_parallel = TRUE)\n\nslopes(model)\n\n\nTo disable parallelism in marginaleffects altogether, you can set a global option:\n\noptions(marginaleffects_parallel = FALSE)\n\n\n\nThe behavior of marginaleffects functions can be modified by setting global options.\nDisable some safety checks:\n\noptions(marginaleffects_safe = FALSE)\n\n\nOmit some columns from the printed output:\n\noptions(marginaleffects_print_omit = c(\"p.value\", \"s.value\"))`\n\n\n\n\n\nGreenland S. 2019. \"Valid P-Values Behave Exactly as They Should: Some Misleading Criticisms of P-Values and Their Resolution With S-Values.\" The American Statistician. 73(S1): 106–114.\n\n\nCole, Stephen R, Jessie K Edwards, and Sander Greenland. 2020. \"Surprise!\" American Journal of Epidemiology 190 (2): 191–93. https://doi.org/10.1093/aje/kwaa136\n\n\n\nlibrary(\"marginaleffects\")\n\n\n\nlibrary(marginaleffects)\n\n# Linear model\ntmp &lt;- mtcars\ntmp$am &lt;- as.logical(tmp$am)\nmod &lt;- lm(mpg ~ am + factor(cyl), tmp)\navg_comparisons(mod, variables = list(cyl = \"reference\"))\navg_comparisons(mod, variables = list(cyl = \"sequential\"))\navg_comparisons(mod, variables = list(cyl = \"pairwise\"))\n\n# GLM with different scale types\nmod &lt;- glm(am ~ factor(gear), data = mtcars)\navg_comparisons(mod, type = \"response\")\navg_comparisons(mod, type = \"link\")\n\n# Contrasts at the mean\ncomparisons(mod, newdata = \"mean\")\n\n# Contrasts between marginal means\ncomparisons(mod, newdata = \"marginalmeans\")\n\n# Contrasts at user-specified values\ncomparisons(mod, newdata = datagrid(am = 0, gear = tmp$gear))\ncomparisons(mod, newdata = datagrid(am = unique, gear = max))\n\nm &lt;- lm(mpg ~ hp + drat + factor(cyl) + factor(am), data = mtcars)\ncomparisons(m, variables = \"hp\", newdata = datagrid(FUN_factor = unique, FUN_numeric = median))\n\n# Numeric contrasts\nmod &lt;- lm(mpg ~ hp, data = mtcars)\navg_comparisons(mod, variables = list(hp = 1))\navg_comparisons(mod, variables = list(hp = 5))\navg_comparisons(mod, variables = list(hp = c(90, 100)))\navg_comparisons(mod, variables = list(hp = \"iqr\"))\navg_comparisons(mod, variables = list(hp = \"sd\"))\navg_comparisons(mod, variables = list(hp = \"minmax\"))\n\n# using a function to specify a custom difference in one regressor\ndat &lt;- mtcars\ndat$new_hp &lt;- 49 * (dat$hp - min(dat$hp)) / (max(dat$hp) - min(dat$hp)) + 1\nmodlog &lt;- lm(mpg ~ log(new_hp) + factor(cyl), data = dat)\nfdiff &lt;- \\(x) data.frame(x, x + 10)\navg_comparisons(modlog, variables = list(new_hp = fdiff))\n\n# Adjusted Risk Ratio: see the contrasts vignette\nmod &lt;- glm(vs ~ mpg, data = mtcars, family = binomial)\navg_comparisons(mod, comparison = \"lnratioavg\", transform = exp)\n\n# Adjusted Risk Ratio: Manual specification of the `comparison`\navg_comparisons(\n     mod,\n     comparison = function(hi, lo) log(mean(hi) / mean(lo)),\n     transform = exp)\n# cross contrasts\nmod &lt;- lm(mpg ~ factor(cyl) * factor(gear) + hp, data = mtcars)\navg_comparisons(mod, variables = c(\"cyl\", \"gear\"), cross = TRUE)\n\n# variable-specific contrasts\navg_comparisons(mod, variables = list(gear = \"sequential\", hp = 10))\n\n# hypothesis test: is the `hp` marginal effect at the mean equal to the `drat` marginal effect\nmod &lt;- lm(mpg ~ wt + drat, data = mtcars)\n\ncomparisons(\n    mod,\n    newdata = \"mean\",\n    hypothesis = \"wt = drat\")\n\n# same hypothesis test using row indices\ncomparisons(\n    mod,\n    newdata = \"mean\",\n    hypothesis = \"b1 - b2 = 0\")\n\n# same hypothesis test using numeric vector of weights\ncomparisons(\n    mod,\n    newdata = \"mean\",\n    hypothesis = c(1, -1))\n\n# two custom contrasts using a matrix of weights\nlc &lt;- matrix(c(\n    1, -1,\n    2, 3),\n    ncol = 2)\ncomparisons(\n    mod,\n    newdata = \"mean\",\n    hypothesis = lc)\n\n# Effect of a 1 group-wise standard deviation change\n# First we calculate the SD in each group of `cyl`\n# Second, we use that SD as the treatment size in the `variables` argument\nlibrary(dplyr)\nmod &lt;- lm(mpg ~ hp + factor(cyl), mtcars)\ntmp &lt;- mtcars %&gt;%\n    group_by(cyl) %&gt;%\n    mutate(hp_sd = sd(hp))\navg_comparisons(mod, \n    variables = list(hp = function(x) data.frame(x, x + tmp$hp_sd)),\n    by = \"cyl\")\n\n# `by` argument\nmod &lt;- lm(mpg ~ hp * am * vs, data = mtcars)\ncomparisons(mod, by = TRUE)\n\nmod &lt;- lm(mpg ~ hp * am * vs, data = mtcars)\navg_comparisons(mod, variables = \"hp\", by = c(\"vs\", \"am\"))\n\nlibrary(nnet)\nmod &lt;- multinom(factor(gear) ~ mpg + am * vs, data = mtcars, trace = FALSE)\nby &lt;- data.frame(\n    group = c(\"3\", \"4\", \"5\"),\n    by = c(\"3,4\", \"3,4\", \"5\"))\ncomparisons(mod, type = \"probs\", by = by)",
    "crumbs": [
      "Model to Meaning",
      "Functions",
      "`comparisons`"
    ]
  },
  {
    "objectID": "man/comparisons.html#comparisons-between-predictions-made-with-different-regressor-values",
    "href": "man/comparisons.html#comparisons-between-predictions-made-with-different-regressor-values",
    "title": "",
    "section": "",
    "text": "Predict the outcome variable at different regressor values (e.g., college graduates vs. others), and compare those predictions by computing a difference, ratio, or some other function. comparisons() can return many quantities of interest, such as contrasts, differences, risk ratios, changes in log odds, lift, slopes, elasticities, etc.\n\n\ncomparisons(): unit-level (conditional) estimates.\n\n\navg_comparisons(): average (marginal) estimates.\n\n\nvariables identifies the focal regressors whose \"effect\" we are interested in. comparison determines how predictions with different regressor values are compared (difference, ratio, odds, etc.). The newdata argument and the datagrid() function control where statistics are evaluated in the predictor space: \"at observed values\", \"at the mean\", \"at representative values\", etc.\nSee the comparisons vignette and package website for worked examples and case studies:\n\n\nhttps://marginaleffects.com/vignettes/comparisons.html\n\n\nhttps://marginaleffects.com/\n\n\ncomparisons(\n  model,\n  newdata = NULL,\n  variables = NULL,\n  comparison = \"difference\",\n  type = NULL,\n  vcov = TRUE,\n  by = FALSE,\n  conf_level = 0.95,\n  transform = NULL,\n  cross = FALSE,\n  wts = FALSE,\n  hypothesis = NULL,\n  equivalence = NULL,\n  p_adjust = NULL,\n  df = Inf,\n  eps = NULL,\n  numderiv = \"fdforward\",\n  ...\n)\n\navg_comparisons(\n  model,\n  newdata = NULL,\n  variables = NULL,\n  type = NULL,\n  vcov = TRUE,\n  by = TRUE,\n  conf_level = 0.95,\n  comparison = \"difference\",\n  transform = NULL,\n  cross = FALSE,\n  wts = FALSE,\n  hypothesis = NULL,\n  equivalence = NULL,\n  p_adjust = NULL,\n  df = Inf,\n  eps = NULL,\n  numderiv = \"fdforward\",\n  ...\n)\n\n\n\n\n\nmodel\n\n\nModel object\n\n\n\n\nnewdata\n\n\nGrid of predictor values at which we evaluate the comparisons.\n\n\nWarning: Avoid modifying your dataset between fitting the model and calling a marginaleffects function. This can sometimes lead to unexpected results.\n\n\nNULL (default): Unit-level contrasts for each observed value in the dataset (empirical distribution). The dataset is retrieved using insight::get_data(), which tries to extract data from the environment. This may produce unexpected results if the original data frame has been altered since fitting the model.\n\n\ndata frame: Unit-level contrasts for each row of the newdata data frame.\n\n\nstring:\n\n\n\"mean\": Contrasts at the Mean. Contrasts when each predictor is held at its mean or mode.\n\n\n\"median\": Contrasts at the Median. Contrasts when each predictor is held at its median or mode.\n\n\n\"balanced\": Contrasts evaluated on a balanced grid with every combination of categories and numeric variables held at their means.\n\n\n\"tukey\": Contrasts at Tukey’s 5 numbers.\n\n\n\"grid\": Contrasts on a grid of representative numbers (Tukey’s 5 numbers and unique values of categorical predictors).\n\n\n\n\ndatagrid() call to specify a custom grid of regressors. For example:\n\n\nnewdata = datagrid(cyl = c(4, 6)): cyl variable equal to 4 and 6 and other regressors fixed at their means or modes.\n\n\nnewdata = datagrid(mpg = fivenum): mpg variable held at Tukey’s five numbers (using the fivenum function), and other regressors fixed at their means or modes.\n\n\nSee the Examples section and the datagrid documentation.\n\n\n\n\nsubset() call with a single argument to select a subset of the dataset used to fit the model, ex: newdata = subset(treatment == 1)\n\n\ndplyr::filter() call with a single argument to select a subset of the dataset used to fit the model, ex: newdata = filter(treatment == 1)\n\n\n\n\n\n\nvariables\n\n\nFocal variables\n\n\nNULL: compute comparisons for all the variables in the model object (can be slow).\n\n\nCharacter vector: subset of variables (usually faster).\n\n\nNamed list: names identify the subset of variables of interest, and values define the type of contrast to compute. Acceptable values depend on the variable type:\n\n\nFactor or character variables:\n\n\n\"reference\": Each factor level is compared to the factor reference (base) level\n\n\n\"all\": All combinations of observed levels\n\n\n\"sequential\": Each factor level is compared to the previous factor level\n\n\n\"pairwise\": Each factor level is compared to all other levels\n\n\n\"minmax\": The highest and lowest levels of a factor.\n\n\n\"revpairwise\", \"revreference\", \"revsequential\": inverse of the corresponding hypotheses.\n\n\nVector of length 2 with the two values to compare.\n\n\nData frame with the same number of rows as newdata, with two columns of \"lo\" and \"hi\" values to compare.\n\n\nFunction that accepts a vector and returns a data frame with two columns of \"lo\" and \"hi\" values to compare. See examples below.\n\n\n\n\nLogical variables:\n\n\nNULL: contrast between TRUE and FALSE\n\n\nData frame with the same number of rows as newdata, with two columns of \"lo\" and \"hi\" values to compare.\n\n\nFunction that accepts a vector and returns a data frame with two columns of \"lo\" and \"hi\" values to compare. See examples below.\n\n\n\n\nNumeric variables:\n\n\nNumeric of length 1: Forward contrast for a gap of x, computed between the observed value and the observed value plus x. Users can set a global option to get a \"center\" or \"backward\" contrast instead: options(marginaleffects_contrast_direction=“center”)\n\n\nNumeric vector of length 2: Contrast between the largest and the smallest elements of the x vector.\n\n\nData frame with the same number of rows as newdata, with two columns of \"lo\" and \"hi\" values to compare.\n\n\nFunction that accepts a vector and returns a data frame with two columns of \"lo\" and \"hi\" values to compare. See examples below.\n\n\n\"iqr\": Contrast across the interquartile range of the regressor.\n\n\n\"sd\": Contrast across one standard deviation around the regressor mean.\n\n\n\"2sd\": Contrast across two standard deviations around the regressor mean.\n\n\n\"minmax\": Contrast between the maximum and the minimum values of the regressor.\n\n\n\n\nExamples:\n\n\nvariables = list(gear = “pairwise”, hp = 10)\n\n\nvariables = list(gear = “sequential”, hp = c(100, 120))\n\n\nvariables = list(hp = (x) data.frame(low = x - 5, high = x + 10))\n\n\nSee the Examples section below for more.\n\n\n\n\n\n\n\n\n\n\ncomparison\n\n\nHow should pairs of predictions be compared? Difference, ratio, odds ratio, or user-defined functions.\n\n\nstring: shortcuts to common contrast functions.\n\n\nSupported shortcuts strings: difference, differenceavg, differenceavgwts, dydx, eyex, eydx, dyex, dydxavg, eyexavg, eydxavg, dyexavg, dydxavgwts, eyexavgwts, eydxavgwts, dyexavgwts, ratio, ratioavg, ratioavgwts, lnratio, lnratioavg, lnratioavgwts, lnor, lnoravg, lnoravgwts, lift, liftavg, liftavgwts, expdydx, expdydxavg, expdydxavgwts\n\n\nSee the Comparisons section below for definitions of each transformation.\n\n\n\n\nfunction: accept two equal-length numeric vectors of adjusted predictions (hi and lo) and returns a vector of contrasts of the same length, or a unique numeric value.\n\n\nSee the Transformations section below for examples of valid functions.\n\n\n\n\n\n\n\n\ntype\n\n\nstring indicates the type (scale) of the predictions used to compute contrasts or slopes. This can differ based on the model type, but will typically be a string such as: \"response\", \"link\", \"probs\", or \"zero\". When an unsupported string is entered, the model-specific list of acceptable values is returned in an error message. When type is NULL, the first entry in the error message is used by default.\n\n\n\n\nvcov\n\n\nType of uncertainty estimates to report (e.g., for robust standard errors). Acceptable values:\n\n\nFALSE: Do not compute standard errors. This can speed up computation considerably.\n\n\nTRUE: Unit-level standard errors using the default vcov(model) variance-covariance matrix.\n\n\nString which indicates the kind of uncertainty estimates to return.\n\n\nHeteroskedasticity-consistent: “HC”, “HC0”, “HC1”, “HC2”, “HC3”, “HC4”, “HC4m”, “HC5”. See ?sandwich::vcovHC\n\n\nHeteroskedasticity and autocorrelation consistent: “HAC”\n\n\nMixed-Models degrees of freedom: \"satterthwaite\", \"kenward-roger\"\n\n\nOther: “NeweyWest”, “KernHAC”, “OPG”. See the sandwich package documentation.\n\n\n\n\nOne-sided formula which indicates the name of cluster variables (e.g., ~unit_id). This formula is passed to the cluster argument of the sandwich::vcovCL function.\n\n\nSquare covariance matrix\n\n\nFunction which returns a covariance matrix (e.g., stats::vcov(model))\n\n\n\n\n\n\nby\n\n\nAggregate unit-level estimates (aka, marginalize, average over). Valid inputs:\n\n\nFALSE: return the original unit-level estimates.\n\n\nTRUE: aggregate estimates for each term.\n\n\nCharacter vector of column names in newdata or in the data frame produced by calling the function without the by argument.\n\n\nData frame with a by column of group labels, and merging columns shared by newdata or the data frame produced by calling the same function without the by argument.\n\n\nSee examples below.\n\n\nFor more complex aggregations, you can use the FUN argument of the hypotheses() function. See that function’s documentation and the Hypothesis Test vignettes on the marginaleffects website.\n\n\n\n\n\n\nconf_level\n\n\nnumeric value between 0 and 1. Confidence level to use to build a confidence interval.\n\n\n\n\ntransform\n\n\nstring or function. Transformation applied to unit-level estimates and confidence intervals just before the function returns results. Functions must accept a vector and return a vector of the same length. Support string shortcuts: \"exp\", \"ln\"\n\n\n\n\ncross\n\n\n\n\nFALSE: Contrasts represent the change in adjusted predictions when one predictor changes and all other variables are held constant.\n\n\nTRUE: Contrasts represent the changes in adjusted predictions when all the predictors specified in the variables argument are manipulated simultaneously (a \"cross-contrast\").\n\n\n\n\n\n\nwts\n\n\nlogical, string or numeric: weights to use when computing average predictions, contrasts or slopes. These weights only affect the averaging in avg_*() or with the by argument, and not unit-level estimates. See ?weighted.mean\n\n\nstring: column name of the weights variable in newdata. When supplying a column name to wts, it is recommended to supply the original data (including the weights variable) explicitly to newdata.\n\n\nnumeric: vector of length equal to the number of rows in the original data or in newdata (if supplied).\n\n\nFALSE: Equal weights.\n\n\nTRUE: Extract weights from the fitted object with insight::find_weights() and use them when taking weighted averages of estimates. Warning: newdata=datagrid() returns a single average weight, which is equivalent to using wts=FALSE\n\n\n\n\n\n\nhypothesis\n\n\nspecify a hypothesis test or custom contrast using a numeric value, vector, or matrix; a string equation; string; a formula, or a function.\n\n\nNumeric:\n\n\nSingle value: the null hypothesis used in the computation of Z and p (before applying transform).\n\n\nVector: Weights to compute a linear combination of (custom contrast between) estimates. Length equal to the number of rows generated by the same function call, but without the hypothesis argument.\n\n\nMatrix: Each column is a vector of weights, as describe above, used to compute a distinct linear combination of (contrast between) estimates. The column names of the matrix are used as labels in the output.\n\n\n\n\nString equation to specify linear or non-linear hypothesis tests. If the term column uniquely identifies rows, terms can be used in the formula. Otherwise, use b1, b2, etc. to identify the position of each parameter. The b* wildcard can be used to test hypotheses on all estimates. If a named vector is used, the names are used as labels in the output. Examples:\n\n\nhp = drat\n\n\nhp + drat = 12\n\n\nb1 + b2 + b3 = 0\n\n\nb* / b1 = 1\n\n\n\n\nString:\n\n\n\"pairwise\": pairwise differences between estimates in each row.\n\n\n\"reference\": differences between the estimates in each row and the estimate in the first row.\n\n\n\"sequential\": difference between an estimate and the estimate in the next row.\n\n\n\"meandev\": difference between an estimate and the mean of all estimates.\n\n\n\"meanotherdev\": difference between an estimate and the mean of all other estimates, excluding the current one.\n\n\n\"revpairwise\", \"revreference\", \"revsequential\": inverse of the corresponding hypotheses, as described above.\n\n\n\n\nFormula:\n\n\ncomparison ~ pairs | group\n\n\nLeft-hand side determines the type of comparison to conduct: difference or ratio. If the left-hand side is empty, difference is chosen.\n\n\nRight-hand side determines the pairs of estimates to compare: reference, sequential, or meandev\n\n\nOptional: Users can supply grouping variables after a vertical bar to conduct comparisons withing subsets.\n\n\nExamples:\n\n\n~ reference\n\n\nratio ~ pairwise\n\n\ndifference ~ pairwise | groupid\n\n\n\n\n\n\nFunction:\n\n\nAccepts an argument x: object produced by a marginaleffects function or a data frame with column rowid and estimate\n\n\nReturns a data frame with columns term and estimate (mandatory) and rowid (optional).\n\n\nThe function can also accept optional input arguments: newdata, by, draws.\n\n\nThis function approach will not work for Bayesian models or with bootstrapping. In those cases, it is easy to use posterior_draws() to extract and manipulate the draws directly.\n\n\n\n\nSee the Examples section below and the vignette: https://marginaleffects.com/vignettes/hypothesis.html\n\n\n\n\n\n\nequivalence\n\n\nNumeric vector of length 2: bounds used for the two-one-sided test (TOST) of equivalence, and for the non-inferiority and non-superiority tests. See Details section below.\n\n\n\n\np_adjust\n\n\nAdjust p-values for multiple comparisons: \"holm\", \"hochberg\", \"hommel\", \"bonferroni\", \"BH\", \"BY\", or \"fdr\". See stats::p.adjust\n\n\n\n\ndf\n\n\nDegrees of freedom used to compute p values and confidence intervals. A single numeric value between 1 and Inf. When df is Inf, the normal distribution is used. When df is finite, the t distribution is used. See insight::get_df for a convenient function to extract degrees of freedom. Ex: slopes(model, df = insight::get_df(model))\n\n\n\n\neps\n\n\nNULL or numeric value which determines the step size to use when calculating numerical derivatives: (f(x+eps)-f(x))/eps. When eps is NULL, the step size is 0.0001 multiplied by the difference between the maximum and minimum values of the variable with respect to which we are taking the derivative. Changing eps may be necessary to avoid numerical problems in certain models.\n\n\n\n\nnumderiv\n\n\nstring or list of strings indicating the method to use to for the numeric differentiation used in to compute delta method standard errors.\n\n\n\"fdforward\": finite difference method with forward differences\n\n\n\"fdcenter\": finite difference method with central differences (default)\n\n\n\"richardson\": Richardson extrapolation method\n\n\nExtra arguments can be specified by passing a list to the numDeriv argument, with the name of the method first and named arguments following, ex: numderiv=list(“fdcenter”, eps = 1e-5). When an unknown argument is used, marginaleffects prints the list of valid arguments for each method.\n\n\n\n\n\n\n…\n\n\nAdditional arguments are passed to the predict() method supplied by the modeling package.These arguments are particularly useful for mixed-effects or bayesian models (see the online vignettes on the marginaleffects website). Available arguments can vary from model to model, depending on the range of supported arguments by each modeling package. See the \"Model-Specific Arguments\" section of the ?slopes documentation for a non-exhaustive list of available arguments.\n\n\n\nA data.frame with one row per observation (per term/group) and several columns:\n\n\nrowid: row number of the newdata data frame\n\n\ntype: prediction type, as defined by the type argument\n\n\ngroup: (optional) value of the grouped outcome (e.g., categorical outcome models)\n\n\nterm: the variable whose marginal effect is computed\n\n\ndydx: slope of the outcome with respect to the term, for a given combination of predictor values\n\n\nstd.error: standard errors computed by via the delta method.\n\n\np.value: p value associated to the estimate column. The null is determined by the hypothesis argument (0 by default), and p values are computed before applying the transform argument.\n\n\ns.value: Shannon information transforms of p values. How many consecutive \"heads\" tosses would provide the same amount of evidence (or \"surprise\") against the null hypothesis that the coin is fair? The purpose of S is to calibrate the analyst’s intuition about the strength of evidence encoded in p against a well-known physical phenomenon. See Greenland (2019) and Cole et al. (2020).\n\n\nconf.low: lower bound of the confidence interval (or equal-tailed interval for bayesian models)\n\n\nconf.high: upper bound of the confidence interval (or equal-tailed interval for bayesian models)\n\n\nSee ?print.marginaleffects for printing options.\n\n\n\navg_comparisons(): Average comparisons\n\n\nStandard errors for all quantities estimated by marginaleffects can be obtained via the delta method. This requires differentiating a function with respect to the coefficients in the model using a finite difference approach. In some models, the delta method standard errors can be sensitive to various aspects of the numeric differentiation strategy, including the step size. By default, the step size is set to 1e-8, or to 1e-4 times the smallest absolute model coefficient, whichever is largest.\nmarginaleffects can delegate numeric differentiation to the numDeriv package, which allows more flexibility. To do this, users can pass arguments to the numDeriv::jacobian function through a global option. For example:\n\n\noptions(marginaleffects_numDeriv = list(method = “simple”, method.args = list(eps = 1e-6)))\n\n\noptions(marginaleffects_numDeriv = list(method = “Richardson”, method.args = list(eps = 1e-5)))\n\n\noptions(marginaleffects_numDeriv = NULL)\n\n\nSee the \"Standard Errors and Confidence Intervals\" vignette on the marginaleffects website for more details on the computation of standard errors:\nhttps://marginaleffects.com/vignettes/uncertainty.html\nNote that the inferences() function can be used to compute uncertainty estimates using a bootstrap or simulation-based inference. See the vignette:\nhttps://marginaleffects.com/vignettes/bootstrap.html\n\nSome model types allow model-specific arguments to modify the nature of marginal effects, predictions, marginal means, and contrasts. Please report other package-specific predict() arguments on Github so we can add them to the table below.\nhttps://github.com/vincentarelbundock/marginaleffects/issues\n\n\n\nPackage\n\n\nClass\n\n\nArgument\n\n\nDocumentation\n\n\n\n\nbrms\n\n\nbrmsfit\n\n\nndraws\n\n\nbrms::posterior_predict\n\n\n\n\n\n\n\n\nre_formula\n\n\nbrms::posterior_predict\n\n\n\n\nlme4\n\n\nmerMod\n\n\nre.form\n\n\nlme4::predict.merMod\n\n\n\n\n\n\n\n\nallow.new.levels\n\n\nlme4::predict.merMod\n\n\n\n\nglmmTMB\n\n\nglmmTMB\n\n\nre.form\n\n\nglmmTMB::predict.glmmTMB\n\n\n\n\n\n\n\n\nallow.new.levels\n\n\nglmmTMB::predict.glmmTMB\n\n\n\n\n\n\n\n\nzitype\n\n\nglmmTMB::predict.glmmTMB\n\n\n\n\nmgcv\n\n\nbam\n\n\nexclude\n\n\nmgcv::predict.bam\n\n\n\n\n\n\ngam\n\n\nexclude\n\n\nmgcv::predict.gam\n\n\n\n\nrobustlmm\n\n\nrlmerMod\n\n\nre.form\n\n\nrobustlmm::predict.rlmerMod\n\n\n\n\n\n\n\n\nallow.new.levels\n\n\nrobustlmm::predict.rlmerMod\n\n\n\n\nMCMCglmm\n\n\nMCMCglmm\n\n\nndraws\n\n\n\n\n\n\nsampleSelection\n\n\nselection\n\n\npart\n\n\nsampleSelection::predict.selection\n\n\n\n\n\n\n\nThe following transformations can be applied by supplying one of the shortcut strings to the comparison argument. hi is a vector of adjusted predictions for the \"high\" side of the contrast. lo is a vector of adjusted predictions for the \"low\" side of the contrast. y is a vector of adjusted predictions for the original data. x is the predictor in the original data. eps is the step size to use to compute derivatives and elasticities.\n\n\n\nShortcut\n\n\nFunction\n\n\n\n\ndifference\n\n\n(hi, lo) hi - lo\n\n\n\n\ndifferenceavg\n\n\n(hi, lo) mean(hi - lo)\n\n\n\n\ndydx\n\n\n(hi, lo, eps) (hi - lo)/eps\n\n\n\n\neyex\n\n\n(hi, lo, eps, y, x) (hi - lo)/eps * (x/y)\n\n\n\n\neydx\n\n\n(hi, lo, eps, y, x) ((hi - lo)/eps)/y\n\n\n\n\ndyex\n\n\n(hi, lo, eps, x) ((hi - lo)/eps) * x\n\n\n\n\ndydxavg\n\n\n(hi, lo, eps) mean((hi - lo)/eps)\n\n\n\n\neyexavg\n\n\n(hi, lo, eps, y, x) mean((hi - lo)/eps * (x/y))\n\n\n\n\neydxavg\n\n\n(hi, lo, eps, y, x) mean(((hi - lo)/eps)/y)\n\n\n\n\ndyexavg\n\n\n(hi, lo, eps, x) mean(((hi - lo)/eps) * x)\n\n\n\n\nratio\n\n\n(hi, lo) hi/lo\n\n\n\n\nratioavg\n\n\n(hi, lo) mean(hi)/mean(lo)\n\n\n\n\nlnratio\n\n\n(hi, lo) log(hi/lo)\n\n\n\n\nlnratioavg\n\n\n(hi, lo) log(mean(hi)/mean(lo))\n\n\n\n\nlnor\n\n\n(hi, lo) log((hi/(1 - hi))/(lo/(1 - lo)))\n\n\n\n\nlnoravg\n\n\n(hi, lo) log((mean(hi)/(1 - mean(hi)))/(mean(lo)/(1 - mean(lo))))\n\n\n\n\nlift\n\n\n(hi, lo) (hi - lo)/lo\n\n\n\n\nliftavg\n\n\n(hi, lo) (mean(hi - lo))/mean(lo)\n\n\n\n\nexpdydx\n\n\n(hi, lo, eps) ((exp(hi) - exp(lo))/exp(eps))/eps\n\n\n\n\nexpdydxavg\n\n\n(hi, lo, eps) mean(((exp(hi) - exp(lo))/exp(eps))/eps)\n\n\n\n\n\n\n\nBy default, credible intervals in bayesian models are built as equal-tailed intervals. This can be changed to a highest density interval by setting a global option:\noptions(“marginaleffects_posterior_interval” = “eti”)\noptions(“marginaleffects_posterior_interval” = “hdi”)\nBy default, the center of the posterior distribution in bayesian models is identified by the median. Users can use a different summary function by setting a global option:\noptions(“marginaleffects_posterior_center” = “mean”)\noptions(“marginaleffects_posterior_center” = “median”)\nWhen estimates are averaged using the by argument, the tidy() function, or the summary() function, the posterior distribution is marginalized twice over. First, we take the average across units but within each iteration of the MCMC chain, according to what the user requested in by argument or tidy()/summary() functions. Then, we identify the center of the resulting posterior using the function supplied to the “marginaleffects_posterior_center” option (the median by default).\n\n\\(\\theta\\) is an estimate, \\(\\sigma_\\theta\\) its estimated standard error, and \\([a, b]\\) are the bounds of the interval supplied to the equivalence argument.\nNon-inferiority:\n\n\n\\(H_0\\): \\(\\theta \\leq a\\)\n\n\n\\(H_1\\): \\(\\theta &gt; a\\)\n\n\n\\(t=(\\theta - a)/\\sigma_\\theta\\)\n\n\np: Upper-tail probability\n\n\nNon-superiority:\n\n\n\\(H_0\\): \\(\\theta \\geq b\\)\n\n\n\\(H_1\\): \\(\\theta &lt; b\\)\n\n\n\\(t=(\\theta - b)/\\sigma_\\theta\\)\n\n\np: Lower-tail probability\n\n\nEquivalence: Two One-Sided Tests (TOST)\n\n\np: Maximum of the non-inferiority and non-superiority p values.\n\n\nThanks to Russell V. Lenth for the excellent emmeans package and documentation which inspired this feature.\n\nThe type argument determines the scale of the predictions used to compute quantities of interest with functions from the marginaleffects package. Admissible values for type depend on the model object. When users specify an incorrect value for type, marginaleffects will raise an informative error with a list of valid type values for the specific model object. The first entry in the list in that error message is the default type.\nThe invlink(link) is a special type defined by marginaleffects. It is available for some (but not all) models, and only for the predictions() function. With this link type, we first compute predictions on the link scale, then we use the inverse link function to backtransform the predictions to the response scale. This is useful for models with non-linear link functions as it can ensure that confidence intervals stay within desirable bounds, ex: 0 to 1 for a logit model. Note that an average of estimates with type=“invlink(link)” will not always be equivalent to the average of estimates with type=“response”. This type is default when calling predictions(). It is available—but not default—when calling avg_predictions() or predictions() with the by argument.\nSome of the most common type values are:\nresponse, link, E, Ep, average, class, conditional, count, cum.prob, cumhaz, cumprob, density, detection, disp, ev, expected, expvalue, fitted, hazard, invlink(link), latent, latent_N, linear, linear.predictor, linpred, location, lp, mean, numeric, p, ppd, pr, precision, prediction, prob, probability, probs, quantile, risk, rmst, scale, survival, unconditional, utility, variance, xb, zero, zlink, zprob\n\nBehind the scenes, the arguments of marginaleffects functions are evaluated in this order:\n\n\nnewdata\n\n\nvariables\n\n\ncomparison and slopes\n\n\nby\n\n\nvcov\n\n\nhypothesis\n\n\ntransform\n\n\nThe slopes() and comparisons() functions can use parallelism to speed up computation. Operations are parallelized for the computation of standard errors, at the model coefficient level. There is always considerable overhead when using parallel computation, mainly involved in passing the whole dataset to the different processes. Thus, parallel computation is most likely to be useful when the model includes many parameters and the dataset is relatively small.\nWarning: In many cases, parallel processing will not be useful at all.\nTo activate parallel computation, users must load the future.apply package, call plan() function, and set a global option. For example:\n\nlibrary(future.apply)\nplan(\"multicore\", workers = 4)\noptions(marginaleffects_parallel = TRUE)\n\nslopes(model)\n\n\nTo disable parallelism in marginaleffects altogether, you can set a global option:\n\noptions(marginaleffects_parallel = FALSE)\n\n\n\nThe behavior of marginaleffects functions can be modified by setting global options.\nDisable some safety checks:\n\noptions(marginaleffects_safe = FALSE)\n\n\nOmit some columns from the printed output:\n\noptions(marginaleffects_print_omit = c(\"p.value\", \"s.value\"))`\n\n\n\n\n\nGreenland S. 2019. \"Valid P-Values Behave Exactly as They Should: Some Misleading Criticisms of P-Values and Their Resolution With S-Values.\" The American Statistician. 73(S1): 106–114.\n\n\nCole, Stephen R, Jessie K Edwards, and Sander Greenland. 2020. \"Surprise!\" American Journal of Epidemiology 190 (2): 191–93. https://doi.org/10.1093/aje/kwaa136\n\n\n\nlibrary(\"marginaleffects\")\n\n\n\nlibrary(marginaleffects)\n\n# Linear model\ntmp &lt;- mtcars\ntmp$am &lt;- as.logical(tmp$am)\nmod &lt;- lm(mpg ~ am + factor(cyl), tmp)\navg_comparisons(mod, variables = list(cyl = \"reference\"))\navg_comparisons(mod, variables = list(cyl = \"sequential\"))\navg_comparisons(mod, variables = list(cyl = \"pairwise\"))\n\n# GLM with different scale types\nmod &lt;- glm(am ~ factor(gear), data = mtcars)\navg_comparisons(mod, type = \"response\")\navg_comparisons(mod, type = \"link\")\n\n# Contrasts at the mean\ncomparisons(mod, newdata = \"mean\")\n\n# Contrasts between marginal means\ncomparisons(mod, newdata = \"marginalmeans\")\n\n# Contrasts at user-specified values\ncomparisons(mod, newdata = datagrid(am = 0, gear = tmp$gear))\ncomparisons(mod, newdata = datagrid(am = unique, gear = max))\n\nm &lt;- lm(mpg ~ hp + drat + factor(cyl) + factor(am), data = mtcars)\ncomparisons(m, variables = \"hp\", newdata = datagrid(FUN_factor = unique, FUN_numeric = median))\n\n# Numeric contrasts\nmod &lt;- lm(mpg ~ hp, data = mtcars)\navg_comparisons(mod, variables = list(hp = 1))\navg_comparisons(mod, variables = list(hp = 5))\navg_comparisons(mod, variables = list(hp = c(90, 100)))\navg_comparisons(mod, variables = list(hp = \"iqr\"))\navg_comparisons(mod, variables = list(hp = \"sd\"))\navg_comparisons(mod, variables = list(hp = \"minmax\"))\n\n# using a function to specify a custom difference in one regressor\ndat &lt;- mtcars\ndat$new_hp &lt;- 49 * (dat$hp - min(dat$hp)) / (max(dat$hp) - min(dat$hp)) + 1\nmodlog &lt;- lm(mpg ~ log(new_hp) + factor(cyl), data = dat)\nfdiff &lt;- \\(x) data.frame(x, x + 10)\navg_comparisons(modlog, variables = list(new_hp = fdiff))\n\n# Adjusted Risk Ratio: see the contrasts vignette\nmod &lt;- glm(vs ~ mpg, data = mtcars, family = binomial)\navg_comparisons(mod, comparison = \"lnratioavg\", transform = exp)\n\n# Adjusted Risk Ratio: Manual specification of the `comparison`\navg_comparisons(\n     mod,\n     comparison = function(hi, lo) log(mean(hi) / mean(lo)),\n     transform = exp)\n# cross contrasts\nmod &lt;- lm(mpg ~ factor(cyl) * factor(gear) + hp, data = mtcars)\navg_comparisons(mod, variables = c(\"cyl\", \"gear\"), cross = TRUE)\n\n# variable-specific contrasts\navg_comparisons(mod, variables = list(gear = \"sequential\", hp = 10))\n\n# hypothesis test: is the `hp` marginal effect at the mean equal to the `drat` marginal effect\nmod &lt;- lm(mpg ~ wt + drat, data = mtcars)\n\ncomparisons(\n    mod,\n    newdata = \"mean\",\n    hypothesis = \"wt = drat\")\n\n# same hypothesis test using row indices\ncomparisons(\n    mod,\n    newdata = \"mean\",\n    hypothesis = \"b1 - b2 = 0\")\n\n# same hypothesis test using numeric vector of weights\ncomparisons(\n    mod,\n    newdata = \"mean\",\n    hypothesis = c(1, -1))\n\n# two custom contrasts using a matrix of weights\nlc &lt;- matrix(c(\n    1, -1,\n    2, 3),\n    ncol = 2)\ncomparisons(\n    mod,\n    newdata = \"mean\",\n    hypothesis = lc)\n\n# Effect of a 1 group-wise standard deviation change\n# First we calculate the SD in each group of `cyl`\n# Second, we use that SD as the treatment size in the `variables` argument\nlibrary(dplyr)\nmod &lt;- lm(mpg ~ hp + factor(cyl), mtcars)\ntmp &lt;- mtcars %&gt;%\n    group_by(cyl) %&gt;%\n    mutate(hp_sd = sd(hp))\navg_comparisons(mod, \n    variables = list(hp = function(x) data.frame(x, x + tmp$hp_sd)),\n    by = \"cyl\")\n\n# `by` argument\nmod &lt;- lm(mpg ~ hp * am * vs, data = mtcars)\ncomparisons(mod, by = TRUE)\n\nmod &lt;- lm(mpg ~ hp * am * vs, data = mtcars)\navg_comparisons(mod, variables = \"hp\", by = c(\"vs\", \"am\"))\n\nlibrary(nnet)\nmod &lt;- multinom(factor(gear) ~ mpg + am * vs, data = mtcars, trace = FALSE)\nby &lt;- data.frame(\n    group = c(\"3\", \"4\", \"5\"),\n    by = c(\"3,4\", \"3,4\", \"5\"))\ncomparisons(mod, type = \"probs\", by = by)",
    "crumbs": [
      "Model to Meaning",
      "Functions",
      "`comparisons`"
    ]
  },
  {
    "objectID": "man/print.marginaleffects.html",
    "href": "man/print.marginaleffects.html",
    "title": "",
    "section": "",
    "text": "This function controls the text which is printed to the console when one of the core marginalefffects functions is called and the object is returned: predictions(), comparisons(), slopes(), hypotheses(), avg_predictions(), avg_comparisons(), avg_slopes().\nAll of those functions return standard data frames. Columns can be extracted by name, predictions(model)$estimate, and all the usual data manipulation functions work out-of-the-box: colnames(), head(), subset(), dplyr::filter(), dplyr::arrange(), etc.\nSome of the data columns are not printed by default. You can disable pretty printing and print the full results as a standard data frame using the style argument or by applying as.data.frame() on the object. See examples below.\n\n## S3 method for class 'marginaleffects'\nprint(\n  x,\n  style = getOption(\"marginaleffects_print_style\", default = \"summary\"),\n  digits = getOption(\"marginaleffects_print_digits\", default = 3),\n  p_eps = getOption(\"marginaleffects_print_p_eps\", default = 0.001),\n  topn = getOption(\"marginaleffects_print_topn\", default = 5),\n  nrows = getOption(\"marginaleffects_print_nrows\", default = 30),\n  ncols = getOption(\"marginaleffects_print_ncols\", default = 30),\n  type = getOption(\"marginaleffects_print_type\", default = TRUE),\n  column_names = getOption(\"marginaleffects_print_column_names\", default = TRUE),\n  ...\n)\n\n\n\n\n\nx\n\n\nAn object produced by one of the marginaleffects package functions.\n\n\n\n\nstyle\n\n\n\"summary\", \"data.frame\", or \"tinytable\"\n\n\n\n\ndigits\n\n\nThe number of digits to display.\n\n\n\n\np_eps\n\n\np values smaller than this number are printed in \"&lt;0.001\" style.\n\n\n\n\ntopn\n\n\nThe number of rows to be printed from the beginning and end of tables with more than nrows rows.\n\n\n\n\nnrows\n\n\nThe number of rows which will be printed before truncation.\n\n\n\n\nncols\n\n\nThe maximum number of column names to display at the bottom of the printed output.\n\n\n\n\ntype\n\n\nboolean: should the type be printed?\n\n\n\n\ncolumn_names\n\n\nboolean: should the column names be printed?\n\n\n\n\n…\n\n\nOther arguments are currently ignored.\n\n\n\n\nlibrary(\"marginaleffects\")\n\nlibrary(marginaleffects)\nmod &lt;- lm(mpg ~ hp + am + factor(gear), data = mtcars)\np &lt;- predictions(mod, by = c(\"am\", \"gear\"))\np\n\n\n am gear Estimate Std. Error    z Pr(&gt;|z|)     S 2.5 % 97.5 %\n  1    4     26.3      1.039 25.3   &lt;0.001 466.1  24.2   28.3\n  0    3     16.1      0.759 21.2   &lt;0.001 329.6  14.6   17.6\n  0    4     21.0      1.470 14.3   &lt;0.001 152.1  18.2   23.9\n  1    5     21.4      1.315 16.3   &lt;0.001 195.2  18.8   24.0\n\nType:  response \nColumns: am, gear, estimate, std.error, statistic, p.value, s.value, conf.low, conf.high \n\nsubset(p, am == 1)\n\n\n Estimate Std. Error    z Pr(&gt;|z|)     S CI low CI high\n     26.3       1.04 25.3   &lt;0.001 466.1   24.2    28.3\n     21.4       1.31 16.3   &lt;0.001 195.2   18.8    24.0\n\nColumns: am, gear, estimate, std.error, statistic, p.value, s.value, conf.low, conf.high \n\nprint(p, style = \"data.frame\")\n\n  am gear estimate std.error statistic       p.value  s.value conf.low\n1  1    4 26.27500 1.0392746  25.28206 5.032257e-141 466.0607 24.23806\n2  0    3 16.10667 0.7589789  21.22150 6.047015e-100 329.5966 14.61910\n3  0    4 21.05000 1.4697592  14.32207  1.592966e-46 152.1370 18.16932\n4  1    5 21.38000 1.3145900  16.26363  1.788354e-59 195.1551 18.80345\n  conf.high\n1  28.31194\n2  17.59424\n3  23.93068\n4  23.95655\n\ndata.frame(p)\n\n  am gear estimate std.error statistic       p.value  s.value conf.low\n1  1    4 26.27500 1.0392746  25.28206 5.032257e-141 466.0607 24.23806\n2  0    3 16.10667 0.7589789  21.22150 6.047015e-100 329.5966 14.61910\n3  0    4 21.05000 1.4697592  14.32207  1.592966e-46 152.1370 18.16932\n4  1    5 21.38000 1.3145900  16.26363  1.788354e-59 195.1551 18.80345\n  conf.high\n1  28.31194\n2  17.59424\n3  23.93068\n4  23.95655",
    "crumbs": [
      "Model to Meaning",
      "Functions",
      "`print.marginaleffects`"
    ]
  },
  {
    "objectID": "man/print.marginaleffects.html#print-marginaleffects-objects",
    "href": "man/print.marginaleffects.html#print-marginaleffects-objects",
    "title": "",
    "section": "",
    "text": "This function controls the text which is printed to the console when one of the core marginalefffects functions is called and the object is returned: predictions(), comparisons(), slopes(), hypotheses(), avg_predictions(), avg_comparisons(), avg_slopes().\nAll of those functions return standard data frames. Columns can be extracted by name, predictions(model)$estimate, and all the usual data manipulation functions work out-of-the-box: colnames(), head(), subset(), dplyr::filter(), dplyr::arrange(), etc.\nSome of the data columns are not printed by default. You can disable pretty printing and print the full results as a standard data frame using the style argument or by applying as.data.frame() on the object. See examples below.\n\n## S3 method for class 'marginaleffects'\nprint(\n  x,\n  style = getOption(\"marginaleffects_print_style\", default = \"summary\"),\n  digits = getOption(\"marginaleffects_print_digits\", default = 3),\n  p_eps = getOption(\"marginaleffects_print_p_eps\", default = 0.001),\n  topn = getOption(\"marginaleffects_print_topn\", default = 5),\n  nrows = getOption(\"marginaleffects_print_nrows\", default = 30),\n  ncols = getOption(\"marginaleffects_print_ncols\", default = 30),\n  type = getOption(\"marginaleffects_print_type\", default = TRUE),\n  column_names = getOption(\"marginaleffects_print_column_names\", default = TRUE),\n  ...\n)\n\n\n\n\n\nx\n\n\nAn object produced by one of the marginaleffects package functions.\n\n\n\n\nstyle\n\n\n\"summary\", \"data.frame\", or \"tinytable\"\n\n\n\n\ndigits\n\n\nThe number of digits to display.\n\n\n\n\np_eps\n\n\np values smaller than this number are printed in \"&lt;0.001\" style.\n\n\n\n\ntopn\n\n\nThe number of rows to be printed from the beginning and end of tables with more than nrows rows.\n\n\n\n\nnrows\n\n\nThe number of rows which will be printed before truncation.\n\n\n\n\nncols\n\n\nThe maximum number of column names to display at the bottom of the printed output.\n\n\n\n\ntype\n\n\nboolean: should the type be printed?\n\n\n\n\ncolumn_names\n\n\nboolean: should the column names be printed?\n\n\n\n\n…\n\n\nOther arguments are currently ignored.\n\n\n\n\nlibrary(\"marginaleffects\")\n\nlibrary(marginaleffects)\nmod &lt;- lm(mpg ~ hp + am + factor(gear), data = mtcars)\np &lt;- predictions(mod, by = c(\"am\", \"gear\"))\np\n\n\n am gear Estimate Std. Error    z Pr(&gt;|z|)     S 2.5 % 97.5 %\n  1    4     26.3      1.039 25.3   &lt;0.001 466.1  24.2   28.3\n  0    3     16.1      0.759 21.2   &lt;0.001 329.6  14.6   17.6\n  0    4     21.0      1.470 14.3   &lt;0.001 152.1  18.2   23.9\n  1    5     21.4      1.315 16.3   &lt;0.001 195.2  18.8   24.0\n\nType:  response \nColumns: am, gear, estimate, std.error, statistic, p.value, s.value, conf.low, conf.high \n\nsubset(p, am == 1)\n\n\n Estimate Std. Error    z Pr(&gt;|z|)     S CI low CI high\n     26.3       1.04 25.3   &lt;0.001 466.1   24.2    28.3\n     21.4       1.31 16.3   &lt;0.001 195.2   18.8    24.0\n\nColumns: am, gear, estimate, std.error, statistic, p.value, s.value, conf.low, conf.high \n\nprint(p, style = \"data.frame\")\n\n  am gear estimate std.error statistic       p.value  s.value conf.low\n1  1    4 26.27500 1.0392746  25.28206 5.032257e-141 466.0607 24.23806\n2  0    3 16.10667 0.7589789  21.22150 6.047015e-100 329.5966 14.61910\n3  0    4 21.05000 1.4697592  14.32207  1.592966e-46 152.1370 18.16932\n4  1    5 21.38000 1.3145900  16.26363  1.788354e-59 195.1551 18.80345\n  conf.high\n1  28.31194\n2  17.59424\n3  23.93068\n4  23.95655\n\ndata.frame(p)\n\n  am gear estimate std.error statistic       p.value  s.value conf.low\n1  1    4 26.27500 1.0392746  25.28206 5.032257e-141 466.0607 24.23806\n2  0    3 16.10667 0.7589789  21.22150 6.047015e-100 329.5966 14.61910\n3  0    4 21.05000 1.4697592  14.32207  1.592966e-46 152.1370 18.16932\n4  1    5 21.38000 1.3145900  16.26363  1.788354e-59 195.1551 18.80345\n  conf.high\n1  28.31194\n2  17.59424\n3  23.93068\n4  23.95655",
    "crumbs": [
      "Model to Meaning",
      "Functions",
      "`print.marginaleffects`"
    ]
  },
  {
    "objectID": "man/plot_slopes.html",
    "href": "man/plot_slopes.html",
    "title": "",
    "section": "",
    "text": "Plot slopes on the y-axis against values of one or more predictors (x-axis, colors/shapes, and facets).\nThe by argument is used to plot marginal slopes, that is, slopes made on the original data, but averaged by subgroups. This is analogous to using the by argument in the slopes() function.\nThe condition argument is used to plot conditional slopes, that is, slopes computed on a user-specified grid. This is analogous to using the newdata argument and datagrid() function in a slopes() call. All variables whose values are not specified explicitly are treated as usual by datagrid(), that is, they are held at their mean or mode (or rounded mean for integers). This includes grouping variables in mixed-effects models, so analysts who fit such models may want to specify the groups of interest using the condition argument, or supply model-specific arguments to compute population-level estimates. See details below. See the \"Plots\" vignette and website for tutorials and information on how to customize plots:\n\n\nhttps://marginaleffects.com/vignettes/plot.html\n\n\nhttps://marginaleffects.com\n\n\nplot_slopes(\n  model,\n  variables = NULL,\n  condition = NULL,\n  by = NULL,\n  newdata = NULL,\n  type = NULL,\n  vcov = NULL,\n  conf_level = 0.95,\n  wts = FALSE,\n  slope = \"dydx\",\n  rug = FALSE,\n  gray = FALSE,\n  draw = TRUE,\n  ...\n)\n\n\n\n\n\nmodel\n\n\nModel object\n\n\n\n\nvariables\n\n\nName of the variable whose marginal effect (slope) we want to plot on the y-axis.\n\n\n\n\ncondition\n\n\nConditional slopes\n\n\nCharacter vector (max length 4): Names of the predictors to display.\n\n\nNamed list (max length 4): List names correspond to predictors. List elements can be:\n\n\nNumeric vector\n\n\nFunction which returns a numeric vector or a set of unique categorical values\n\n\nShortcut strings for common reference values: \"minmax\", \"quartile\", \"threenum\"\n\n\n\n\n1: x-axis. 2: color/shape. 3: facet (wrap if no fourth variable, otherwise cols of grid). 4: facet (rows of grid).\n\n\nNumeric variables in positions 2 and 3 are summarized by Tukey’s five numbers ?stats::fivenum.\n\n\n\n\n\n\nby\n\n\nAggregate unit-level estimates (aka, marginalize, average over). Valid inputs:\n\n\nFALSE: return the original unit-level estimates.\n\n\nTRUE: aggregate estimates for each term.\n\n\nCharacter vector of column names in newdata or in the data frame produced by calling the function without the by argument.\n\n\nData frame with a by column of group labels, and merging columns shared by newdata or the data frame produced by calling the same function without the by argument.\n\n\nSee examples below.\n\n\nFor more complex aggregations, you can use the FUN argument of the hypotheses() function. See that function’s documentation and the Hypothesis Test vignettes on the marginaleffects website.\n\n\n\n\n\n\nnewdata\n\n\nWhen newdata is NULL, the grid is determined by the condition argument. When newdata is not NULL, the argument behaves in the same way as in the slopes() function.\n\n\n\n\ntype\n\n\nstring indicates the type (scale) of the predictions used to compute contrasts or slopes. This can differ based on the model type, but will typically be a string such as: \"response\", \"link\", \"probs\", or \"zero\". When an unsupported string is entered, the model-specific list of acceptable values is returned in an error message. When type is NULL, the first entry in the error message is used by default.\n\n\n\n\nvcov\n\n\nType of uncertainty estimates to report (e.g., for robust standard errors). Acceptable values:\n\n\nFALSE: Do not compute standard errors. This can speed up computation considerably.\n\n\nTRUE: Unit-level standard errors using the default vcov(model) variance-covariance matrix.\n\n\nString which indicates the kind of uncertainty estimates to return.\n\n\nHeteroskedasticity-consistent: “HC”, “HC0”, “HC1”, “HC2”, “HC3”, “HC4”, “HC4m”, “HC5”. See ?sandwich::vcovHC\n\n\nHeteroskedasticity and autocorrelation consistent: “HAC”\n\n\nMixed-Models degrees of freedom: \"satterthwaite\", \"kenward-roger\"\n\n\nOther: “NeweyWest”, “KernHAC”, “OPG”. See the sandwich package documentation.\n\n\n\n\nOne-sided formula which indicates the name of cluster variables (e.g., ~unit_id). This formula is passed to the cluster argument of the sandwich::vcovCL function.\n\n\nSquare covariance matrix\n\n\nFunction which returns a covariance matrix (e.g., stats::vcov(model))\n\n\n\n\n\n\nconf_level\n\n\nnumeric value between 0 and 1. Confidence level to use to build a confidence interval.\n\n\n\n\nwts\n\n\nlogical, string or numeric: weights to use when computing average predictions, contrasts or slopes. These weights only affect the averaging in avg_*() or with the by argument, and not unit-level estimates. See ?weighted.mean\n\n\nstring: column name of the weights variable in newdata. When supplying a column name to wts, it is recommended to supply the original data (including the weights variable) explicitly to newdata.\n\n\nnumeric: vector of length equal to the number of rows in the original data or in newdata (if supplied).\n\n\nFALSE: Equal weights.\n\n\nTRUE: Extract weights from the fitted object with insight::find_weights() and use them when taking weighted averages of estimates. Warning: newdata=datagrid() returns a single average weight, which is equivalent to using wts=FALSE\n\n\n\n\n\n\nslope\n\n\nstring indicates the type of slope or (semi-)elasticity to compute:\n\n\n\"dydx\": dY/dX\n\n\n\"eyex\": dY/dX * Y / X\n\n\n\"eydx\": dY/dX * Y\n\n\n\"dyex\": dY/dX / X\n\n\nY is the predicted value of the outcome; X is the observed value of the predictor.\n\n\n\n\n\n\nrug\n\n\nTRUE displays tick marks on the axes to mark the distribution of raw data.\n\n\n\n\ngray\n\n\nFALSE grayscale or color plot\n\n\n\n\ndraw\n\n\nTRUE returns a ggplot2 plot. FALSE returns a data.frame of the underlying data.\n\n\n\n\n…\n\n\nAdditional arguments are passed to the predict() method supplied by the modeling package.These arguments are particularly useful for mixed-effects or bayesian models (see the online vignettes on the marginaleffects website). Available arguments can vary from model to model, depending on the range of supported arguments by each modeling package. See the \"Model-Specific Arguments\" section of the ?slopes documentation for a non-exhaustive list of available arguments.\n\n\n\nA ggplot2 object\n\nSome model types allow model-specific arguments to modify the nature of marginal effects, predictions, marginal means, and contrasts. Please report other package-specific predict() arguments on Github so we can add them to the table below.\nhttps://github.com/vincentarelbundock/marginaleffects/issues\n\n\n\nPackage\n\n\nClass\n\n\nArgument\n\n\nDocumentation\n\n\n\n\nbrms\n\n\nbrmsfit\n\n\nndraws\n\n\nbrms::posterior_predict\n\n\n\n\n\n\n\n\nre_formula\n\n\nbrms::posterior_predict\n\n\n\n\nlme4\n\n\nmerMod\n\n\nre.form\n\n\nlme4::predict.merMod\n\n\n\n\n\n\n\n\nallow.new.levels\n\n\nlme4::predict.merMod\n\n\n\n\nglmmTMB\n\n\nglmmTMB\n\n\nre.form\n\n\nglmmTMB::predict.glmmTMB\n\n\n\n\n\n\n\n\nallow.new.levels\n\n\nglmmTMB::predict.glmmTMB\n\n\n\n\n\n\n\n\nzitype\n\n\nglmmTMB::predict.glmmTMB\n\n\n\n\nmgcv\n\n\nbam\n\n\nexclude\n\n\nmgcv::predict.bam\n\n\n\n\n\n\ngam\n\n\nexclude\n\n\nmgcv::predict.gam\n\n\n\n\nrobustlmm\n\n\nrlmerMod\n\n\nre.form\n\n\nrobustlmm::predict.rlmerMod\n\n\n\n\n\n\n\n\nallow.new.levels\n\n\nrobustlmm::predict.rlmerMod\n\n\n\n\nMCMCglmm\n\n\nMCMCglmm\n\n\nndraws\n\n\n\n\n\n\nsampleSelection\n\n\nselection\n\n\npart\n\n\nsampleSelection::predict.selection\n\n\n\n\n\n\n\n\nlibrary(\"marginaleffects\")\n\nlibrary(marginaleffects)\nmod &lt;- lm(mpg ~ hp * drat * factor(am), data = mtcars)\n\nplot_slopes(mod, variables = \"hp\", condition = \"drat\")\n\n\n\n\n\n\nplot_slopes(mod, variables = \"hp\", condition = c(\"drat\", \"am\"))\n\n\n\n\n\n\nplot_slopes(mod, variables = \"hp\", condition = list(\"am\", \"drat\" = 3:5))\n\n\n\n\n\n\nplot_slopes(mod, variables = \"am\", condition = list(\"hp\", \"drat\" = range))\n\n\n\n\n\n\nplot_slopes(mod, variables = \"am\", condition = list(\"hp\", \"drat\" = \"threenum\"))",
    "crumbs": [
      "Model to Meaning",
      "Functions",
      "`plot_slopes`"
    ]
  },
  {
    "objectID": "man/plot_slopes.html#plot-conditional-or-marginal-slopes",
    "href": "man/plot_slopes.html#plot-conditional-or-marginal-slopes",
    "title": "",
    "section": "",
    "text": "Plot slopes on the y-axis against values of one or more predictors (x-axis, colors/shapes, and facets).\nThe by argument is used to plot marginal slopes, that is, slopes made on the original data, but averaged by subgroups. This is analogous to using the by argument in the slopes() function.\nThe condition argument is used to plot conditional slopes, that is, slopes computed on a user-specified grid. This is analogous to using the newdata argument and datagrid() function in a slopes() call. All variables whose values are not specified explicitly are treated as usual by datagrid(), that is, they are held at their mean or mode (or rounded mean for integers). This includes grouping variables in mixed-effects models, so analysts who fit such models may want to specify the groups of interest using the condition argument, or supply model-specific arguments to compute population-level estimates. See details below. See the \"Plots\" vignette and website for tutorials and information on how to customize plots:\n\n\nhttps://marginaleffects.com/vignettes/plot.html\n\n\nhttps://marginaleffects.com\n\n\nplot_slopes(\n  model,\n  variables = NULL,\n  condition = NULL,\n  by = NULL,\n  newdata = NULL,\n  type = NULL,\n  vcov = NULL,\n  conf_level = 0.95,\n  wts = FALSE,\n  slope = \"dydx\",\n  rug = FALSE,\n  gray = FALSE,\n  draw = TRUE,\n  ...\n)\n\n\n\n\n\nmodel\n\n\nModel object\n\n\n\n\nvariables\n\n\nName of the variable whose marginal effect (slope) we want to plot on the y-axis.\n\n\n\n\ncondition\n\n\nConditional slopes\n\n\nCharacter vector (max length 4): Names of the predictors to display.\n\n\nNamed list (max length 4): List names correspond to predictors. List elements can be:\n\n\nNumeric vector\n\n\nFunction which returns a numeric vector or a set of unique categorical values\n\n\nShortcut strings for common reference values: \"minmax\", \"quartile\", \"threenum\"\n\n\n\n\n1: x-axis. 2: color/shape. 3: facet (wrap if no fourth variable, otherwise cols of grid). 4: facet (rows of grid).\n\n\nNumeric variables in positions 2 and 3 are summarized by Tukey’s five numbers ?stats::fivenum.\n\n\n\n\n\n\nby\n\n\nAggregate unit-level estimates (aka, marginalize, average over). Valid inputs:\n\n\nFALSE: return the original unit-level estimates.\n\n\nTRUE: aggregate estimates for each term.\n\n\nCharacter vector of column names in newdata or in the data frame produced by calling the function without the by argument.\n\n\nData frame with a by column of group labels, and merging columns shared by newdata or the data frame produced by calling the same function without the by argument.\n\n\nSee examples below.\n\n\nFor more complex aggregations, you can use the FUN argument of the hypotheses() function. See that function’s documentation and the Hypothesis Test vignettes on the marginaleffects website.\n\n\n\n\n\n\nnewdata\n\n\nWhen newdata is NULL, the grid is determined by the condition argument. When newdata is not NULL, the argument behaves in the same way as in the slopes() function.\n\n\n\n\ntype\n\n\nstring indicates the type (scale) of the predictions used to compute contrasts or slopes. This can differ based on the model type, but will typically be a string such as: \"response\", \"link\", \"probs\", or \"zero\". When an unsupported string is entered, the model-specific list of acceptable values is returned in an error message. When type is NULL, the first entry in the error message is used by default.\n\n\n\n\nvcov\n\n\nType of uncertainty estimates to report (e.g., for robust standard errors). Acceptable values:\n\n\nFALSE: Do not compute standard errors. This can speed up computation considerably.\n\n\nTRUE: Unit-level standard errors using the default vcov(model) variance-covariance matrix.\n\n\nString which indicates the kind of uncertainty estimates to return.\n\n\nHeteroskedasticity-consistent: “HC”, “HC0”, “HC1”, “HC2”, “HC3”, “HC4”, “HC4m”, “HC5”. See ?sandwich::vcovHC\n\n\nHeteroskedasticity and autocorrelation consistent: “HAC”\n\n\nMixed-Models degrees of freedom: \"satterthwaite\", \"kenward-roger\"\n\n\nOther: “NeweyWest”, “KernHAC”, “OPG”. See the sandwich package documentation.\n\n\n\n\nOne-sided formula which indicates the name of cluster variables (e.g., ~unit_id). This formula is passed to the cluster argument of the sandwich::vcovCL function.\n\n\nSquare covariance matrix\n\n\nFunction which returns a covariance matrix (e.g., stats::vcov(model))\n\n\n\n\n\n\nconf_level\n\n\nnumeric value between 0 and 1. Confidence level to use to build a confidence interval.\n\n\n\n\nwts\n\n\nlogical, string or numeric: weights to use when computing average predictions, contrasts or slopes. These weights only affect the averaging in avg_*() or with the by argument, and not unit-level estimates. See ?weighted.mean\n\n\nstring: column name of the weights variable in newdata. When supplying a column name to wts, it is recommended to supply the original data (including the weights variable) explicitly to newdata.\n\n\nnumeric: vector of length equal to the number of rows in the original data or in newdata (if supplied).\n\n\nFALSE: Equal weights.\n\n\nTRUE: Extract weights from the fitted object with insight::find_weights() and use them when taking weighted averages of estimates. Warning: newdata=datagrid() returns a single average weight, which is equivalent to using wts=FALSE\n\n\n\n\n\n\nslope\n\n\nstring indicates the type of slope or (semi-)elasticity to compute:\n\n\n\"dydx\": dY/dX\n\n\n\"eyex\": dY/dX * Y / X\n\n\n\"eydx\": dY/dX * Y\n\n\n\"dyex\": dY/dX / X\n\n\nY is the predicted value of the outcome; X is the observed value of the predictor.\n\n\n\n\n\n\nrug\n\n\nTRUE displays tick marks on the axes to mark the distribution of raw data.\n\n\n\n\ngray\n\n\nFALSE grayscale or color plot\n\n\n\n\ndraw\n\n\nTRUE returns a ggplot2 plot. FALSE returns a data.frame of the underlying data.\n\n\n\n\n…\n\n\nAdditional arguments are passed to the predict() method supplied by the modeling package.These arguments are particularly useful for mixed-effects or bayesian models (see the online vignettes on the marginaleffects website). Available arguments can vary from model to model, depending on the range of supported arguments by each modeling package. See the \"Model-Specific Arguments\" section of the ?slopes documentation for a non-exhaustive list of available arguments.\n\n\n\nA ggplot2 object\n\nSome model types allow model-specific arguments to modify the nature of marginal effects, predictions, marginal means, and contrasts. Please report other package-specific predict() arguments on Github so we can add them to the table below.\nhttps://github.com/vincentarelbundock/marginaleffects/issues\n\n\n\nPackage\n\n\nClass\n\n\nArgument\n\n\nDocumentation\n\n\n\n\nbrms\n\n\nbrmsfit\n\n\nndraws\n\n\nbrms::posterior_predict\n\n\n\n\n\n\n\n\nre_formula\n\n\nbrms::posterior_predict\n\n\n\n\nlme4\n\n\nmerMod\n\n\nre.form\n\n\nlme4::predict.merMod\n\n\n\n\n\n\n\n\nallow.new.levels\n\n\nlme4::predict.merMod\n\n\n\n\nglmmTMB\n\n\nglmmTMB\n\n\nre.form\n\n\nglmmTMB::predict.glmmTMB\n\n\n\n\n\n\n\n\nallow.new.levels\n\n\nglmmTMB::predict.glmmTMB\n\n\n\n\n\n\n\n\nzitype\n\n\nglmmTMB::predict.glmmTMB\n\n\n\n\nmgcv\n\n\nbam\n\n\nexclude\n\n\nmgcv::predict.bam\n\n\n\n\n\n\ngam\n\n\nexclude\n\n\nmgcv::predict.gam\n\n\n\n\nrobustlmm\n\n\nrlmerMod\n\n\nre.form\n\n\nrobustlmm::predict.rlmerMod\n\n\n\n\n\n\n\n\nallow.new.levels\n\n\nrobustlmm::predict.rlmerMod\n\n\n\n\nMCMCglmm\n\n\nMCMCglmm\n\n\nndraws\n\n\n\n\n\n\nsampleSelection\n\n\nselection\n\n\npart\n\n\nsampleSelection::predict.selection\n\n\n\n\n\n\n\n\nlibrary(\"marginaleffects\")\n\nlibrary(marginaleffects)\nmod &lt;- lm(mpg ~ hp * drat * factor(am), data = mtcars)\n\nplot_slopes(mod, variables = \"hp\", condition = \"drat\")\n\n\n\n\n\n\nplot_slopes(mod, variables = \"hp\", condition = c(\"drat\", \"am\"))\n\n\n\n\n\n\nplot_slopes(mod, variables = \"hp\", condition = list(\"am\", \"drat\" = 3:5))\n\n\n\n\n\n\nplot_slopes(mod, variables = \"am\", condition = list(\"hp\", \"drat\" = range))\n\n\n\n\n\n\nplot_slopes(mod, variables = \"am\", condition = list(\"hp\", \"drat\" = \"threenum\"))",
    "crumbs": [
      "Model to Meaning",
      "Functions",
      "`plot_slopes`"
    ]
  },
  {
    "objectID": "man/plot_predictions.html",
    "href": "man/plot_predictions.html",
    "title": "",
    "section": "",
    "text": "Plot predictions on the y-axis against values of one or more predictors (x-axis, colors/shapes, and facets).\nThe by argument is used to plot marginal predictions, that is, predictions made on the original data, but averaged by subgroups. This is analogous to using the by argument in the predictions() function.\nThe condition argument is used to plot conditional predictions, that is, predictions made on a user-specified grid. This is analogous to using the newdata argument and datagrid() function in a predictions() call. All variables whose values are not specified explicitly are treated as usual by datagrid(), that is, they are held at their mean or mode (or rounded mean for integers). This includes grouping variables in mixed-effects models, so analysts who fit such models may want to specify the groups of interest using the condition argument, or supply model-specific arguments to compute population-level estimates. See details below.\nSee the \"Plots\" vignette and website for tutorials and information on how to customize plots:\n\n\nhttps://marginaleffects.com/vignettes/plot.html\n\n\nhttps://marginaleffects.com\n\n\nplot_predictions(\n  model,\n  condition = NULL,\n  by = NULL,\n  newdata = NULL,\n  type = NULL,\n  vcov = NULL,\n  conf_level = 0.95,\n  wts = FALSE,\n  transform = NULL,\n  points = 0,\n  rug = FALSE,\n  gray = FALSE,\n  draw = TRUE,\n  ...\n)\n\n\n\n\n\nmodel\n\n\nModel object\n\n\n\n\ncondition\n\n\nConditional predictions\n\n\nCharacter vector (max length 4): Names of the predictors to display.\n\n\nNamed list (max length 4): List names correspond to predictors. List elements can be:\n\n\nNumeric vector\n\n\nFunction which returns a numeric vector or a set of unique categorical values\n\n\nShortcut strings for common reference values: \"minmax\", \"quartile\", \"threenum\"\n\n\n\n\n1: x-axis. 2: color/shape. 3: facet (wrap if no fourth variable, otherwise cols of grid). 4: facet (rows of grid).\n\n\nNumeric variables in positions 2 and 3 are summarized by Tukey’s five numbers ?stats::fivenum\n\n\n\n\n\n\nby\n\n\nMarginal predictions\n\n\nCharacter vector (max length 3): Names of the categorical predictors to marginalize across.\n\n\n1: x-axis. 2: color. 3: facets.\n\n\n\n\n\n\nnewdata\n\n\nWhen newdata is NULL, the grid is determined by the condition argument. When newdata is not NULL, the argument behaves in the same way as in the predictions() function.\n\n\n\n\ntype\n\n\nstring indicates the type (scale) of the predictions used to compute contrasts or slopes. This can differ based on the model type, but will typically be a string such as: \"response\", \"link\", \"probs\", or \"zero\". When an unsupported string is entered, the model-specific list of acceptable values is returned in an error message. When type is NULL, the first entry in the error message is used by default.\n\n\n\n\nvcov\n\n\nType of uncertainty estimates to report (e.g., for robust standard errors). Acceptable values:\n\n\nFALSE: Do not compute standard errors. This can speed up computation considerably.\n\n\nTRUE: Unit-level standard errors using the default vcov(model) variance-covariance matrix.\n\n\nString which indicates the kind of uncertainty estimates to return.\n\n\nHeteroskedasticity-consistent: “HC”, “HC0”, “HC1”, “HC2”, “HC3”, “HC4”, “HC4m”, “HC5”. See ?sandwich::vcovHC\n\n\nHeteroskedasticity and autocorrelation consistent: “HAC”\n\n\nMixed-Models degrees of freedom: \"satterthwaite\", \"kenward-roger\"\n\n\nOther: “NeweyWest”, “KernHAC”, “OPG”. See the sandwich package documentation.\n\n\n\n\nOne-sided formula which indicates the name of cluster variables (e.g., ~unit_id). This formula is passed to the cluster argument of the sandwich::vcovCL function.\n\n\nSquare covariance matrix\n\n\nFunction which returns a covariance matrix (e.g., stats::vcov(model))\n\n\n\n\n\n\nconf_level\n\n\nnumeric value between 0 and 1. Confidence level to use to build a confidence interval.\n\n\n\n\nwts\n\n\nlogical, string or numeric: weights to use when computing average predictions, contrasts or slopes. These weights only affect the averaging in avg_*() or with the by argument, and not unit-level estimates. See ?weighted.mean\n\n\nstring: column name of the weights variable in newdata. When supplying a column name to wts, it is recommended to supply the original data (including the weights variable) explicitly to newdata.\n\n\nnumeric: vector of length equal to the number of rows in the original data or in newdata (if supplied).\n\n\nFALSE: Equal weights.\n\n\nTRUE: Extract weights from the fitted object with insight::find_weights() and use them when taking weighted averages of estimates. Warning: newdata=datagrid() returns a single average weight, which is equivalent to using wts=FALSE\n\n\n\n\n\n\ntransform\n\n\nA function applied to unit-level adjusted predictions and confidence intervals just before the function returns results. For bayesian models, this function is applied to individual draws from the posterior distribution, before computing summaries.\n\n\n\n\npoints\n\n\nNumber between 0 and 1 which controls the transparency of raw data points. 0 (default) does not display any points. Warning: The points displayed are raw data, so the resulting plot is not a \"partial residual plot.\"\n\n\n\n\nrug\n\n\nTRUE displays tick marks on the axes to mark the distribution of raw data.\n\n\n\n\ngray\n\n\nFALSE grayscale or color plot\n\n\n\n\ndraw\n\n\nTRUE returns a ggplot2 plot. FALSE returns a data.frame of the underlying data.\n\n\n\n\n…\n\n\nAdditional arguments are passed to the predict() method supplied by the modeling package.These arguments are particularly useful for mixed-effects or bayesian models (see the online vignettes on the marginaleffects website). Available arguments can vary from model to model, depending on the range of supported arguments by each modeling package. See the \"Model-Specific Arguments\" section of the ?slopes documentation for a non-exhaustive list of available arguments.\n\n\n\nA ggplot2 object or data frame (if draw=FALSE)\n\nSome model types allow model-specific arguments to modify the nature of marginal effects, predictions, marginal means, and contrasts. Please report other package-specific predict() arguments on Github so we can add them to the table below.\nhttps://github.com/vincentarelbundock/marginaleffects/issues\n\n\n\nPackage\n\n\nClass\n\n\nArgument\n\n\nDocumentation\n\n\n\n\nbrms\n\n\nbrmsfit\n\n\nndraws\n\n\nbrms::posterior_predict\n\n\n\n\n\n\n\n\nre_formula\n\n\nbrms::posterior_predict\n\n\n\n\nlme4\n\n\nmerMod\n\n\nre.form\n\n\nlme4::predict.merMod\n\n\n\n\n\n\n\n\nallow.new.levels\n\n\nlme4::predict.merMod\n\n\n\n\nglmmTMB\n\n\nglmmTMB\n\n\nre.form\n\n\nglmmTMB::predict.glmmTMB\n\n\n\n\n\n\n\n\nallow.new.levels\n\n\nglmmTMB::predict.glmmTMB\n\n\n\n\n\n\n\n\nzitype\n\n\nglmmTMB::predict.glmmTMB\n\n\n\n\nmgcv\n\n\nbam\n\n\nexclude\n\n\nmgcv::predict.bam\n\n\n\n\n\n\ngam\n\n\nexclude\n\n\nmgcv::predict.gam\n\n\n\n\nrobustlmm\n\n\nrlmerMod\n\n\nre.form\n\n\nrobustlmm::predict.rlmerMod\n\n\n\n\n\n\n\n\nallow.new.levels\n\n\nrobustlmm::predict.rlmerMod\n\n\n\n\nMCMCglmm\n\n\nMCMCglmm\n\n\nndraws\n\n\n\n\n\n\nsampleSelection\n\n\nselection\n\n\npart\n\n\nsampleSelection::predict.selection\n\n\n\n\n\n\n\nThe type argument determines the scale of the predictions used to compute quantities of interest with functions from the marginaleffects package. Admissible values for type depend on the model object. When users specify an incorrect value for type, marginaleffects will raise an informative error with a list of valid type values for the specific model object. The first entry in the list in that error message is the default type.\nThe invlink(link) is a special type defined by marginaleffects. It is available for some (but not all) models, and only for the predictions() function. With this link type, we first compute predictions on the link scale, then we use the inverse link function to backtransform the predictions to the response scale. This is useful for models with non-linear link functions as it can ensure that confidence intervals stay within desirable bounds, ex: 0 to 1 for a logit model. Note that an average of estimates with type=“invlink(link)” will not always be equivalent to the average of estimates with type=“response”. This type is default when calling predictions(). It is available—but not default—when calling avg_predictions() or predictions() with the by argument.\nSome of the most common type values are:\nresponse, link, E, Ep, average, class, conditional, count, cum.prob, cumhaz, cumprob, density, detection, disp, ev, expected, expvalue, fitted, hazard, invlink(link), latent, latent_N, linear, linear.predictor, linpred, location, lp, mean, numeric, p, ppd, pr, precision, prediction, prob, probability, probs, quantile, risk, rmst, scale, survival, unconditional, utility, variance, xb, zero, zlink, zprob\n\n\nlibrary(\"marginaleffects\")\n\nmod &lt;- lm(mpg ~ hp + wt, data = mtcars)\nplot_predictions(mod, condition = \"wt\")\n\n\n\n\n\n\nmod &lt;- lm(mpg ~ hp * wt * am, data = mtcars)\nplot_predictions(mod, condition = c(\"hp\", \"wt\"))\n\n\n\n\n\n\nplot_predictions(mod, condition = list(\"hp\", wt = \"threenum\"))\n\n\n\n\n\n\nplot_predictions(mod, condition = list(\"hp\", wt = range))",
    "crumbs": [
      "Model to Meaning",
      "Functions",
      "`plot_predictions`"
    ]
  },
  {
    "objectID": "man/plot_predictions.html#plot-conditional-or-marginal-predictions",
    "href": "man/plot_predictions.html#plot-conditional-or-marginal-predictions",
    "title": "",
    "section": "",
    "text": "Plot predictions on the y-axis against values of one or more predictors (x-axis, colors/shapes, and facets).\nThe by argument is used to plot marginal predictions, that is, predictions made on the original data, but averaged by subgroups. This is analogous to using the by argument in the predictions() function.\nThe condition argument is used to plot conditional predictions, that is, predictions made on a user-specified grid. This is analogous to using the newdata argument and datagrid() function in a predictions() call. All variables whose values are not specified explicitly are treated as usual by datagrid(), that is, they are held at their mean or mode (or rounded mean for integers). This includes grouping variables in mixed-effects models, so analysts who fit such models may want to specify the groups of interest using the condition argument, or supply model-specific arguments to compute population-level estimates. See details below.\nSee the \"Plots\" vignette and website for tutorials and information on how to customize plots:\n\n\nhttps://marginaleffects.com/vignettes/plot.html\n\n\nhttps://marginaleffects.com\n\n\nplot_predictions(\n  model,\n  condition = NULL,\n  by = NULL,\n  newdata = NULL,\n  type = NULL,\n  vcov = NULL,\n  conf_level = 0.95,\n  wts = FALSE,\n  transform = NULL,\n  points = 0,\n  rug = FALSE,\n  gray = FALSE,\n  draw = TRUE,\n  ...\n)\n\n\n\n\n\nmodel\n\n\nModel object\n\n\n\n\ncondition\n\n\nConditional predictions\n\n\nCharacter vector (max length 4): Names of the predictors to display.\n\n\nNamed list (max length 4): List names correspond to predictors. List elements can be:\n\n\nNumeric vector\n\n\nFunction which returns a numeric vector or a set of unique categorical values\n\n\nShortcut strings for common reference values: \"minmax\", \"quartile\", \"threenum\"\n\n\n\n\n1: x-axis. 2: color/shape. 3: facet (wrap if no fourth variable, otherwise cols of grid). 4: facet (rows of grid).\n\n\nNumeric variables in positions 2 and 3 are summarized by Tukey’s five numbers ?stats::fivenum\n\n\n\n\n\n\nby\n\n\nMarginal predictions\n\n\nCharacter vector (max length 3): Names of the categorical predictors to marginalize across.\n\n\n1: x-axis. 2: color. 3: facets.\n\n\n\n\n\n\nnewdata\n\n\nWhen newdata is NULL, the grid is determined by the condition argument. When newdata is not NULL, the argument behaves in the same way as in the predictions() function.\n\n\n\n\ntype\n\n\nstring indicates the type (scale) of the predictions used to compute contrasts or slopes. This can differ based on the model type, but will typically be a string such as: \"response\", \"link\", \"probs\", or \"zero\". When an unsupported string is entered, the model-specific list of acceptable values is returned in an error message. When type is NULL, the first entry in the error message is used by default.\n\n\n\n\nvcov\n\n\nType of uncertainty estimates to report (e.g., for robust standard errors). Acceptable values:\n\n\nFALSE: Do not compute standard errors. This can speed up computation considerably.\n\n\nTRUE: Unit-level standard errors using the default vcov(model) variance-covariance matrix.\n\n\nString which indicates the kind of uncertainty estimates to return.\n\n\nHeteroskedasticity-consistent: “HC”, “HC0”, “HC1”, “HC2”, “HC3”, “HC4”, “HC4m”, “HC5”. See ?sandwich::vcovHC\n\n\nHeteroskedasticity and autocorrelation consistent: “HAC”\n\n\nMixed-Models degrees of freedom: \"satterthwaite\", \"kenward-roger\"\n\n\nOther: “NeweyWest”, “KernHAC”, “OPG”. See the sandwich package documentation.\n\n\n\n\nOne-sided formula which indicates the name of cluster variables (e.g., ~unit_id). This formula is passed to the cluster argument of the sandwich::vcovCL function.\n\n\nSquare covariance matrix\n\n\nFunction which returns a covariance matrix (e.g., stats::vcov(model))\n\n\n\n\n\n\nconf_level\n\n\nnumeric value between 0 and 1. Confidence level to use to build a confidence interval.\n\n\n\n\nwts\n\n\nlogical, string or numeric: weights to use when computing average predictions, contrasts or slopes. These weights only affect the averaging in avg_*() or with the by argument, and not unit-level estimates. See ?weighted.mean\n\n\nstring: column name of the weights variable in newdata. When supplying a column name to wts, it is recommended to supply the original data (including the weights variable) explicitly to newdata.\n\n\nnumeric: vector of length equal to the number of rows in the original data or in newdata (if supplied).\n\n\nFALSE: Equal weights.\n\n\nTRUE: Extract weights from the fitted object with insight::find_weights() and use them when taking weighted averages of estimates. Warning: newdata=datagrid() returns a single average weight, which is equivalent to using wts=FALSE\n\n\n\n\n\n\ntransform\n\n\nA function applied to unit-level adjusted predictions and confidence intervals just before the function returns results. For bayesian models, this function is applied to individual draws from the posterior distribution, before computing summaries.\n\n\n\n\npoints\n\n\nNumber between 0 and 1 which controls the transparency of raw data points. 0 (default) does not display any points. Warning: The points displayed are raw data, so the resulting plot is not a \"partial residual plot.\"\n\n\n\n\nrug\n\n\nTRUE displays tick marks on the axes to mark the distribution of raw data.\n\n\n\n\ngray\n\n\nFALSE grayscale or color plot\n\n\n\n\ndraw\n\n\nTRUE returns a ggplot2 plot. FALSE returns a data.frame of the underlying data.\n\n\n\n\n…\n\n\nAdditional arguments are passed to the predict() method supplied by the modeling package.These arguments are particularly useful for mixed-effects or bayesian models (see the online vignettes on the marginaleffects website). Available arguments can vary from model to model, depending on the range of supported arguments by each modeling package. See the \"Model-Specific Arguments\" section of the ?slopes documentation for a non-exhaustive list of available arguments.\n\n\n\nA ggplot2 object or data frame (if draw=FALSE)\n\nSome model types allow model-specific arguments to modify the nature of marginal effects, predictions, marginal means, and contrasts. Please report other package-specific predict() arguments on Github so we can add them to the table below.\nhttps://github.com/vincentarelbundock/marginaleffects/issues\n\n\n\nPackage\n\n\nClass\n\n\nArgument\n\n\nDocumentation\n\n\n\n\nbrms\n\n\nbrmsfit\n\n\nndraws\n\n\nbrms::posterior_predict\n\n\n\n\n\n\n\n\nre_formula\n\n\nbrms::posterior_predict\n\n\n\n\nlme4\n\n\nmerMod\n\n\nre.form\n\n\nlme4::predict.merMod\n\n\n\n\n\n\n\n\nallow.new.levels\n\n\nlme4::predict.merMod\n\n\n\n\nglmmTMB\n\n\nglmmTMB\n\n\nre.form\n\n\nglmmTMB::predict.glmmTMB\n\n\n\n\n\n\n\n\nallow.new.levels\n\n\nglmmTMB::predict.glmmTMB\n\n\n\n\n\n\n\n\nzitype\n\n\nglmmTMB::predict.glmmTMB\n\n\n\n\nmgcv\n\n\nbam\n\n\nexclude\n\n\nmgcv::predict.bam\n\n\n\n\n\n\ngam\n\n\nexclude\n\n\nmgcv::predict.gam\n\n\n\n\nrobustlmm\n\n\nrlmerMod\n\n\nre.form\n\n\nrobustlmm::predict.rlmerMod\n\n\n\n\n\n\n\n\nallow.new.levels\n\n\nrobustlmm::predict.rlmerMod\n\n\n\n\nMCMCglmm\n\n\nMCMCglmm\n\n\nndraws\n\n\n\n\n\n\nsampleSelection\n\n\nselection\n\n\npart\n\n\nsampleSelection::predict.selection\n\n\n\n\n\n\n\nThe type argument determines the scale of the predictions used to compute quantities of interest with functions from the marginaleffects package. Admissible values for type depend on the model object. When users specify an incorrect value for type, marginaleffects will raise an informative error with a list of valid type values for the specific model object. The first entry in the list in that error message is the default type.\nThe invlink(link) is a special type defined by marginaleffects. It is available for some (but not all) models, and only for the predictions() function. With this link type, we first compute predictions on the link scale, then we use the inverse link function to backtransform the predictions to the response scale. This is useful for models with non-linear link functions as it can ensure that confidence intervals stay within desirable bounds, ex: 0 to 1 for a logit model. Note that an average of estimates with type=“invlink(link)” will not always be equivalent to the average of estimates with type=“response”. This type is default when calling predictions(). It is available—but not default—when calling avg_predictions() or predictions() with the by argument.\nSome of the most common type values are:\nresponse, link, E, Ep, average, class, conditional, count, cum.prob, cumhaz, cumprob, density, detection, disp, ev, expected, expvalue, fitted, hazard, invlink(link), latent, latent_N, linear, linear.predictor, linpred, location, lp, mean, numeric, p, ppd, pr, precision, prediction, prob, probability, probs, quantile, risk, rmst, scale, survival, unconditional, utility, variance, xb, zero, zlink, zprob\n\n\nlibrary(\"marginaleffects\")\n\nmod &lt;- lm(mpg ~ hp + wt, data = mtcars)\nplot_predictions(mod, condition = \"wt\")\n\n\n\n\n\n\nmod &lt;- lm(mpg ~ hp * wt * am, data = mtcars)\nplot_predictions(mod, condition = c(\"hp\", \"wt\"))\n\n\n\n\n\n\nplot_predictions(mod, condition = list(\"hp\", wt = \"threenum\"))\n\n\n\n\n\n\nplot_predictions(mod, condition = list(\"hp\", wt = range))",
    "crumbs": [
      "Model to Meaning",
      "Functions",
      "`plot_predictions`"
    ]
  },
  {
    "objectID": "man/slopes.html",
    "href": "man/slopes.html",
    "title": "",
    "section": "",
    "text": "Partial derivative of the regression equation with respect to a regressor of interest.\n\n\nslopes(): unit-level (conditional) estimates.\n\n\navg_slopes(): average (marginal) estimates.\n\n\nThe newdata argument and the datagrid() function can be used to control where statistics are evaluated in the predictor space: \"at observed values\", \"at the mean\", \"at representative values\", etc.\nSee the slopes vignette and package website for worked examples and case studies:\n\n\nhttps://marginaleffects.com/vignettes/slopes.html\n\n\nhttps://marginaleffects.com/\n\n\nslopes(\n  model,\n  newdata = NULL,\n  variables = NULL,\n  type = NULL,\n  by = FALSE,\n  vcov = TRUE,\n  conf_level = 0.95,\n  slope = \"dydx\",\n  wts = FALSE,\n  hypothesis = NULL,\n  equivalence = NULL,\n  p_adjust = NULL,\n  df = Inf,\n  eps = NULL,\n  numderiv = \"fdforward\",\n  ...\n)\n\navg_slopes(\n  model,\n  newdata = NULL,\n  variables = NULL,\n  type = NULL,\n  by = TRUE,\n  vcov = TRUE,\n  conf_level = 0.95,\n  slope = \"dydx\",\n  wts = FALSE,\n  hypothesis = NULL,\n  equivalence = NULL,\n  p_adjust = NULL,\n  df = Inf,\n  eps = NULL,\n  numderiv = \"fdforward\",\n  ...\n)\n\n\n\n\n\nmodel\n\n\nModel object\n\n\n\n\nnewdata\n\n\nGrid of predictor values at which we evaluate the slopes.\n\n\nWarning: Please avoid modifying your dataset between fitting the model and calling a marginaleffects function. This can sometimes lead to unexpected results.\n\n\nNULL (default): Unit-level slopes for each observed value in the dataset (empirical distribution). The dataset is retrieved using insight::get_data(), which tries to extract data from the environment. This may produce unexpected results if the original data frame has been altered since fitting the model.\n\n\ndatagrid() call to specify a custom grid of regressors. For example:\n\n\nnewdata = datagrid(cyl = c(4, 6)): cyl variable equal to 4 and 6 and other regressors fixed at their means or modes.\n\n\nSee the Examples section and the datagrid() documentation.\n\n\n\n\nsubset() call with a single argument to select a subset of the dataset used to fit the model, ex: newdata = subset(treatment == 1)\n\n\ndplyr::filter() call with a single argument to select a subset of the dataset used to fit the model, ex: newdata = filter(treatment == 1)\n\n\nstring:\n\n\n\"mean\": Slopes evaluated when each predictor is held at its mean or mode.\n\n\n\"median\": Slopes evaluated when each predictor is held at its median or mode.\n\n\n\"balanced\": Slopes evaluated on a balanced grid with every combination of categories and numeric variables held at their means.\n\n\n\"tukey\": Slopes evaluated at Tukey’s 5 numbers.\n\n\n\"grid\": Slopes evaluated on a grid of representative numbers (Tukey’s 5 numbers and unique values of categorical predictors).\n\n\n\n\n\n\n\n\nvariables\n\n\nFocal variables\n\n\nNULL: compute slopes or comparisons for all the variables in the model object (can be slow).\n\n\nCharacter vector: subset of variables (usually faster).\n\n\n\n\n\n\ntype\n\n\nstring indicates the type (scale) of the predictions used to compute contrasts or slopes. This can differ based on the model type, but will typically be a string such as: \"response\", \"link\", \"probs\", or \"zero\". When an unsupported string is entered, the model-specific list of acceptable values is returned in an error message. When type is NULL, the first entry in the error message is used by default.\n\n\n\n\nby\n\n\nAggregate unit-level estimates (aka, marginalize, average over). Valid inputs:\n\n\nFALSE: return the original unit-level estimates.\n\n\nTRUE: aggregate estimates for each term.\n\n\nCharacter vector of column names in newdata or in the data frame produced by calling the function without the by argument.\n\n\nData frame with a by column of group labels, and merging columns shared by newdata or the data frame produced by calling the same function without the by argument.\n\n\nSee examples below.\n\n\nFor more complex aggregations, you can use the FUN argument of the hypotheses() function. See that function’s documentation and the Hypothesis Test vignettes on the marginaleffects website.\n\n\n\n\n\n\nvcov\n\n\nType of uncertainty estimates to report (e.g., for robust standard errors). Acceptable values:\n\n\nFALSE: Do not compute standard errors. This can speed up computation considerably.\n\n\nTRUE: Unit-level standard errors using the default vcov(model) variance-covariance matrix.\n\n\nString which indicates the kind of uncertainty estimates to return.\n\n\nHeteroskedasticity-consistent: “HC”, “HC0”, “HC1”, “HC2”, “HC3”, “HC4”, “HC4m”, “HC5”. See ?sandwich::vcovHC\n\n\nHeteroskedasticity and autocorrelation consistent: “HAC”\n\n\nMixed-Models degrees of freedom: \"satterthwaite\", \"kenward-roger\"\n\n\nOther: “NeweyWest”, “KernHAC”, “OPG”. See the sandwich package documentation.\n\n\n\n\nOne-sided formula which indicates the name of cluster variables (e.g., ~unit_id). This formula is passed to the cluster argument of the sandwich::vcovCL function.\n\n\nSquare covariance matrix\n\n\nFunction which returns a covariance matrix (e.g., stats::vcov(model))\n\n\n\n\n\n\nconf_level\n\n\nnumeric value between 0 and 1. Confidence level to use to build a confidence interval.\n\n\n\n\nslope\n\n\nstring indicates the type of slope or (semi-)elasticity to compute:\n\n\n\"dydx\": dY/dX\n\n\n\"eyex\": dY/dX * Y / X\n\n\n\"eydx\": dY/dX * Y\n\n\n\"dyex\": dY/dX / X\n\n\nY is the predicted value of the outcome; X is the observed value of the predictor.\n\n\n\n\n\n\nwts\n\n\nlogical, string or numeric: weights to use when computing average predictions, contrasts or slopes. These weights only affect the averaging in avg_*() or with the by argument, and not unit-level estimates. See ?weighted.mean\n\n\nstring: column name of the weights variable in newdata. When supplying a column name to wts, it is recommended to supply the original data (including the weights variable) explicitly to newdata.\n\n\nnumeric: vector of length equal to the number of rows in the original data or in newdata (if supplied).\n\n\nFALSE: Equal weights.\n\n\nTRUE: Extract weights from the fitted object with insight::find_weights() and use them when taking weighted averages of estimates. Warning: newdata=datagrid() returns a single average weight, which is equivalent to using wts=FALSE\n\n\n\n\n\n\nhypothesis\n\n\nspecify a hypothesis test or custom contrast using a numeric value, vector, or matrix; a string equation; string; a formula, or a function.\n\n\nNumeric:\n\n\nSingle value: the null hypothesis used in the computation of Z and p (before applying transform).\n\n\nVector: Weights to compute a linear combination of (custom contrast between) estimates. Length equal to the number of rows generated by the same function call, but without the hypothesis argument.\n\n\nMatrix: Each column is a vector of weights, as describe above, used to compute a distinct linear combination of (contrast between) estimates. The column names of the matrix are used as labels in the output.\n\n\n\n\nString equation to specify linear or non-linear hypothesis tests. If the term column uniquely identifies rows, terms can be used in the formula. Otherwise, use b1, b2, etc. to identify the position of each parameter. The b* wildcard can be used to test hypotheses on all estimates. If a named vector is used, the names are used as labels in the output. Examples:\n\n\nhp = drat\n\n\nhp + drat = 12\n\n\nb1 + b2 + b3 = 0\n\n\nb* / b1 = 1\n\n\n\n\nString:\n\n\n\"pairwise\": pairwise differences between estimates in each row.\n\n\n\"reference\": differences between the estimates in each row and the estimate in the first row.\n\n\n\"sequential\": difference between an estimate and the estimate in the next row.\n\n\n\"meandev\": difference between an estimate and the mean of all estimates.\n\n\n\"meanotherdev\": difference between an estimate and the mean of all other estimates, excluding the current one.\n\n\n\"revpairwise\", \"revreference\", \"revsequential\": inverse of the corresponding hypotheses, as described above.\n\n\n\n\nFormula:\n\n\ncomparison ~ pairs | group\n\n\nLeft-hand side determines the type of comparison to conduct: difference or ratio. If the left-hand side is empty, difference is chosen.\n\n\nRight-hand side determines the pairs of estimates to compare: reference, sequential, or meandev\n\n\nOptional: Users can supply grouping variables after a vertical bar to conduct comparisons withing subsets.\n\n\nExamples:\n\n\n~ reference\n\n\nratio ~ pairwise\n\n\ndifference ~ pairwise | groupid\n\n\n\n\n\n\nFunction:\n\n\nAccepts an argument x: object produced by a marginaleffects function or a data frame with column rowid and estimate\n\n\nReturns a data frame with columns term and estimate (mandatory) and rowid (optional).\n\n\nThe function can also accept optional input arguments: newdata, by, draws.\n\n\nThis function approach will not work for Bayesian models or with bootstrapping. In those cases, it is easy to use posterior_draws() to extract and manipulate the draws directly.\n\n\n\n\nSee the Examples section below and the vignette: https://marginaleffects.com/vignettes/hypothesis.html\n\n\n\n\n\n\nequivalence\n\n\nNumeric vector of length 2: bounds used for the two-one-sided test (TOST) of equivalence, and for the non-inferiority and non-superiority tests. See Details section below.\n\n\n\n\np_adjust\n\n\nAdjust p-values for multiple comparisons: \"holm\", \"hochberg\", \"hommel\", \"bonferroni\", \"BH\", \"BY\", or \"fdr\". See stats::p.adjust\n\n\n\n\ndf\n\n\nDegrees of freedom used to compute p values and confidence intervals. A single numeric value between 1 and Inf. When df is Inf, the normal distribution is used. When df is finite, the t distribution is used. See insight::get_df for a convenient function to extract degrees of freedom. Ex: slopes(model, df = insight::get_df(model))\n\n\n\n\neps\n\n\nNULL or numeric value which determines the step size to use when calculating numerical derivatives: (f(x+eps)-f(x))/eps. When eps is NULL, the step size is 0.0001 multiplied by the difference between the maximum and minimum values of the variable with respect to which we are taking the derivative. Changing eps may be necessary to avoid numerical problems in certain models.\n\n\n\n\nnumderiv\n\n\nstring or list of strings indicating the method to use to for the numeric differentiation used in to compute delta method standard errors.\n\n\n\"fdforward\": finite difference method with forward differences\n\n\n\"fdcenter\": finite difference method with central differences (default)\n\n\n\"richardson\": Richardson extrapolation method\n\n\nExtra arguments can be specified by passing a list to the numDeriv argument, with the name of the method first and named arguments following, ex: numderiv=list(“fdcenter”, eps = 1e-5). When an unknown argument is used, marginaleffects prints the list of valid arguments for each method.\n\n\n\n\n\n\n…\n\n\nAdditional arguments are passed to the predict() method supplied by the modeling package.These arguments are particularly useful for mixed-effects or bayesian models (see the online vignettes on the marginaleffects website). Available arguments can vary from model to model, depending on the range of supported arguments by each modeling package. See the \"Model-Specific Arguments\" section of the ?slopes documentation for a non-exhaustive list of available arguments.\n\n\n\nA \"slope\" or \"marginal effect\" is the partial derivative of the regression equation with respect to a variable in the model. This function uses automatic differentiation to compute slopes for a vast array of models, including non-linear models with transformations (e.g., polynomials). Uncertainty estimates are computed using the delta method.\nNumerical derivatives for the slopes function are calculated using a simple epsilon difference approach: \\(\\partial Y / \\partial X = (f(X + \\varepsilon/2) - f(X-\\varepsilon/2)) / \\varepsilon\\), where f is the predict() method associated with the model class, and \\(\\varepsilon\\) is determined by the eps argument.\n\nA data.frame with one row per observation (per term/group) and several columns:\n\n\nrowid: row number of the newdata data frame\n\n\ntype: prediction type, as defined by the type argument\n\n\ngroup: (optional) value of the grouped outcome (e.g., categorical outcome models)\n\n\nterm: the variable whose marginal effect is computed\n\n\ndydx: slope of the outcome with respect to the term, for a given combination of predictor values\n\n\nstd.error: standard errors computed by via the delta method.\n\n\np.value: p value associated to the estimate column. The null is determined by the hypothesis argument (0 by default), and p values are computed before applying the transform argument. For models of class feglm, Gam, glm and negbin, p values are computed on the link scale by default unless the type argument is specified explicitly.\n\n\ns.value: Shannon information transforms of p values. How many consecutive \"heads\" tosses would provide the same amount of evidence (or \"surprise\") against the null hypothesis that the coin is fair? The purpose of S is to calibrate the analyst’s intuition about the strength of evidence encoded in p against a well-known physical phenomenon. See Greenland (2019) and Cole et al. (2020).\n\n\nconf.low: lower bound of the confidence interval (or equal-tailed interval for bayesian models)\n\n\nconf.high: upper bound of the confidence interval (or equal-tailed interval for bayesian models)\n\n\nSee ?print.marginaleffects for printing options.\n\n\n\navg_slopes(): Average slopes\n\n\nStandard errors for all quantities estimated by marginaleffects can be obtained via the delta method. This requires differentiating a function with respect to the coefficients in the model using a finite difference approach. In some models, the delta method standard errors can be sensitive to various aspects of the numeric differentiation strategy, including the step size. By default, the step size is set to 1e-8, or to 1e-4 times the smallest absolute model coefficient, whichever is largest.\nmarginaleffects can delegate numeric differentiation to the numDeriv package, which allows more flexibility. To do this, users can pass arguments to the numDeriv::jacobian function through a global option. For example:\n\n\noptions(marginaleffects_numDeriv = list(method = “simple”, method.args = list(eps = 1e-6)))\n\n\noptions(marginaleffects_numDeriv = list(method = “Richardson”, method.args = list(eps = 1e-5)))\n\n\noptions(marginaleffects_numDeriv = NULL)\n\n\nSee the \"Standard Errors and Confidence Intervals\" vignette on the marginaleffects website for more details on the computation of standard errors:\nhttps://marginaleffects.com/vignettes/uncertainty.html\nNote that the inferences() function can be used to compute uncertainty estimates using a bootstrap or simulation-based inference. See the vignette:\nhttps://marginaleffects.com/vignettes/bootstrap.html\n\nSome model types allow model-specific arguments to modify the nature of marginal effects, predictions, marginal means, and contrasts. Please report other package-specific predict() arguments on Github so we can add them to the table below.\nhttps://github.com/vincentarelbundock/marginaleffects/issues\n\n\n\nPackage\n\n\nClass\n\n\nArgument\n\n\nDocumentation\n\n\n\n\nbrms\n\n\nbrmsfit\n\n\nndraws\n\n\nbrms::posterior_predict\n\n\n\n\n\n\n\n\nre_formula\n\n\nbrms::posterior_predict\n\n\n\n\nlme4\n\n\nmerMod\n\n\nre.form\n\n\nlme4::predict.merMod\n\n\n\n\n\n\n\n\nallow.new.levels\n\n\nlme4::predict.merMod\n\n\n\n\nglmmTMB\n\n\nglmmTMB\n\n\nre.form\n\n\nglmmTMB::predict.glmmTMB\n\n\n\n\n\n\n\n\nallow.new.levels\n\n\nglmmTMB::predict.glmmTMB\n\n\n\n\n\n\n\n\nzitype\n\n\nglmmTMB::predict.glmmTMB\n\n\n\n\nmgcv\n\n\nbam\n\n\nexclude\n\n\nmgcv::predict.bam\n\n\n\n\n\n\ngam\n\n\nexclude\n\n\nmgcv::predict.gam\n\n\n\n\nrobustlmm\n\n\nrlmerMod\n\n\nre.form\n\n\nrobustlmm::predict.rlmerMod\n\n\n\n\n\n\n\n\nallow.new.levels\n\n\nrobustlmm::predict.rlmerMod\n\n\n\n\nMCMCglmm\n\n\nMCMCglmm\n\n\nndraws\n\n\n\n\n\n\nsampleSelection\n\n\nselection\n\n\npart\n\n\nsampleSelection::predict.selection\n\n\n\n\n\n\n\nBy default, credible intervals in bayesian models are built as equal-tailed intervals. This can be changed to a highest density interval by setting a global option:\noptions(“marginaleffects_posterior_interval” = “eti”)\noptions(“marginaleffects_posterior_interval” = “hdi”)\nBy default, the center of the posterior distribution in bayesian models is identified by the median. Users can use a different summary function by setting a global option:\noptions(“marginaleffects_posterior_center” = “mean”)\noptions(“marginaleffects_posterior_center” = “median”)\nWhen estimates are averaged using the by argument, the tidy() function, or the summary() function, the posterior distribution is marginalized twice over. First, we take the average across units but within each iteration of the MCMC chain, according to what the user requested in by argument or tidy()/summary() functions. Then, we identify the center of the resulting posterior using the function supplied to the “marginaleffects_posterior_center” option (the median by default).\n\n\\(\\theta\\) is an estimate, \\(\\sigma_\\theta\\) its estimated standard error, and \\([a, b]\\) are the bounds of the interval supplied to the equivalence argument.\nNon-inferiority:\n\n\n\\(H_0\\): \\(\\theta \\leq a\\)\n\n\n\\(H_1\\): \\(\\theta &gt; a\\)\n\n\n\\(t=(\\theta - a)/\\sigma_\\theta\\)\n\n\np: Upper-tail probability\n\n\nNon-superiority:\n\n\n\\(H_0\\): \\(\\theta \\geq b\\)\n\n\n\\(H_1\\): \\(\\theta &lt; b\\)\n\n\n\\(t=(\\theta - b)/\\sigma_\\theta\\)\n\n\np: Lower-tail probability\n\n\nEquivalence: Two One-Sided Tests (TOST)\n\n\np: Maximum of the non-inferiority and non-superiority p values.\n\n\nThanks to Russell V. Lenth for the excellent emmeans package and documentation which inspired this feature.\n\nThe type argument determines the scale of the predictions used to compute quantities of interest with functions from the marginaleffects package. Admissible values for type depend on the model object. When users specify an incorrect value for type, marginaleffects will raise an informative error with a list of valid type values for the specific model object. The first entry in the list in that error message is the default type.\nThe invlink(link) is a special type defined by marginaleffects. It is available for some (but not all) models, and only for the predictions() function. With this link type, we first compute predictions on the link scale, then we use the inverse link function to backtransform the predictions to the response scale. This is useful for models with non-linear link functions as it can ensure that confidence intervals stay within desirable bounds, ex: 0 to 1 for a logit model. Note that an average of estimates with type=“invlink(link)” will not always be equivalent to the average of estimates with type=“response”. This type is default when calling predictions(). It is available—but not default—when calling avg_predictions() or predictions() with the by argument.\nSome of the most common type values are:\nresponse, link, E, Ep, average, class, conditional, count, cum.prob, cumhaz, cumprob, density, detection, disp, ev, expected, expvalue, fitted, hazard, invlink(link), latent, latent_N, linear, linear.predictor, linpred, location, lp, mean, numeric, p, ppd, pr, precision, prediction, prob, probability, probs, quantile, risk, rmst, scale, survival, unconditional, utility, variance, xb, zero, zlink, zprob\n\nThe slopes() and comparisons() functions can use parallelism to speed up computation. Operations are parallelized for the computation of standard errors, at the model coefficient level. There is always considerable overhead when using parallel computation, mainly involved in passing the whole dataset to the different processes. Thus, parallel computation is most likely to be useful when the model includes many parameters and the dataset is relatively small.\nWarning: In many cases, parallel processing will not be useful at all.\nTo activate parallel computation, users must load the future.apply package, call plan() function, and set a global option. For example:\n\nlibrary(future.apply)\nplan(\"multicore\", workers = 4)\noptions(marginaleffects_parallel = TRUE)\n\nslopes(model)\n\n\nTo disable parallelism in marginaleffects altogether, you can set a global option:\n\noptions(marginaleffects_parallel = FALSE)\n\n\n\nBehind the scenes, the arguments of marginaleffects functions are evaluated in this order:\n\n\nnewdata\n\n\nvariables\n\n\ncomparison and slopes\n\n\nby\n\n\nvcov\n\n\nhypothesis\n\n\ntransform\n\n\nThe behavior of marginaleffects functions can be modified by setting global options.\nDisable some safety checks:\n\noptions(marginaleffects_safe = FALSE)\n\n\nOmit some columns from the printed output:\n\noptions(marginaleffects_print_omit = c(\"p.value\", \"s.value\"))`\n\n\n\n\n\nGreenland S. 2019. \"Valid P-Values Behave Exactly as They Should: Some Misleading Criticisms of P-Values and Their Resolution With S-Values.\" The American Statistician. 73(S1): 106–114.\n\n\nCole, Stephen R, Jessie K Edwards, and Sander Greenland. 2020. \"Surprise!\" American Journal of Epidemiology 190 (2): 191–93. https://doi.org/10.1093/aje/kwaa136\n\n\n\nlibrary(\"marginaleffects\")\n\n\n\n# Unit-level (conditional) Marginal Effects\nmod &lt;- glm(am ~ hp * wt, data = mtcars, family = binomial)\nmfx &lt;- slopes(mod)\nhead(mfx)\n\n# Average Marginal Effect (AME)\navg_slopes(mod, by = TRUE)\n\n\n# Marginal Effect at the Mean (MEM)\nslopes(mod, newdata = datagrid())\n\n# Marginal Effect at User-Specified Values\n# Variables not explicitly included in `datagrid()` are held at their means\nslopes(mod, newdata = datagrid(hp = c(100, 110)))\n\n# Group-Average Marginal Effects (G-AME)\n# Calculate marginal effects for each observation, and then take the average\n# marginal effect within each subset of observations with different observed\n# values for the `cyl` variable:\nmod2 &lt;- lm(mpg ~ hp * cyl, data = mtcars)\navg_slopes(mod2, variables = \"hp\", by = \"cyl\")\n\n# Marginal Effects at User-Specified Values (counterfactual)\n# Variables not explicitly included in `datagrid()` are held at their\n# original values, and the whole dataset is duplicated once for each\n# combination of the values in `datagrid()`\nmfx &lt;- slopes(mod,\n    newdata = datagrid(\n        hp = c(100, 110),\n        grid_type = \"counterfactual\"))\nhead(mfx)\n\n# Heteroskedasticity robust standard errors\nmfx &lt;- slopes(mod, vcov = sandwich::vcovHC(mod))\nhead(mfx)\n\n# hypothesis test: is the `hp` marginal effect at the mean equal to the `drat` marginal effect\nmod &lt;- lm(mpg ~ wt + drat, data = mtcars)\n\nslopes(\n    mod,\n    newdata = \"mean\",\n    hypothesis = \"wt = drat\")\n\n# same hypothesis test using row indices\nslopes(\n    mod,\n    newdata = \"mean\",\n    hypothesis = \"b1 - b2 = 0\")\n\n# same hypothesis test using numeric vector of weights\nslopes(\n    mod,\n    newdata = \"mean\",\n    hypothesis = c(1, -1))\n\n# two custom contrasts using a matrix of weights\nlc &lt;- matrix(\n    c(\n        1, -1,\n        2, 3),\n    ncol = 2)\ncolnames(lc) &lt;- c(\"Contrast A\", \"Contrast B\")\nslopes(\n    mod,\n    newdata = \"mean\",\n    hypothesis = lc)",
    "crumbs": [
      "Model to Meaning",
      "Functions",
      "`slopes`"
    ]
  },
  {
    "objectID": "man/slopes.html#slopes-aka-partial-derivatives-marginal-effects-or-trends",
    "href": "man/slopes.html#slopes-aka-partial-derivatives-marginal-effects-or-trends",
    "title": "",
    "section": "",
    "text": "Partial derivative of the regression equation with respect to a regressor of interest.\n\n\nslopes(): unit-level (conditional) estimates.\n\n\navg_slopes(): average (marginal) estimates.\n\n\nThe newdata argument and the datagrid() function can be used to control where statistics are evaluated in the predictor space: \"at observed values\", \"at the mean\", \"at representative values\", etc.\nSee the slopes vignette and package website for worked examples and case studies:\n\n\nhttps://marginaleffects.com/vignettes/slopes.html\n\n\nhttps://marginaleffects.com/\n\n\nslopes(\n  model,\n  newdata = NULL,\n  variables = NULL,\n  type = NULL,\n  by = FALSE,\n  vcov = TRUE,\n  conf_level = 0.95,\n  slope = \"dydx\",\n  wts = FALSE,\n  hypothesis = NULL,\n  equivalence = NULL,\n  p_adjust = NULL,\n  df = Inf,\n  eps = NULL,\n  numderiv = \"fdforward\",\n  ...\n)\n\navg_slopes(\n  model,\n  newdata = NULL,\n  variables = NULL,\n  type = NULL,\n  by = TRUE,\n  vcov = TRUE,\n  conf_level = 0.95,\n  slope = \"dydx\",\n  wts = FALSE,\n  hypothesis = NULL,\n  equivalence = NULL,\n  p_adjust = NULL,\n  df = Inf,\n  eps = NULL,\n  numderiv = \"fdforward\",\n  ...\n)\n\n\n\n\n\nmodel\n\n\nModel object\n\n\n\n\nnewdata\n\n\nGrid of predictor values at which we evaluate the slopes.\n\n\nWarning: Please avoid modifying your dataset between fitting the model and calling a marginaleffects function. This can sometimes lead to unexpected results.\n\n\nNULL (default): Unit-level slopes for each observed value in the dataset (empirical distribution). The dataset is retrieved using insight::get_data(), which tries to extract data from the environment. This may produce unexpected results if the original data frame has been altered since fitting the model.\n\n\ndatagrid() call to specify a custom grid of regressors. For example:\n\n\nnewdata = datagrid(cyl = c(4, 6)): cyl variable equal to 4 and 6 and other regressors fixed at their means or modes.\n\n\nSee the Examples section and the datagrid() documentation.\n\n\n\n\nsubset() call with a single argument to select a subset of the dataset used to fit the model, ex: newdata = subset(treatment == 1)\n\n\ndplyr::filter() call with a single argument to select a subset of the dataset used to fit the model, ex: newdata = filter(treatment == 1)\n\n\nstring:\n\n\n\"mean\": Slopes evaluated when each predictor is held at its mean or mode.\n\n\n\"median\": Slopes evaluated when each predictor is held at its median or mode.\n\n\n\"balanced\": Slopes evaluated on a balanced grid with every combination of categories and numeric variables held at their means.\n\n\n\"tukey\": Slopes evaluated at Tukey’s 5 numbers.\n\n\n\"grid\": Slopes evaluated on a grid of representative numbers (Tukey’s 5 numbers and unique values of categorical predictors).\n\n\n\n\n\n\n\n\nvariables\n\n\nFocal variables\n\n\nNULL: compute slopes or comparisons for all the variables in the model object (can be slow).\n\n\nCharacter vector: subset of variables (usually faster).\n\n\n\n\n\n\ntype\n\n\nstring indicates the type (scale) of the predictions used to compute contrasts or slopes. This can differ based on the model type, but will typically be a string such as: \"response\", \"link\", \"probs\", or \"zero\". When an unsupported string is entered, the model-specific list of acceptable values is returned in an error message. When type is NULL, the first entry in the error message is used by default.\n\n\n\n\nby\n\n\nAggregate unit-level estimates (aka, marginalize, average over). Valid inputs:\n\n\nFALSE: return the original unit-level estimates.\n\n\nTRUE: aggregate estimates for each term.\n\n\nCharacter vector of column names in newdata or in the data frame produced by calling the function without the by argument.\n\n\nData frame with a by column of group labels, and merging columns shared by newdata or the data frame produced by calling the same function without the by argument.\n\n\nSee examples below.\n\n\nFor more complex aggregations, you can use the FUN argument of the hypotheses() function. See that function’s documentation and the Hypothesis Test vignettes on the marginaleffects website.\n\n\n\n\n\n\nvcov\n\n\nType of uncertainty estimates to report (e.g., for robust standard errors). Acceptable values:\n\n\nFALSE: Do not compute standard errors. This can speed up computation considerably.\n\n\nTRUE: Unit-level standard errors using the default vcov(model) variance-covariance matrix.\n\n\nString which indicates the kind of uncertainty estimates to return.\n\n\nHeteroskedasticity-consistent: “HC”, “HC0”, “HC1”, “HC2”, “HC3”, “HC4”, “HC4m”, “HC5”. See ?sandwich::vcovHC\n\n\nHeteroskedasticity and autocorrelation consistent: “HAC”\n\n\nMixed-Models degrees of freedom: \"satterthwaite\", \"kenward-roger\"\n\n\nOther: “NeweyWest”, “KernHAC”, “OPG”. See the sandwich package documentation.\n\n\n\n\nOne-sided formula which indicates the name of cluster variables (e.g., ~unit_id). This formula is passed to the cluster argument of the sandwich::vcovCL function.\n\n\nSquare covariance matrix\n\n\nFunction which returns a covariance matrix (e.g., stats::vcov(model))\n\n\n\n\n\n\nconf_level\n\n\nnumeric value between 0 and 1. Confidence level to use to build a confidence interval.\n\n\n\n\nslope\n\n\nstring indicates the type of slope or (semi-)elasticity to compute:\n\n\n\"dydx\": dY/dX\n\n\n\"eyex\": dY/dX * Y / X\n\n\n\"eydx\": dY/dX * Y\n\n\n\"dyex\": dY/dX / X\n\n\nY is the predicted value of the outcome; X is the observed value of the predictor.\n\n\n\n\n\n\nwts\n\n\nlogical, string or numeric: weights to use when computing average predictions, contrasts or slopes. These weights only affect the averaging in avg_*() or with the by argument, and not unit-level estimates. See ?weighted.mean\n\n\nstring: column name of the weights variable in newdata. When supplying a column name to wts, it is recommended to supply the original data (including the weights variable) explicitly to newdata.\n\n\nnumeric: vector of length equal to the number of rows in the original data or in newdata (if supplied).\n\n\nFALSE: Equal weights.\n\n\nTRUE: Extract weights from the fitted object with insight::find_weights() and use them when taking weighted averages of estimates. Warning: newdata=datagrid() returns a single average weight, which is equivalent to using wts=FALSE\n\n\n\n\n\n\nhypothesis\n\n\nspecify a hypothesis test or custom contrast using a numeric value, vector, or matrix; a string equation; string; a formula, or a function.\n\n\nNumeric:\n\n\nSingle value: the null hypothesis used in the computation of Z and p (before applying transform).\n\n\nVector: Weights to compute a linear combination of (custom contrast between) estimates. Length equal to the number of rows generated by the same function call, but without the hypothesis argument.\n\n\nMatrix: Each column is a vector of weights, as describe above, used to compute a distinct linear combination of (contrast between) estimates. The column names of the matrix are used as labels in the output.\n\n\n\n\nString equation to specify linear or non-linear hypothesis tests. If the term column uniquely identifies rows, terms can be used in the formula. Otherwise, use b1, b2, etc. to identify the position of each parameter. The b* wildcard can be used to test hypotheses on all estimates. If a named vector is used, the names are used as labels in the output. Examples:\n\n\nhp = drat\n\n\nhp + drat = 12\n\n\nb1 + b2 + b3 = 0\n\n\nb* / b1 = 1\n\n\n\n\nString:\n\n\n\"pairwise\": pairwise differences between estimates in each row.\n\n\n\"reference\": differences between the estimates in each row and the estimate in the first row.\n\n\n\"sequential\": difference between an estimate and the estimate in the next row.\n\n\n\"meandev\": difference between an estimate and the mean of all estimates.\n\n\n\"meanotherdev\": difference between an estimate and the mean of all other estimates, excluding the current one.\n\n\n\"revpairwise\", \"revreference\", \"revsequential\": inverse of the corresponding hypotheses, as described above.\n\n\n\n\nFormula:\n\n\ncomparison ~ pairs | group\n\n\nLeft-hand side determines the type of comparison to conduct: difference or ratio. If the left-hand side is empty, difference is chosen.\n\n\nRight-hand side determines the pairs of estimates to compare: reference, sequential, or meandev\n\n\nOptional: Users can supply grouping variables after a vertical bar to conduct comparisons withing subsets.\n\n\nExamples:\n\n\n~ reference\n\n\nratio ~ pairwise\n\n\ndifference ~ pairwise | groupid\n\n\n\n\n\n\nFunction:\n\n\nAccepts an argument x: object produced by a marginaleffects function or a data frame with column rowid and estimate\n\n\nReturns a data frame with columns term and estimate (mandatory) and rowid (optional).\n\n\nThe function can also accept optional input arguments: newdata, by, draws.\n\n\nThis function approach will not work for Bayesian models or with bootstrapping. In those cases, it is easy to use posterior_draws() to extract and manipulate the draws directly.\n\n\n\n\nSee the Examples section below and the vignette: https://marginaleffects.com/vignettes/hypothesis.html\n\n\n\n\n\n\nequivalence\n\n\nNumeric vector of length 2: bounds used for the two-one-sided test (TOST) of equivalence, and for the non-inferiority and non-superiority tests. See Details section below.\n\n\n\n\np_adjust\n\n\nAdjust p-values for multiple comparisons: \"holm\", \"hochberg\", \"hommel\", \"bonferroni\", \"BH\", \"BY\", or \"fdr\". See stats::p.adjust\n\n\n\n\ndf\n\n\nDegrees of freedom used to compute p values and confidence intervals. A single numeric value between 1 and Inf. When df is Inf, the normal distribution is used. When df is finite, the t distribution is used. See insight::get_df for a convenient function to extract degrees of freedom. Ex: slopes(model, df = insight::get_df(model))\n\n\n\n\neps\n\n\nNULL or numeric value which determines the step size to use when calculating numerical derivatives: (f(x+eps)-f(x))/eps. When eps is NULL, the step size is 0.0001 multiplied by the difference between the maximum and minimum values of the variable with respect to which we are taking the derivative. Changing eps may be necessary to avoid numerical problems in certain models.\n\n\n\n\nnumderiv\n\n\nstring or list of strings indicating the method to use to for the numeric differentiation used in to compute delta method standard errors.\n\n\n\"fdforward\": finite difference method with forward differences\n\n\n\"fdcenter\": finite difference method with central differences (default)\n\n\n\"richardson\": Richardson extrapolation method\n\n\nExtra arguments can be specified by passing a list to the numDeriv argument, with the name of the method first and named arguments following, ex: numderiv=list(“fdcenter”, eps = 1e-5). When an unknown argument is used, marginaleffects prints the list of valid arguments for each method.\n\n\n\n\n\n\n…\n\n\nAdditional arguments are passed to the predict() method supplied by the modeling package.These arguments are particularly useful for mixed-effects or bayesian models (see the online vignettes on the marginaleffects website). Available arguments can vary from model to model, depending on the range of supported arguments by each modeling package. See the \"Model-Specific Arguments\" section of the ?slopes documentation for a non-exhaustive list of available arguments.\n\n\n\nA \"slope\" or \"marginal effect\" is the partial derivative of the regression equation with respect to a variable in the model. This function uses automatic differentiation to compute slopes for a vast array of models, including non-linear models with transformations (e.g., polynomials). Uncertainty estimates are computed using the delta method.\nNumerical derivatives for the slopes function are calculated using a simple epsilon difference approach: \\(\\partial Y / \\partial X = (f(X + \\varepsilon/2) - f(X-\\varepsilon/2)) / \\varepsilon\\), where f is the predict() method associated with the model class, and \\(\\varepsilon\\) is determined by the eps argument.\n\nA data.frame with one row per observation (per term/group) and several columns:\n\n\nrowid: row number of the newdata data frame\n\n\ntype: prediction type, as defined by the type argument\n\n\ngroup: (optional) value of the grouped outcome (e.g., categorical outcome models)\n\n\nterm: the variable whose marginal effect is computed\n\n\ndydx: slope of the outcome with respect to the term, for a given combination of predictor values\n\n\nstd.error: standard errors computed by via the delta method.\n\n\np.value: p value associated to the estimate column. The null is determined by the hypothesis argument (0 by default), and p values are computed before applying the transform argument. For models of class feglm, Gam, glm and negbin, p values are computed on the link scale by default unless the type argument is specified explicitly.\n\n\ns.value: Shannon information transforms of p values. How many consecutive \"heads\" tosses would provide the same amount of evidence (or \"surprise\") against the null hypothesis that the coin is fair? The purpose of S is to calibrate the analyst’s intuition about the strength of evidence encoded in p against a well-known physical phenomenon. See Greenland (2019) and Cole et al. (2020).\n\n\nconf.low: lower bound of the confidence interval (or equal-tailed interval for bayesian models)\n\n\nconf.high: upper bound of the confidence interval (or equal-tailed interval for bayesian models)\n\n\nSee ?print.marginaleffects for printing options.\n\n\n\navg_slopes(): Average slopes\n\n\nStandard errors for all quantities estimated by marginaleffects can be obtained via the delta method. This requires differentiating a function with respect to the coefficients in the model using a finite difference approach. In some models, the delta method standard errors can be sensitive to various aspects of the numeric differentiation strategy, including the step size. By default, the step size is set to 1e-8, or to 1e-4 times the smallest absolute model coefficient, whichever is largest.\nmarginaleffects can delegate numeric differentiation to the numDeriv package, which allows more flexibility. To do this, users can pass arguments to the numDeriv::jacobian function through a global option. For example:\n\n\noptions(marginaleffects_numDeriv = list(method = “simple”, method.args = list(eps = 1e-6)))\n\n\noptions(marginaleffects_numDeriv = list(method = “Richardson”, method.args = list(eps = 1e-5)))\n\n\noptions(marginaleffects_numDeriv = NULL)\n\n\nSee the \"Standard Errors and Confidence Intervals\" vignette on the marginaleffects website for more details on the computation of standard errors:\nhttps://marginaleffects.com/vignettes/uncertainty.html\nNote that the inferences() function can be used to compute uncertainty estimates using a bootstrap or simulation-based inference. See the vignette:\nhttps://marginaleffects.com/vignettes/bootstrap.html\n\nSome model types allow model-specific arguments to modify the nature of marginal effects, predictions, marginal means, and contrasts. Please report other package-specific predict() arguments on Github so we can add them to the table below.\nhttps://github.com/vincentarelbundock/marginaleffects/issues\n\n\n\nPackage\n\n\nClass\n\n\nArgument\n\n\nDocumentation\n\n\n\n\nbrms\n\n\nbrmsfit\n\n\nndraws\n\n\nbrms::posterior_predict\n\n\n\n\n\n\n\n\nre_formula\n\n\nbrms::posterior_predict\n\n\n\n\nlme4\n\n\nmerMod\n\n\nre.form\n\n\nlme4::predict.merMod\n\n\n\n\n\n\n\n\nallow.new.levels\n\n\nlme4::predict.merMod\n\n\n\n\nglmmTMB\n\n\nglmmTMB\n\n\nre.form\n\n\nglmmTMB::predict.glmmTMB\n\n\n\n\n\n\n\n\nallow.new.levels\n\n\nglmmTMB::predict.glmmTMB\n\n\n\n\n\n\n\n\nzitype\n\n\nglmmTMB::predict.glmmTMB\n\n\n\n\nmgcv\n\n\nbam\n\n\nexclude\n\n\nmgcv::predict.bam\n\n\n\n\n\n\ngam\n\n\nexclude\n\n\nmgcv::predict.gam\n\n\n\n\nrobustlmm\n\n\nrlmerMod\n\n\nre.form\n\n\nrobustlmm::predict.rlmerMod\n\n\n\n\n\n\n\n\nallow.new.levels\n\n\nrobustlmm::predict.rlmerMod\n\n\n\n\nMCMCglmm\n\n\nMCMCglmm\n\n\nndraws\n\n\n\n\n\n\nsampleSelection\n\n\nselection\n\n\npart\n\n\nsampleSelection::predict.selection\n\n\n\n\n\n\n\nBy default, credible intervals in bayesian models are built as equal-tailed intervals. This can be changed to a highest density interval by setting a global option:\noptions(“marginaleffects_posterior_interval” = “eti”)\noptions(“marginaleffects_posterior_interval” = “hdi”)\nBy default, the center of the posterior distribution in bayesian models is identified by the median. Users can use a different summary function by setting a global option:\noptions(“marginaleffects_posterior_center” = “mean”)\noptions(“marginaleffects_posterior_center” = “median”)\nWhen estimates are averaged using the by argument, the tidy() function, or the summary() function, the posterior distribution is marginalized twice over. First, we take the average across units but within each iteration of the MCMC chain, according to what the user requested in by argument or tidy()/summary() functions. Then, we identify the center of the resulting posterior using the function supplied to the “marginaleffects_posterior_center” option (the median by default).\n\n\\(\\theta\\) is an estimate, \\(\\sigma_\\theta\\) its estimated standard error, and \\([a, b]\\) are the bounds of the interval supplied to the equivalence argument.\nNon-inferiority:\n\n\n\\(H_0\\): \\(\\theta \\leq a\\)\n\n\n\\(H_1\\): \\(\\theta &gt; a\\)\n\n\n\\(t=(\\theta - a)/\\sigma_\\theta\\)\n\n\np: Upper-tail probability\n\n\nNon-superiority:\n\n\n\\(H_0\\): \\(\\theta \\geq b\\)\n\n\n\\(H_1\\): \\(\\theta &lt; b\\)\n\n\n\\(t=(\\theta - b)/\\sigma_\\theta\\)\n\n\np: Lower-tail probability\n\n\nEquivalence: Two One-Sided Tests (TOST)\n\n\np: Maximum of the non-inferiority and non-superiority p values.\n\n\nThanks to Russell V. Lenth for the excellent emmeans package and documentation which inspired this feature.\n\nThe type argument determines the scale of the predictions used to compute quantities of interest with functions from the marginaleffects package. Admissible values for type depend on the model object. When users specify an incorrect value for type, marginaleffects will raise an informative error with a list of valid type values for the specific model object. The first entry in the list in that error message is the default type.\nThe invlink(link) is a special type defined by marginaleffects. It is available for some (but not all) models, and only for the predictions() function. With this link type, we first compute predictions on the link scale, then we use the inverse link function to backtransform the predictions to the response scale. This is useful for models with non-linear link functions as it can ensure that confidence intervals stay within desirable bounds, ex: 0 to 1 for a logit model. Note that an average of estimates with type=“invlink(link)” will not always be equivalent to the average of estimates with type=“response”. This type is default when calling predictions(). It is available—but not default—when calling avg_predictions() or predictions() with the by argument.\nSome of the most common type values are:\nresponse, link, E, Ep, average, class, conditional, count, cum.prob, cumhaz, cumprob, density, detection, disp, ev, expected, expvalue, fitted, hazard, invlink(link), latent, latent_N, linear, linear.predictor, linpred, location, lp, mean, numeric, p, ppd, pr, precision, prediction, prob, probability, probs, quantile, risk, rmst, scale, survival, unconditional, utility, variance, xb, zero, zlink, zprob\n\nThe slopes() and comparisons() functions can use parallelism to speed up computation. Operations are parallelized for the computation of standard errors, at the model coefficient level. There is always considerable overhead when using parallel computation, mainly involved in passing the whole dataset to the different processes. Thus, parallel computation is most likely to be useful when the model includes many parameters and the dataset is relatively small.\nWarning: In many cases, parallel processing will not be useful at all.\nTo activate parallel computation, users must load the future.apply package, call plan() function, and set a global option. For example:\n\nlibrary(future.apply)\nplan(\"multicore\", workers = 4)\noptions(marginaleffects_parallel = TRUE)\n\nslopes(model)\n\n\nTo disable parallelism in marginaleffects altogether, you can set a global option:\n\noptions(marginaleffects_parallel = FALSE)\n\n\n\nBehind the scenes, the arguments of marginaleffects functions are evaluated in this order:\n\n\nnewdata\n\n\nvariables\n\n\ncomparison and slopes\n\n\nby\n\n\nvcov\n\n\nhypothesis\n\n\ntransform\n\n\nThe behavior of marginaleffects functions can be modified by setting global options.\nDisable some safety checks:\n\noptions(marginaleffects_safe = FALSE)\n\n\nOmit some columns from the printed output:\n\noptions(marginaleffects_print_omit = c(\"p.value\", \"s.value\"))`\n\n\n\n\n\nGreenland S. 2019. \"Valid P-Values Behave Exactly as They Should: Some Misleading Criticisms of P-Values and Their Resolution With S-Values.\" The American Statistician. 73(S1): 106–114.\n\n\nCole, Stephen R, Jessie K Edwards, and Sander Greenland. 2020. \"Surprise!\" American Journal of Epidemiology 190 (2): 191–93. https://doi.org/10.1093/aje/kwaa136\n\n\n\nlibrary(\"marginaleffects\")\n\n\n\n# Unit-level (conditional) Marginal Effects\nmod &lt;- glm(am ~ hp * wt, data = mtcars, family = binomial)\nmfx &lt;- slopes(mod)\nhead(mfx)\n\n# Average Marginal Effect (AME)\navg_slopes(mod, by = TRUE)\n\n\n# Marginal Effect at the Mean (MEM)\nslopes(mod, newdata = datagrid())\n\n# Marginal Effect at User-Specified Values\n# Variables not explicitly included in `datagrid()` are held at their means\nslopes(mod, newdata = datagrid(hp = c(100, 110)))\n\n# Group-Average Marginal Effects (G-AME)\n# Calculate marginal effects for each observation, and then take the average\n# marginal effect within each subset of observations with different observed\n# values for the `cyl` variable:\nmod2 &lt;- lm(mpg ~ hp * cyl, data = mtcars)\navg_slopes(mod2, variables = \"hp\", by = \"cyl\")\n\n# Marginal Effects at User-Specified Values (counterfactual)\n# Variables not explicitly included in `datagrid()` are held at their\n# original values, and the whole dataset is duplicated once for each\n# combination of the values in `datagrid()`\nmfx &lt;- slopes(mod,\n    newdata = datagrid(\n        hp = c(100, 110),\n        grid_type = \"counterfactual\"))\nhead(mfx)\n\n# Heteroskedasticity robust standard errors\nmfx &lt;- slopes(mod, vcov = sandwich::vcovHC(mod))\nhead(mfx)\n\n# hypothesis test: is the `hp` marginal effect at the mean equal to the `drat` marginal effect\nmod &lt;- lm(mpg ~ wt + drat, data = mtcars)\n\nslopes(\n    mod,\n    newdata = \"mean\",\n    hypothesis = \"wt = drat\")\n\n# same hypothesis test using row indices\nslopes(\n    mod,\n    newdata = \"mean\",\n    hypothesis = \"b1 - b2 = 0\")\n\n# same hypothesis test using numeric vector of weights\nslopes(\n    mod,\n    newdata = \"mean\",\n    hypothesis = c(1, -1))\n\n# two custom contrasts using a matrix of weights\nlc &lt;- matrix(\n    c(\n        1, -1,\n        2, 3),\n    ncol = 2)\ncolnames(lc) &lt;- c(\"Contrast A\", \"Contrast B\")\nslopes(\n    mod,\n    newdata = \"mean\",\n    hypothesis = lc)",
    "crumbs": [
      "Model to Meaning",
      "Functions",
      "`slopes`"
    ]
  },
  {
    "objectID": "man/inferences.html",
    "href": "man/inferences.html",
    "title": "",
    "section": "",
    "text": "Warning: This function is experimental. It may be renamed, the user interface may change, or the functionality may migrate to arguments in other marginaleffects functions.\nApply this function to a marginaleffects object to change the inferential method used to compute uncertainty estimates.\n\ninferences(\n  x,\n  method,\n  R = 1000,\n  conf_type = \"perc\",\n  conformal_test = NULL,\n  conformal_calibration = NULL,\n  conformal_score = \"residual_abs\",\n  ...\n)\n\n\n\n\n\nx\n\n\nObject produced by one of the core marginaleffects functions.\n\n\n\n\nmethod\n\n\nString\n\n\n\"delta\": delta method standard errors\n\n\n\"boot\" package\n\n\n\"fwb\": fractional weighted bootstrap\n\n\n\"rsample\" package\n\n\n\"simulation\" from a multivariate normal distribution (Krinsky & Robb, 1986)\n\n\n\"mi\" multiple imputation for missing data\n\n\n\"conformal_split\": prediction intervals using split conformal prediction (see Angelopoulos & Bates, 2022)\n\n\n\"conformal_cv+\": prediction intervals using cross-validation+ conformal prediction (see Barber et al., 2020)\n\n\n\n\n\n\nR\n\n\nNumber of resamples, simulations, or cross-validation folds.\n\n\n\n\nconf_type\n\n\nString: type of bootstrap interval to construct.\n\n\nboot: \"perc\", \"norm\", \"basic\", or \"bca\"\n\n\nfwb: \"perc\", \"norm\", \"basic\", \"bc\", or \"bca\"\n\n\nrsample: \"perc\" or \"bca\"\n\n\nsimulation: argument ignored.\n\n\n\n\n\n\nconformal_test\n\n\nData frame of test data for conformal prediction.\n\n\n\n\nconformal_calibration\n\n\nData frame of calibration data for split conformal prediction (method=“conformal_split).\n\n\n\n\nconformal_score\n\n\nString. Warning: The type argument in predictions() must generate predictions which are on the same scale as the outcome variable. Typically, this means that type must be \"response\" or \"probs\".\n\n\n\"residual_abs\" or \"residual_sq\" for regression tasks (numeric outcome)\n\n\n\"softmax\" for classification tasks (when predictions() returns a group columns, such as multinomial or ordinal logit models.\n\n\n\n\n\n\n…\n\n\n\n\nIf method=“boot”, additional arguments are passed to boot::boot().\n\n\nIf method=“fwb”, additional arguments are passed to fwb::fwb().\n\n\nIf method=“rsample”, additional arguments are passed to rsample::bootstraps().\n\n\nAdditional arguments are ignored for all other methods.\n\n\n\n\n\nWhen method=“simulation”, we conduct simulation-based inference following the method discussed in Krinsky & Robb (1986):\n\n\nDraw R sets of simulated coefficients from a multivariate normal distribution with mean equal to the original model’s estimated coefficients and variance equal to the model’s variance-covariance matrix (classical, \"HC3\", or other).\n\n\nUse the R sets of coefficients to compute R sets of estimands: predictions, comparisons, slopes, or hypotheses.\n\n\nTake quantiles of the resulting distribution of estimands to obtain a confidence interval and the standard deviation of simulated estimates to estimate the standard error.\n\n\nWhen method=“fwb”, drawn weights are supplied to the model fitting function’s weights argument; if the model doesn’t accept non-integer weights, this method should not be used. If weights were included in the original model fit, they are extracted by weights() and multiplied by the drawn weights. These weights are supplied to the wts argument of the estimation function (e.g., comparisons()).\n\nA marginaleffects object with simulation or bootstrap resamples and objects attached.\n\nKrinsky, I., and A. L. Robb. 1986. “On Approximating the Statistical Properties of Elasticities.” Review of Economics and Statistics 68 (4): 715–9.\nKing, Gary, Michael Tomz, and Jason Wittenberg. \"Making the most of statistical analyses: Improving interpretation and presentation.\" American journal of political science (2000): 347-361\nDowd, Bryan E., William H. Greene, and Edward C. Norton. \"Computation of standard errors.\" Health services research 49.2 (2014): 731-750.\nAngelopoulos, Anastasios N., and Stephen Bates. 2022. \"A Gentle Introduction to Conformal Prediction and Distribution-Free Uncertainty Quantification.\" arXiv. https://doi.org/10.48550/arXiv.2107.07511.\nBarber, Rina Foygel, Emmanuel J. Candes, Aaditya Ramdas, and Ryan J. Tibshirani. 2020. “Predictive Inference with the Jackknife+.” arXiv. http://arxiv.org/abs/1905.02928.\n\n\nlibrary(\"marginaleffects\")\n\nlibrary(marginaleffects)\nlibrary(magrittr)\nset.seed(1024)\nmod &lt;- lm(Sepal.Length ~ Sepal.Width * Species, data = iris)\n\n# bootstrap\navg_predictions(mod, by = \"Species\") %&gt;%\n  inferences(method = \"boot\")\n\navg_predictions(mod, by = \"Species\") %&gt;%\n  inferences(method = \"rsample\")\n\n# Fractional (bayesian) bootstrap\navg_slopes(mod, by = \"Species\") %&gt;%\n  inferences(method = \"fwb\") %&gt;%\n  posterior_draws(\"rvar\") %&gt;%\n  data.frame()\n\n# Simulation-based inference\nslopes(mod) %&gt;%\n  inferences(method = \"simulation\") %&gt;%\n  head()",
    "crumbs": [
      "Model to Meaning",
      "Functions",
      "`inferences`"
    ]
  },
  {
    "objectID": "man/inferences.html#experimental-bootstrap-conformal-and-simulation-based-inference",
    "href": "man/inferences.html#experimental-bootstrap-conformal-and-simulation-based-inference",
    "title": "",
    "section": "",
    "text": "Warning: This function is experimental. It may be renamed, the user interface may change, or the functionality may migrate to arguments in other marginaleffects functions.\nApply this function to a marginaleffects object to change the inferential method used to compute uncertainty estimates.\n\ninferences(\n  x,\n  method,\n  R = 1000,\n  conf_type = \"perc\",\n  conformal_test = NULL,\n  conformal_calibration = NULL,\n  conformal_score = \"residual_abs\",\n  ...\n)\n\n\n\n\n\nx\n\n\nObject produced by one of the core marginaleffects functions.\n\n\n\n\nmethod\n\n\nString\n\n\n\"delta\": delta method standard errors\n\n\n\"boot\" package\n\n\n\"fwb\": fractional weighted bootstrap\n\n\n\"rsample\" package\n\n\n\"simulation\" from a multivariate normal distribution (Krinsky & Robb, 1986)\n\n\n\"mi\" multiple imputation for missing data\n\n\n\"conformal_split\": prediction intervals using split conformal prediction (see Angelopoulos & Bates, 2022)\n\n\n\"conformal_cv+\": prediction intervals using cross-validation+ conformal prediction (see Barber et al., 2020)\n\n\n\n\n\n\nR\n\n\nNumber of resamples, simulations, or cross-validation folds.\n\n\n\n\nconf_type\n\n\nString: type of bootstrap interval to construct.\n\n\nboot: \"perc\", \"norm\", \"basic\", or \"bca\"\n\n\nfwb: \"perc\", \"norm\", \"basic\", \"bc\", or \"bca\"\n\n\nrsample: \"perc\" or \"bca\"\n\n\nsimulation: argument ignored.\n\n\n\n\n\n\nconformal_test\n\n\nData frame of test data for conformal prediction.\n\n\n\n\nconformal_calibration\n\n\nData frame of calibration data for split conformal prediction (method=“conformal_split).\n\n\n\n\nconformal_score\n\n\nString. Warning: The type argument in predictions() must generate predictions which are on the same scale as the outcome variable. Typically, this means that type must be \"response\" or \"probs\".\n\n\n\"residual_abs\" or \"residual_sq\" for regression tasks (numeric outcome)\n\n\n\"softmax\" for classification tasks (when predictions() returns a group columns, such as multinomial or ordinal logit models.\n\n\n\n\n\n\n…\n\n\n\n\nIf method=“boot”, additional arguments are passed to boot::boot().\n\n\nIf method=“fwb”, additional arguments are passed to fwb::fwb().\n\n\nIf method=“rsample”, additional arguments are passed to rsample::bootstraps().\n\n\nAdditional arguments are ignored for all other methods.\n\n\n\n\n\nWhen method=“simulation”, we conduct simulation-based inference following the method discussed in Krinsky & Robb (1986):\n\n\nDraw R sets of simulated coefficients from a multivariate normal distribution with mean equal to the original model’s estimated coefficients and variance equal to the model’s variance-covariance matrix (classical, \"HC3\", or other).\n\n\nUse the R sets of coefficients to compute R sets of estimands: predictions, comparisons, slopes, or hypotheses.\n\n\nTake quantiles of the resulting distribution of estimands to obtain a confidence interval and the standard deviation of simulated estimates to estimate the standard error.\n\n\nWhen method=“fwb”, drawn weights are supplied to the model fitting function’s weights argument; if the model doesn’t accept non-integer weights, this method should not be used. If weights were included in the original model fit, they are extracted by weights() and multiplied by the drawn weights. These weights are supplied to the wts argument of the estimation function (e.g., comparisons()).\n\nA marginaleffects object with simulation or bootstrap resamples and objects attached.\n\nKrinsky, I., and A. L. Robb. 1986. “On Approximating the Statistical Properties of Elasticities.” Review of Economics and Statistics 68 (4): 715–9.\nKing, Gary, Michael Tomz, and Jason Wittenberg. \"Making the most of statistical analyses: Improving interpretation and presentation.\" American journal of political science (2000): 347-361\nDowd, Bryan E., William H. Greene, and Edward C. Norton. \"Computation of standard errors.\" Health services research 49.2 (2014): 731-750.\nAngelopoulos, Anastasios N., and Stephen Bates. 2022. \"A Gentle Introduction to Conformal Prediction and Distribution-Free Uncertainty Quantification.\" arXiv. https://doi.org/10.48550/arXiv.2107.07511.\nBarber, Rina Foygel, Emmanuel J. Candes, Aaditya Ramdas, and Ryan J. Tibshirani. 2020. “Predictive Inference with the Jackknife+.” arXiv. http://arxiv.org/abs/1905.02928.\n\n\nlibrary(\"marginaleffects\")\n\nlibrary(marginaleffects)\nlibrary(magrittr)\nset.seed(1024)\nmod &lt;- lm(Sepal.Length ~ Sepal.Width * Species, data = iris)\n\n# bootstrap\navg_predictions(mod, by = \"Species\") %&gt;%\n  inferences(method = \"boot\")\n\navg_predictions(mod, by = \"Species\") %&gt;%\n  inferences(method = \"rsample\")\n\n# Fractional (bayesian) bootstrap\navg_slopes(mod, by = \"Species\") %&gt;%\n  inferences(method = \"fwb\") %&gt;%\n  posterior_draws(\"rvar\") %&gt;%\n  data.frame()\n\n# Simulation-based inference\nslopes(mod) %&gt;%\n  inferences(method = \"simulation\") %&gt;%\n  head()",
    "crumbs": [
      "Model to Meaning",
      "Functions",
      "`inferences`"
    ]
  },
  {
    "objectID": "man/hypotheses.html",
    "href": "man/hypotheses.html",
    "title": "",
    "section": "",
    "text": "Uncertainty estimates are calculated as first-order approximate standard errors for linear or non-linear functions of a vector of random variables with known or estimated covariance matrix. In that sense, hypotheses emulates the behavior of the excellent and well-established car::deltaMethod and car::linearHypothesis functions, but it supports more models; requires fewer dependencies; expands the range of tests to equivalence and superiority/inferiority; and offers convenience features like robust standard errors.\nTo learn more, read the hypothesis tests vignette, visit the package website, or scroll down this page for a full list of vignettes:\n\n\nhttps://marginaleffects.com/vignettes/hypothesis.html\n\n\nhttps://marginaleffects.com/\n\n\nWarning #1: Tests are conducted directly on the scale defined by the type argument. For some models, it can make sense to conduct hypothesis or equivalence tests on the “link” scale instead of the “response” scale which is often the default.\nWarning #2: For hypothesis tests on objects produced by the marginaleffects package, it is safer to use the hypothesis argument of the original function. Using hypotheses() may not work in certain environments, in lists, or when working programmatically with *apply style functions.\nWarning #3: The tests assume that the hypothesis expression is (approximately) normally distributed, which for non-linear functions of the parameters may not be realistic. More reliable confidence intervals can be obtained using the inferences() function with method = “boot”.\n\nhypotheses(\n  model,\n  hypothesis = NULL,\n  vcov = NULL,\n  conf_level = 0.95,\n  df = NULL,\n  equivalence = NULL,\n  joint = FALSE,\n  joint_test = \"f\",\n  numderiv = \"fdforward\",\n  ...\n)\n\n\n\n\n\nmodel\n\n\nModel object or object generated by the comparisons(), slopes(), or predictions() functions.\n\n\n\n\nhypothesis\n\n\nspecify a hypothesis test or custom contrast using a numeric value, vector, or matrix; a string equation; string; a formula, or a function.\n\n\nNumeric:\n\n\nSingle value: the null hypothesis used in the computation of Z and p (before applying transform).\n\n\nVector: Weights to compute a linear combination of (custom contrast between) estimates. Length equal to the number of rows generated by the same function call, but without the hypothesis argument.\n\n\nMatrix: Each column is a vector of weights, as describe above, used to compute a distinct linear combination of (contrast between) estimates. The column names of the matrix are used as labels in the output.\n\n\n\n\nString equation to specify linear or non-linear hypothesis tests. If the term column uniquely identifies rows, terms can be used in the formula. Otherwise, use b1, b2, etc. to identify the position of each parameter. The b* wildcard can be used to test hypotheses on all estimates. If a named vector is used, the names are used as labels in the output. Examples:\n\n\nhp = drat\n\n\nhp + drat = 12\n\n\nb1 + b2 + b3 = 0\n\n\nb* / b1 = 1\n\n\n\n\nString:\n\n\n\"pairwise\": pairwise differences between estimates in each row.\n\n\n\"reference\": differences between the estimates in each row and the estimate in the first row.\n\n\n\"sequential\": difference between an estimate and the estimate in the next row.\n\n\n\"meandev\": difference between an estimate and the mean of all estimates.\n\n\n\"meanotherdev\": difference between an estimate and the mean of all other estimates, excluding the current one.\n\n\n\"revpairwise\", \"revreference\", \"revsequential\": inverse of the corresponding hypotheses, as described above.\n\n\n\n\nFormula:\n\n\ncomparison ~ pairs | group\n\n\nLeft-hand side determines the type of comparison to conduct: difference or ratio. If the left-hand side is empty, difference is chosen.\n\n\nRight-hand side determines the pairs of estimates to compare: reference, sequential, or meandev\n\n\nOptional: Users can supply grouping variables after a vertical bar to conduct comparisons withing subsets.\n\n\nExamples:\n\n\n~ reference\n\n\nratio ~ pairwise\n\n\ndifference ~ pairwise | groupid\n\n\n\n\n\n\nFunction:\n\n\nAccepts an argument x: object produced by a marginaleffects function or a data frame with column rowid and estimate\n\n\nReturns a data frame with columns term and estimate (mandatory) and rowid (optional).\n\n\nThe function can also accept optional input arguments: newdata, by, draws.\n\n\nThis function approach will not work for Bayesian models or with bootstrapping. In those cases, it is easy to use posterior_draws() to extract and manipulate the draws directly.\n\n\n\n\nSee the Examples section below and the vignette: https://marginaleffects.com/vignettes/hypothesis.html\n\n\n\n\n\n\nvcov\n\n\nType of uncertainty estimates to report (e.g., for robust standard errors). Acceptable values:\n\n\nFALSE: Do not compute standard errors. This can speed up computation considerably.\n\n\nTRUE: Unit-level standard errors using the default vcov(model) variance-covariance matrix.\n\n\nString which indicates the kind of uncertainty estimates to return.\n\n\nHeteroskedasticity-consistent: “HC”, “HC0”, “HC1”, “HC2”, “HC3”, “HC4”, “HC4m”, “HC5”. See ?sandwich::vcovHC\n\n\nHeteroskedasticity and autocorrelation consistent: “HAC”\n\n\nMixed-Models degrees of freedom: \"satterthwaite\", \"kenward-roger\"\n\n\nOther: “NeweyWest”, “KernHAC”, “OPG”. See the sandwich package documentation.\n\n\n\n\nOne-sided formula which indicates the name of cluster variables (e.g., ~unit_id). This formula is passed to the cluster argument of the sandwich::vcovCL function.\n\n\nSquare covariance matrix\n\n\nFunction which returns a covariance matrix (e.g., stats::vcov(model))\n\n\n\n\n\n\nconf_level\n\n\nnumeric value between 0 and 1. Confidence level to use to build a confidence interval.\n\n\n\n\ndf\n\n\nDegrees of freedom used to compute p values and confidence intervals. A single numeric value between 1 and Inf. When using joint_test=“f”, the df argument should be a numeric vector of length 2.\n\n\n\n\nequivalence\n\n\nNumeric vector of length 2: bounds used for the two-one-sided test (TOST) of equivalence, and for the non-inferiority and non-superiority tests. See Details section below.\n\n\n\n\njoint\n\n\nJoint test of statistical significance. The null hypothesis value can be set using the hypothesis argument.\n\n\nFALSE: Hypotheses are not tested jointly.\n\n\nTRUE: All parameters are tested jointly.\n\n\nString: A regular expression to match parameters to be tested jointly. grep(joint, perl = TRUE)\n\n\nCharacter vector of parameter names to be tested. Characters refer to the names of the vector returned by coef(object).\n\n\nInteger vector of indices. Which parameters positions to test jointly.\n\n\n\n\n\n\njoint_test\n\n\nA character string specifying the type of test, either \"f\" or \"chisq\". The null hypothesis is set by the hypothesis argument, with default null equal to 0 for all parameters.\n\n\n\n\nnumderiv\n\n\nstring or list of strings indicating the method to use to for the numeric differentiation used in to compute delta method standard errors.\n\n\n\"fdforward\": finite difference method with forward differences\n\n\n\"fdcenter\": finite difference method with central differences (default)\n\n\n\"richardson\": Richardson extrapolation method\n\n\nExtra arguments can be specified by passing a list to the numDeriv argument, with the name of the method first and named arguments following, ex: numderiv=list(“fdcenter”, eps = 1e-5). When an unknown argument is used, marginaleffects prints the list of valid arguments for each method.\n\n\n\n\n\n\n…\n\n\nAdditional arguments are passed to the predict() method supplied by the modeling package.These arguments are particularly useful for mixed-effects or bayesian models (see the online vignettes on the marginaleffects website). Available arguments can vary from model to model, depending on the range of supported arguments by each modeling package. See the \"Model-Specific Arguments\" section of the ?slopes documentation for a non-exhaustive list of available arguments.\n\n\n\nThe test statistic for the joint Wald test is calculated as (R * theta_hat - r)’ * inv(R * V_hat * R’) * (R * theta_hat - r) / Q, where theta_hat is the vector of estimated parameters, V_hat is the estimated covariance matrix, R is a Q x P matrix for testing Q hypotheses on P parameters, r is a Q x 1 vector for the null hypothesis, and Q is the number of rows in R. If the test is a Chi-squared test, the test statistic is not normalized.\nThe p-value is then calculated based on either the F-distribution (for F-test) or the Chi-squared distribution (for Chi-squared test). For the F-test, the degrees of freedom are Q and (n - P), where n is the sample size and P is the number of parameters. For the Chi-squared test, the degrees of freedom are Q.\n\n\\(\\theta\\) is an estimate, \\(\\sigma_\\theta\\) its estimated standard error, and \\([a, b]\\) are the bounds of the interval supplied to the equivalence argument.\nNon-inferiority:\n\n\n\\(H_0\\): \\(\\theta \\leq a\\)\n\n\n\\(H_1\\): \\(\\theta &gt; a\\)\n\n\n\\(t=(\\theta - a)/\\sigma_\\theta\\)\n\n\np: Upper-tail probability\n\n\nNon-superiority:\n\n\n\\(H_0\\): \\(\\theta \\geq b\\)\n\n\n\\(H_1\\): \\(\\theta &lt; b\\)\n\n\n\\(t=(\\theta - b)/\\sigma_\\theta\\)\n\n\np: Lower-tail probability\n\n\nEquivalence: Two One-Sided Tests (TOST)\n\n\np: Maximum of the non-inferiority and non-superiority p values.\n\n\nThanks to Russell V. Lenth for the excellent emmeans package and documentation which inspired this feature.\n\n\nlibrary(\"marginaleffects\")\n\nlibrary(marginaleffects)\nmod &lt;- lm(mpg ~ hp + wt + factor(cyl), data = mtcars)\n\nhypotheses(mod)\n\n\n         Term Estimate Std. Error     z Pr(&gt;|z|)     S   2.5 %    97.5 %\n (Intercept)   35.8460      2.041 17.56   &lt;0.001 227.0 31.8457 39.846319\n hp            -0.0231      0.012 -1.93   0.0531   4.2 -0.0465  0.000306\n wt            -3.1814      0.720 -4.42   &lt;0.001  16.6 -4.5918 -1.771012\n factor(cyl)6  -3.3590      1.402 -2.40   0.0166   5.9 -6.1062 -0.611803\n factor(cyl)8  -3.1859      2.170 -1.47   0.1422   2.8 -7.4399  1.068169\n\nColumns: term, estimate, std.error, statistic, p.value, s.value, conf.low, conf.high \n\n# Test of equality between coefficients\nhypotheses(mod, hypothesis = \"hp = wt\")\n\n\n Estimate Std. Error    z Pr(&gt;|z|)    S 2.5 % 97.5 %\n     3.16       0.72 4.39   &lt;0.001 16.4  1.75   4.57\n\nTerm: hp = wt\nColumns: term, estimate, std.error, statistic, p.value, s.value, conf.low, conf.high \n\n# Non-linear function\nhypotheses(mod, hypothesis = \"exp(hp + wt) = 0.1\")\n\n\n Estimate Std. Error     z Pr(&gt;|z|)   S  2.5 %  97.5 %\n  -0.0594     0.0292 -2.04   0.0418 4.6 -0.117 -0.0022\n\nTerm: exp(hp + wt) = 0.1\nColumns: term, estimate, std.error, statistic, p.value, s.value, conf.low, conf.high \n\n# Robust standard errors\nhypotheses(mod, hypothesis = \"hp = wt\", vcov = \"HC3\")\n\n\n Estimate Std. Error    z Pr(&gt;|z|)    S 2.5 % 97.5 %\n     3.16      0.805 3.92   &lt;0.001 13.5  1.58   4.74\n\nTerm: hp = wt\nColumns: term, estimate, std.error, statistic, p.value, s.value, conf.low, conf.high \n\n# b1, b2, ... shortcuts can be used to identify the position of the\n# parameters of interest in the output of\nhypotheses(mod, hypothesis = \"b2 = b3\")\n\n\n Estimate Std. Error    z Pr(&gt;|z|)    S 2.5 % 97.5 %\n     3.16       0.72 4.39   &lt;0.001 16.4  1.75   4.57\n\nTerm: b2 = b3\nColumns: term, estimate, std.error, statistic, p.value, s.value, conf.low, conf.high \n\n# wildcard\nhypotheses(mod, hypothesis = \"b* / b2 = 1\")\n\n\n        Term Estimate Std. Error     z Pr(&gt;|z|)   S   2.5 % 97.5 %\n b1 / b2 = 1    -1551      764.0 -2.03   0.0423 4.6 -3048.9    -54\n b2 / b2 = 1        0         NA    NA       NA  NA      NA     NA\n b3 / b2 = 1      137       78.1  1.75   0.0804 3.6   -16.6    290\n b4 / b2 = 1      144      111.0  1.30   0.1938 2.4   -73.3    362\n b5 / b2 = 1      137      151.9  0.90   0.3679 1.4  -161.0    435\n\nColumns: term, estimate, std.error, statistic, p.value, s.value, conf.low, conf.high \n\n# term names with special characters have to be enclosed in backticks\nhypotheses(mod, hypothesis = \"`factor(cyl)6` = `factor(cyl)8`\")\n\n\n Estimate Std. Error      z Pr(&gt;|z|)   S 2.5 % 97.5 %\n   -0.173       1.65 -0.105    0.917 0.1 -3.41   3.07\n\nTerm: `factor(cyl)6` = `factor(cyl)8`\nColumns: term, estimate, std.error, statistic, p.value, s.value, conf.low, conf.high \n\nmod2 &lt;- lm(mpg ~ hp * drat, data = mtcars)\nhypotheses(mod2, hypothesis = \"`hp:drat` = drat\")\n\n\n Estimate Std. Error    z Pr(&gt;|z|)   S 2.5 % 97.5 %\n    -6.08       2.89 -2.1   0.0357 4.8 -11.8 -0.405\n\nTerm: `hp:drat` = drat\nColumns: term, estimate, std.error, statistic, p.value, s.value, conf.low, conf.high \n\n# predictions(), comparisons(), and slopes()\nmod &lt;- glm(am ~ hp + mpg, data = mtcars, family = binomial)\ncmp &lt;- comparisons(mod, newdata = \"mean\")\nhypotheses(cmp, hypothesis = \"b1 = b2\")\n\n\n Estimate Std. Error    z Pr(&gt;|z|)   S  2.5 %  97.5 %\n    -0.28      0.104 -2.7  0.00684 7.2 -0.483 -0.0771\n\nTerm: b1=b2\nType:  response \nColumns: term, estimate, std.error, statistic, p.value, s.value, conf.low, conf.high \n\nmfx &lt;- slopes(mod, newdata = \"mean\")\nhypotheses(cmp, hypothesis = \"b2 = 0.2\")\n\n\n Estimate Std. Error     z Pr(&gt;|z|)   S  2.5 % 97.5 %\n   0.0938      0.109 0.857    0.391 1.4 -0.121  0.308\n\nTerm: b2=0.2\nType:  response \nColumns: term, estimate, std.error, statistic, p.value, s.value, conf.low, conf.high \n\npre &lt;- predictions(mod, newdata = datagrid(hp = 110, mpg = c(30, 35)))\nhypotheses(pre, hypothesis = \"b1 = b2\")\n\n\n  Estimate Std. Error      z Pr(&gt;|z|)   S     2.5 %   97.5 %\n -3.57e-05   0.000172 -0.207    0.836 0.3 -0.000373 0.000302\n\nTerm: b1=b2\nType:  response \nColumns: term, estimate, std.error, statistic, p.value, s.value, conf.low, conf.high \n\n# The `hypothesis` argument can be used to compute standard errors for fitted values\nmod &lt;- glm(am ~ hp + mpg, data = mtcars, family = binomial)\n\nf &lt;- function(x) predict(x, type = \"link\", newdata = mtcars)\np &lt;- hypotheses(mod, hypothesis = f)\nhead(p)\n\n\n Term Estimate Std. Error      z Pr(&gt;|z|)   S 2.5 % 97.5 %\n    1   -1.098      0.716 -1.534    0.125 3.0 -2.50  0.305\n    2   -1.098      0.716 -1.534    0.125 3.0 -2.50  0.305\n    3    0.233      0.781  0.299    0.765 0.4 -1.30  1.764\n    4   -0.595      0.647 -0.919    0.358 1.5 -1.86  0.674\n    5   -0.418      0.647 -0.645    0.519 0.9 -1.69  0.851\n    6   -5.026      2.195 -2.290    0.022 5.5 -9.33 -0.725\n\nColumns: term, estimate, std.error, statistic, p.value, s.value, conf.low, conf.high \n\nf &lt;- function(x) predict(x, type = \"response\", newdata = mtcars)\np &lt;- hypotheses(mod, hypothesis = f)\nhead(p)\n\n\n Term Estimate Std. Error     z Pr(&gt;|z|)   S   2.5 % 97.5 %\n    1  0.25005     0.1343 1.862  0.06257 4.0 -0.0131 0.5132\n    2  0.25005     0.1343 1.862  0.06257 4.0 -0.0131 0.5132\n    3  0.55803     0.1926 2.898  0.00376 8.1  0.1806 0.9355\n    4  0.35560     0.1483 2.398  0.01648 5.9  0.0650 0.6462\n    5  0.39710     0.1550 2.562  0.01041 6.6  0.0933 0.7009\n    6  0.00652     0.0142 0.459  0.64653 0.6 -0.0213 0.0344\n\nColumns: term, estimate, std.error, statistic, p.value, s.value, conf.low, conf.high \n\n# Complex aggregation\n# Step 1: Collapse predicted probabilities by outcome level, for each individual\n# Step 2: Take the mean of the collapsed probabilities by group and `cyl`\nlibrary(dplyr)\nlibrary(MASS)\nlibrary(dplyr)\n\ndat &lt;- transform(mtcars, gear = factor(gear))\nmod &lt;- polr(gear ~ factor(cyl) + hp, dat)\n\naggregation_fun &lt;- function(x) {\n    predictions(x, vcov = FALSE) |&gt;\n        mutate(group = ifelse(group %in% c(\"3\", \"4\"), \"3 & 4\", \"5\")) |&gt;\n        summarize(estimate = sum(estimate), .by = c(\"rowid\", \"cyl\", \"group\")) |&gt;\n        summarize(estimate = mean(estimate), .by = c(\"cyl\", \"group\")) |&gt;\n        rename(term = cyl)\n}\n\nhypotheses(mod, hypothesis = aggregation_fun)\n\n\n Group Term Estimate Std. Error     z Pr(&gt;|z|)     S  2.5 % 97.5 %\n 3 & 4    6   0.8390     0.0651 12.89   &lt;0.001 123.9 0.7115  0.967\n 3 & 4    4   0.7197     0.1099  6.55   &lt;0.001  34.0 0.5044  0.935\n 3 & 4    8   0.9283     0.0174 53.45   &lt;0.001   Inf 0.8943  0.962\n 5        6   0.1610     0.0651  2.47   0.0134   6.2 0.0334  0.289\n 5        4   0.2803     0.1099  2.55   0.0108   6.5 0.0649  0.496\n 5        8   0.0717     0.0174  4.13   &lt;0.001  14.7 0.0377  0.106\n\nColumns: term, group, estimate, std.error, statistic, p.value, s.value, conf.low, conf.high \n\n# Equivalence, non-inferiority, and non-superiority tests\nmod &lt;- lm(mpg ~ hp + factor(gear), data = mtcars)\np &lt;- predictions(mod, newdata = \"median\")\nhypotheses(p, equivalence = c(17, 18))\n\n\n Estimate Std. Error    z Pr(&gt;|z|)     S 2.5 % 97.5 % p (NonSup) p (NonInf)\n     19.7          1 19.6   &lt;0.001 281.3  17.7   21.6      0.951    0.00404\n p (Equiv)  hp gear\n     0.951 123    3\n\nType:  response \nColumns: rowid, estimate, std.error, statistic, p.value, s.value, conf.low, conf.high, hp, gear, mpg, statistic.noninf, statistic.nonsup, p.value.noninf, p.value.nonsup, p.value.equiv \n\nmfx &lt;- avg_slopes(mod, variables = \"hp\")\nhypotheses(mfx, equivalence = c(-.1, .1))\n\n\n Estimate Std. Error     z Pr(&gt;|z|)    S   2.5 %  97.5 % p (NonSup) p (NonInf)\n  -0.0669      0.011 -6.05   &lt;0.001 29.4 -0.0885 -0.0452     &lt;0.001    0.00135\n p (Equiv)\n   0.00135\n\nTerm: hp\nType:  response \nComparison: mean(dY/dX)\nColumns: term, contrast, estimate, std.error, statistic, p.value, s.value, conf.low, conf.high, predicted_lo, predicted_hi, predicted, statistic.noninf, statistic.nonsup, p.value.noninf, p.value.nonsup, p.value.equiv \n\ncmp &lt;- avg_comparisons(mod, variables = \"gear\", hypothesis = \"pairwise\")\nhypotheses(cmp, equivalence = c(0, 10))\n\n\n Estimate Std. Error     z Pr(&gt;|z|)   S 2.5 % 97.5 % p (NonSup) p (NonInf)\n    -3.94       2.05 -1.92   0.0543 4.2 -7.95 0.0727     &lt;0.001      0.973\n p (Equiv)\n     0.973\n\nTerm: (mean(4) - mean(3)) - (mean(5) - mean(3))\nType:  response \nColumns: term, estimate, std.error, statistic, p.value, s.value, conf.low, conf.high, statistic.noninf, statistic.nonsup, p.value.noninf, p.value.nonsup, p.value.equiv \n\n# joint hypotheses: character vector\nmodel &lt;- lm(mpg ~ as.factor(cyl) * hp, data = mtcars)\nhypotheses(model, joint = c(\"as.factor(cyl)6:hp\", \"as.factor(cyl)8:hp\"))\n\n\n\nJoint hypothesis test:\nas.factor(cyl)6:hp = 0\nas.factor(cyl)8:hp = 0\n \n    F Pr(&gt;|F|) Df 1 Df 2\n 2.11    0.142    2   26\n\nColumns: statistic, p.value, df1, df2 \n\n# joint hypotheses: regular expression\nhypotheses(model, joint = \"cyl\")\n\n\n\nJoint hypothesis test:\n as.factor(cyl)6 = 0\n as.factor(cyl)8 = 0\n as.factor(cyl)6:hp = 0\n as.factor(cyl)8:hp = 0\n \n   F Pr(&gt;|F|) Df 1 Df 2\n 5.7  0.00197    4   26\n\nColumns: statistic, p.value, df1, df2 \n\n# joint hypotheses: integer indices\nhypotheses(model, joint = 2:3)\n\n\n\nJoint hypothesis test:\n as.factor(cyl)6 = 0\n as.factor(cyl)8 = 0\n \n    F Pr(&gt;|F|) Df 1 Df 2\n 6.12  0.00665    2   26\n\nColumns: statistic, p.value, df1, df2 \n\n# joint hypotheses: different null hypotheses\nhypotheses(model, joint = 2:3, hypothesis = 1)\n\n\n\nJoint hypothesis test:\n as.factor(cyl)6 = 1\n as.factor(cyl)8 = 1\n \n    F Pr(&gt;|F|) Df 1 Df 2\n 6.84  0.00411    2   26\n\nColumns: statistic, p.value, df1, df2 \n\nhypotheses(model, joint = 2:3, hypothesis = 1:2)\n\n\n\nJoint hypothesis test:\n as.factor(cyl)6 = 1\n as.factor(cyl)8 = 2\n \n    F Pr(&gt;|F|) Df 1 Df 2\n 7.47  0.00273    2   26\n\nColumns: statistic, p.value, df1, df2 \n\n# joint hypotheses: marginaleffects object\ncmp &lt;- avg_comparisons(model)\nhypotheses(cmp, joint = \"cyl\")\n\n\n\nJoint hypothesis test:\n cyl mean(6) - mean(4) = 0\n cyl mean(8) - mean(4) = 0\n \n   F Pr(&gt;|F|) Df 1 Df 2\n 1.6    0.221    2   26\n\nColumns: statistic, p.value, df1, df2",
    "crumbs": [
      "Model to Meaning",
      "Functions",
      "`hypotheses`"
    ]
  },
  {
    "objectID": "man/hypotheses.html#non-linear-tests-for-null-hypotheses-joint-hypotheses-equivalence-non-superiority-and-non-inferiority",
    "href": "man/hypotheses.html#non-linear-tests-for-null-hypotheses-joint-hypotheses-equivalence-non-superiority-and-non-inferiority",
    "title": "",
    "section": "",
    "text": "Uncertainty estimates are calculated as first-order approximate standard errors for linear or non-linear functions of a vector of random variables with known or estimated covariance matrix. In that sense, hypotheses emulates the behavior of the excellent and well-established car::deltaMethod and car::linearHypothesis functions, but it supports more models; requires fewer dependencies; expands the range of tests to equivalence and superiority/inferiority; and offers convenience features like robust standard errors.\nTo learn more, read the hypothesis tests vignette, visit the package website, or scroll down this page for a full list of vignettes:\n\n\nhttps://marginaleffects.com/vignettes/hypothesis.html\n\n\nhttps://marginaleffects.com/\n\n\nWarning #1: Tests are conducted directly on the scale defined by the type argument. For some models, it can make sense to conduct hypothesis or equivalence tests on the “link” scale instead of the “response” scale which is often the default.\nWarning #2: For hypothesis tests on objects produced by the marginaleffects package, it is safer to use the hypothesis argument of the original function. Using hypotheses() may not work in certain environments, in lists, or when working programmatically with *apply style functions.\nWarning #3: The tests assume that the hypothesis expression is (approximately) normally distributed, which for non-linear functions of the parameters may not be realistic. More reliable confidence intervals can be obtained using the inferences() function with method = “boot”.\n\nhypotheses(\n  model,\n  hypothesis = NULL,\n  vcov = NULL,\n  conf_level = 0.95,\n  df = NULL,\n  equivalence = NULL,\n  joint = FALSE,\n  joint_test = \"f\",\n  numderiv = \"fdforward\",\n  ...\n)\n\n\n\n\n\nmodel\n\n\nModel object or object generated by the comparisons(), slopes(), or predictions() functions.\n\n\n\n\nhypothesis\n\n\nspecify a hypothesis test or custom contrast using a numeric value, vector, or matrix; a string equation; string; a formula, or a function.\n\n\nNumeric:\n\n\nSingle value: the null hypothesis used in the computation of Z and p (before applying transform).\n\n\nVector: Weights to compute a linear combination of (custom contrast between) estimates. Length equal to the number of rows generated by the same function call, but without the hypothesis argument.\n\n\nMatrix: Each column is a vector of weights, as describe above, used to compute a distinct linear combination of (contrast between) estimates. The column names of the matrix are used as labels in the output.\n\n\n\n\nString equation to specify linear or non-linear hypothesis tests. If the term column uniquely identifies rows, terms can be used in the formula. Otherwise, use b1, b2, etc. to identify the position of each parameter. The b* wildcard can be used to test hypotheses on all estimates. If a named vector is used, the names are used as labels in the output. Examples:\n\n\nhp = drat\n\n\nhp + drat = 12\n\n\nb1 + b2 + b3 = 0\n\n\nb* / b1 = 1\n\n\n\n\nString:\n\n\n\"pairwise\": pairwise differences between estimates in each row.\n\n\n\"reference\": differences between the estimates in each row and the estimate in the first row.\n\n\n\"sequential\": difference between an estimate and the estimate in the next row.\n\n\n\"meandev\": difference between an estimate and the mean of all estimates.\n\n\n\"meanotherdev\": difference between an estimate and the mean of all other estimates, excluding the current one.\n\n\n\"revpairwise\", \"revreference\", \"revsequential\": inverse of the corresponding hypotheses, as described above.\n\n\n\n\nFormula:\n\n\ncomparison ~ pairs | group\n\n\nLeft-hand side determines the type of comparison to conduct: difference or ratio. If the left-hand side is empty, difference is chosen.\n\n\nRight-hand side determines the pairs of estimates to compare: reference, sequential, or meandev\n\n\nOptional: Users can supply grouping variables after a vertical bar to conduct comparisons withing subsets.\n\n\nExamples:\n\n\n~ reference\n\n\nratio ~ pairwise\n\n\ndifference ~ pairwise | groupid\n\n\n\n\n\n\nFunction:\n\n\nAccepts an argument x: object produced by a marginaleffects function or a data frame with column rowid and estimate\n\n\nReturns a data frame with columns term and estimate (mandatory) and rowid (optional).\n\n\nThe function can also accept optional input arguments: newdata, by, draws.\n\n\nThis function approach will not work for Bayesian models or with bootstrapping. In those cases, it is easy to use posterior_draws() to extract and manipulate the draws directly.\n\n\n\n\nSee the Examples section below and the vignette: https://marginaleffects.com/vignettes/hypothesis.html\n\n\n\n\n\n\nvcov\n\n\nType of uncertainty estimates to report (e.g., for robust standard errors). Acceptable values:\n\n\nFALSE: Do not compute standard errors. This can speed up computation considerably.\n\n\nTRUE: Unit-level standard errors using the default vcov(model) variance-covariance matrix.\n\n\nString which indicates the kind of uncertainty estimates to return.\n\n\nHeteroskedasticity-consistent: “HC”, “HC0”, “HC1”, “HC2”, “HC3”, “HC4”, “HC4m”, “HC5”. See ?sandwich::vcovHC\n\n\nHeteroskedasticity and autocorrelation consistent: “HAC”\n\n\nMixed-Models degrees of freedom: \"satterthwaite\", \"kenward-roger\"\n\n\nOther: “NeweyWest”, “KernHAC”, “OPG”. See the sandwich package documentation.\n\n\n\n\nOne-sided formula which indicates the name of cluster variables (e.g., ~unit_id). This formula is passed to the cluster argument of the sandwich::vcovCL function.\n\n\nSquare covariance matrix\n\n\nFunction which returns a covariance matrix (e.g., stats::vcov(model))\n\n\n\n\n\n\nconf_level\n\n\nnumeric value between 0 and 1. Confidence level to use to build a confidence interval.\n\n\n\n\ndf\n\n\nDegrees of freedom used to compute p values and confidence intervals. A single numeric value between 1 and Inf. When using joint_test=“f”, the df argument should be a numeric vector of length 2.\n\n\n\n\nequivalence\n\n\nNumeric vector of length 2: bounds used for the two-one-sided test (TOST) of equivalence, and for the non-inferiority and non-superiority tests. See Details section below.\n\n\n\n\njoint\n\n\nJoint test of statistical significance. The null hypothesis value can be set using the hypothesis argument.\n\n\nFALSE: Hypotheses are not tested jointly.\n\n\nTRUE: All parameters are tested jointly.\n\n\nString: A regular expression to match parameters to be tested jointly. grep(joint, perl = TRUE)\n\n\nCharacter vector of parameter names to be tested. Characters refer to the names of the vector returned by coef(object).\n\n\nInteger vector of indices. Which parameters positions to test jointly.\n\n\n\n\n\n\njoint_test\n\n\nA character string specifying the type of test, either \"f\" or \"chisq\". The null hypothesis is set by the hypothesis argument, with default null equal to 0 for all parameters.\n\n\n\n\nnumderiv\n\n\nstring or list of strings indicating the method to use to for the numeric differentiation used in to compute delta method standard errors.\n\n\n\"fdforward\": finite difference method with forward differences\n\n\n\"fdcenter\": finite difference method with central differences (default)\n\n\n\"richardson\": Richardson extrapolation method\n\n\nExtra arguments can be specified by passing a list to the numDeriv argument, with the name of the method first and named arguments following, ex: numderiv=list(“fdcenter”, eps = 1e-5). When an unknown argument is used, marginaleffects prints the list of valid arguments for each method.\n\n\n\n\n\n\n…\n\n\nAdditional arguments are passed to the predict() method supplied by the modeling package.These arguments are particularly useful for mixed-effects or bayesian models (see the online vignettes on the marginaleffects website). Available arguments can vary from model to model, depending on the range of supported arguments by each modeling package. See the \"Model-Specific Arguments\" section of the ?slopes documentation for a non-exhaustive list of available arguments.\n\n\n\nThe test statistic for the joint Wald test is calculated as (R * theta_hat - r)’ * inv(R * V_hat * R’) * (R * theta_hat - r) / Q, where theta_hat is the vector of estimated parameters, V_hat is the estimated covariance matrix, R is a Q x P matrix for testing Q hypotheses on P parameters, r is a Q x 1 vector for the null hypothesis, and Q is the number of rows in R. If the test is a Chi-squared test, the test statistic is not normalized.\nThe p-value is then calculated based on either the F-distribution (for F-test) or the Chi-squared distribution (for Chi-squared test). For the F-test, the degrees of freedom are Q and (n - P), where n is the sample size and P is the number of parameters. For the Chi-squared test, the degrees of freedom are Q.\n\n\\(\\theta\\) is an estimate, \\(\\sigma_\\theta\\) its estimated standard error, and \\([a, b]\\) are the bounds of the interval supplied to the equivalence argument.\nNon-inferiority:\n\n\n\\(H_0\\): \\(\\theta \\leq a\\)\n\n\n\\(H_1\\): \\(\\theta &gt; a\\)\n\n\n\\(t=(\\theta - a)/\\sigma_\\theta\\)\n\n\np: Upper-tail probability\n\n\nNon-superiority:\n\n\n\\(H_0\\): \\(\\theta \\geq b\\)\n\n\n\\(H_1\\): \\(\\theta &lt; b\\)\n\n\n\\(t=(\\theta - b)/\\sigma_\\theta\\)\n\n\np: Lower-tail probability\n\n\nEquivalence: Two One-Sided Tests (TOST)\n\n\np: Maximum of the non-inferiority and non-superiority p values.\n\n\nThanks to Russell V. Lenth for the excellent emmeans package and documentation which inspired this feature.\n\n\nlibrary(\"marginaleffects\")\n\nlibrary(marginaleffects)\nmod &lt;- lm(mpg ~ hp + wt + factor(cyl), data = mtcars)\n\nhypotheses(mod)\n\n\n         Term Estimate Std. Error     z Pr(&gt;|z|)     S   2.5 %    97.5 %\n (Intercept)   35.8460      2.041 17.56   &lt;0.001 227.0 31.8457 39.846319\n hp            -0.0231      0.012 -1.93   0.0531   4.2 -0.0465  0.000306\n wt            -3.1814      0.720 -4.42   &lt;0.001  16.6 -4.5918 -1.771012\n factor(cyl)6  -3.3590      1.402 -2.40   0.0166   5.9 -6.1062 -0.611803\n factor(cyl)8  -3.1859      2.170 -1.47   0.1422   2.8 -7.4399  1.068169\n\nColumns: term, estimate, std.error, statistic, p.value, s.value, conf.low, conf.high \n\n# Test of equality between coefficients\nhypotheses(mod, hypothesis = \"hp = wt\")\n\n\n Estimate Std. Error    z Pr(&gt;|z|)    S 2.5 % 97.5 %\n     3.16       0.72 4.39   &lt;0.001 16.4  1.75   4.57\n\nTerm: hp = wt\nColumns: term, estimate, std.error, statistic, p.value, s.value, conf.low, conf.high \n\n# Non-linear function\nhypotheses(mod, hypothesis = \"exp(hp + wt) = 0.1\")\n\n\n Estimate Std. Error     z Pr(&gt;|z|)   S  2.5 %  97.5 %\n  -0.0594     0.0292 -2.04   0.0418 4.6 -0.117 -0.0022\n\nTerm: exp(hp + wt) = 0.1\nColumns: term, estimate, std.error, statistic, p.value, s.value, conf.low, conf.high \n\n# Robust standard errors\nhypotheses(mod, hypothesis = \"hp = wt\", vcov = \"HC3\")\n\n\n Estimate Std. Error    z Pr(&gt;|z|)    S 2.5 % 97.5 %\n     3.16      0.805 3.92   &lt;0.001 13.5  1.58   4.74\n\nTerm: hp = wt\nColumns: term, estimate, std.error, statistic, p.value, s.value, conf.low, conf.high \n\n# b1, b2, ... shortcuts can be used to identify the position of the\n# parameters of interest in the output of\nhypotheses(mod, hypothesis = \"b2 = b3\")\n\n\n Estimate Std. Error    z Pr(&gt;|z|)    S 2.5 % 97.5 %\n     3.16       0.72 4.39   &lt;0.001 16.4  1.75   4.57\n\nTerm: b2 = b3\nColumns: term, estimate, std.error, statistic, p.value, s.value, conf.low, conf.high \n\n# wildcard\nhypotheses(mod, hypothesis = \"b* / b2 = 1\")\n\n\n        Term Estimate Std. Error     z Pr(&gt;|z|)   S   2.5 % 97.5 %\n b1 / b2 = 1    -1551      764.0 -2.03   0.0423 4.6 -3048.9    -54\n b2 / b2 = 1        0         NA    NA       NA  NA      NA     NA\n b3 / b2 = 1      137       78.1  1.75   0.0804 3.6   -16.6    290\n b4 / b2 = 1      144      111.0  1.30   0.1938 2.4   -73.3    362\n b5 / b2 = 1      137      151.9  0.90   0.3679 1.4  -161.0    435\n\nColumns: term, estimate, std.error, statistic, p.value, s.value, conf.low, conf.high \n\n# term names with special characters have to be enclosed in backticks\nhypotheses(mod, hypothesis = \"`factor(cyl)6` = `factor(cyl)8`\")\n\n\n Estimate Std. Error      z Pr(&gt;|z|)   S 2.5 % 97.5 %\n   -0.173       1.65 -0.105    0.917 0.1 -3.41   3.07\n\nTerm: `factor(cyl)6` = `factor(cyl)8`\nColumns: term, estimate, std.error, statistic, p.value, s.value, conf.low, conf.high \n\nmod2 &lt;- lm(mpg ~ hp * drat, data = mtcars)\nhypotheses(mod2, hypothesis = \"`hp:drat` = drat\")\n\n\n Estimate Std. Error    z Pr(&gt;|z|)   S 2.5 % 97.5 %\n    -6.08       2.89 -2.1   0.0357 4.8 -11.8 -0.405\n\nTerm: `hp:drat` = drat\nColumns: term, estimate, std.error, statistic, p.value, s.value, conf.low, conf.high \n\n# predictions(), comparisons(), and slopes()\nmod &lt;- glm(am ~ hp + mpg, data = mtcars, family = binomial)\ncmp &lt;- comparisons(mod, newdata = \"mean\")\nhypotheses(cmp, hypothesis = \"b1 = b2\")\n\n\n Estimate Std. Error    z Pr(&gt;|z|)   S  2.5 %  97.5 %\n    -0.28      0.104 -2.7  0.00684 7.2 -0.483 -0.0771\n\nTerm: b1=b2\nType:  response \nColumns: term, estimate, std.error, statistic, p.value, s.value, conf.low, conf.high \n\nmfx &lt;- slopes(mod, newdata = \"mean\")\nhypotheses(cmp, hypothesis = \"b2 = 0.2\")\n\n\n Estimate Std. Error     z Pr(&gt;|z|)   S  2.5 % 97.5 %\n   0.0938      0.109 0.857    0.391 1.4 -0.121  0.308\n\nTerm: b2=0.2\nType:  response \nColumns: term, estimate, std.error, statistic, p.value, s.value, conf.low, conf.high \n\npre &lt;- predictions(mod, newdata = datagrid(hp = 110, mpg = c(30, 35)))\nhypotheses(pre, hypothesis = \"b1 = b2\")\n\n\n  Estimate Std. Error      z Pr(&gt;|z|)   S     2.5 %   97.5 %\n -3.57e-05   0.000172 -0.207    0.836 0.3 -0.000373 0.000302\n\nTerm: b1=b2\nType:  response \nColumns: term, estimate, std.error, statistic, p.value, s.value, conf.low, conf.high \n\n# The `hypothesis` argument can be used to compute standard errors for fitted values\nmod &lt;- glm(am ~ hp + mpg, data = mtcars, family = binomial)\n\nf &lt;- function(x) predict(x, type = \"link\", newdata = mtcars)\np &lt;- hypotheses(mod, hypothesis = f)\nhead(p)\n\n\n Term Estimate Std. Error      z Pr(&gt;|z|)   S 2.5 % 97.5 %\n    1   -1.098      0.716 -1.534    0.125 3.0 -2.50  0.305\n    2   -1.098      0.716 -1.534    0.125 3.0 -2.50  0.305\n    3    0.233      0.781  0.299    0.765 0.4 -1.30  1.764\n    4   -0.595      0.647 -0.919    0.358 1.5 -1.86  0.674\n    5   -0.418      0.647 -0.645    0.519 0.9 -1.69  0.851\n    6   -5.026      2.195 -2.290    0.022 5.5 -9.33 -0.725\n\nColumns: term, estimate, std.error, statistic, p.value, s.value, conf.low, conf.high \n\nf &lt;- function(x) predict(x, type = \"response\", newdata = mtcars)\np &lt;- hypotheses(mod, hypothesis = f)\nhead(p)\n\n\n Term Estimate Std. Error     z Pr(&gt;|z|)   S   2.5 % 97.5 %\n    1  0.25005     0.1343 1.862  0.06257 4.0 -0.0131 0.5132\n    2  0.25005     0.1343 1.862  0.06257 4.0 -0.0131 0.5132\n    3  0.55803     0.1926 2.898  0.00376 8.1  0.1806 0.9355\n    4  0.35560     0.1483 2.398  0.01648 5.9  0.0650 0.6462\n    5  0.39710     0.1550 2.562  0.01041 6.6  0.0933 0.7009\n    6  0.00652     0.0142 0.459  0.64653 0.6 -0.0213 0.0344\n\nColumns: term, estimate, std.error, statistic, p.value, s.value, conf.low, conf.high \n\n# Complex aggregation\n# Step 1: Collapse predicted probabilities by outcome level, for each individual\n# Step 2: Take the mean of the collapsed probabilities by group and `cyl`\nlibrary(dplyr)\nlibrary(MASS)\nlibrary(dplyr)\n\ndat &lt;- transform(mtcars, gear = factor(gear))\nmod &lt;- polr(gear ~ factor(cyl) + hp, dat)\n\naggregation_fun &lt;- function(x) {\n    predictions(x, vcov = FALSE) |&gt;\n        mutate(group = ifelse(group %in% c(\"3\", \"4\"), \"3 & 4\", \"5\")) |&gt;\n        summarize(estimate = sum(estimate), .by = c(\"rowid\", \"cyl\", \"group\")) |&gt;\n        summarize(estimate = mean(estimate), .by = c(\"cyl\", \"group\")) |&gt;\n        rename(term = cyl)\n}\n\nhypotheses(mod, hypothesis = aggregation_fun)\n\n\n Group Term Estimate Std. Error     z Pr(&gt;|z|)     S  2.5 % 97.5 %\n 3 & 4    6   0.8390     0.0651 12.89   &lt;0.001 123.9 0.7115  0.967\n 3 & 4    4   0.7197     0.1099  6.55   &lt;0.001  34.0 0.5044  0.935\n 3 & 4    8   0.9283     0.0174 53.45   &lt;0.001   Inf 0.8943  0.962\n 5        6   0.1610     0.0651  2.47   0.0134   6.2 0.0334  0.289\n 5        4   0.2803     0.1099  2.55   0.0108   6.5 0.0649  0.496\n 5        8   0.0717     0.0174  4.13   &lt;0.001  14.7 0.0377  0.106\n\nColumns: term, group, estimate, std.error, statistic, p.value, s.value, conf.low, conf.high \n\n# Equivalence, non-inferiority, and non-superiority tests\nmod &lt;- lm(mpg ~ hp + factor(gear), data = mtcars)\np &lt;- predictions(mod, newdata = \"median\")\nhypotheses(p, equivalence = c(17, 18))\n\n\n Estimate Std. Error    z Pr(&gt;|z|)     S 2.5 % 97.5 % p (NonSup) p (NonInf)\n     19.7          1 19.6   &lt;0.001 281.3  17.7   21.6      0.951    0.00404\n p (Equiv)  hp gear\n     0.951 123    3\n\nType:  response \nColumns: rowid, estimate, std.error, statistic, p.value, s.value, conf.low, conf.high, hp, gear, mpg, statistic.noninf, statistic.nonsup, p.value.noninf, p.value.nonsup, p.value.equiv \n\nmfx &lt;- avg_slopes(mod, variables = \"hp\")\nhypotheses(mfx, equivalence = c(-.1, .1))\n\n\n Estimate Std. Error     z Pr(&gt;|z|)    S   2.5 %  97.5 % p (NonSup) p (NonInf)\n  -0.0669      0.011 -6.05   &lt;0.001 29.4 -0.0885 -0.0452     &lt;0.001    0.00135\n p (Equiv)\n   0.00135\n\nTerm: hp\nType:  response \nComparison: mean(dY/dX)\nColumns: term, contrast, estimate, std.error, statistic, p.value, s.value, conf.low, conf.high, predicted_lo, predicted_hi, predicted, statistic.noninf, statistic.nonsup, p.value.noninf, p.value.nonsup, p.value.equiv \n\ncmp &lt;- avg_comparisons(mod, variables = \"gear\", hypothesis = \"pairwise\")\nhypotheses(cmp, equivalence = c(0, 10))\n\n\n Estimate Std. Error     z Pr(&gt;|z|)   S 2.5 % 97.5 % p (NonSup) p (NonInf)\n    -3.94       2.05 -1.92   0.0543 4.2 -7.95 0.0727     &lt;0.001      0.973\n p (Equiv)\n     0.973\n\nTerm: (mean(4) - mean(3)) - (mean(5) - mean(3))\nType:  response \nColumns: term, estimate, std.error, statistic, p.value, s.value, conf.low, conf.high, statistic.noninf, statistic.nonsup, p.value.noninf, p.value.nonsup, p.value.equiv \n\n# joint hypotheses: character vector\nmodel &lt;- lm(mpg ~ as.factor(cyl) * hp, data = mtcars)\nhypotheses(model, joint = c(\"as.factor(cyl)6:hp\", \"as.factor(cyl)8:hp\"))\n\n\n\nJoint hypothesis test:\nas.factor(cyl)6:hp = 0\nas.factor(cyl)8:hp = 0\n \n    F Pr(&gt;|F|) Df 1 Df 2\n 2.11    0.142    2   26\n\nColumns: statistic, p.value, df1, df2 \n\n# joint hypotheses: regular expression\nhypotheses(model, joint = \"cyl\")\n\n\n\nJoint hypothesis test:\n as.factor(cyl)6 = 0\n as.factor(cyl)8 = 0\n as.factor(cyl)6:hp = 0\n as.factor(cyl)8:hp = 0\n \n   F Pr(&gt;|F|) Df 1 Df 2\n 5.7  0.00197    4   26\n\nColumns: statistic, p.value, df1, df2 \n\n# joint hypotheses: integer indices\nhypotheses(model, joint = 2:3)\n\n\n\nJoint hypothesis test:\n as.factor(cyl)6 = 0\n as.factor(cyl)8 = 0\n \n    F Pr(&gt;|F|) Df 1 Df 2\n 6.12  0.00665    2   26\n\nColumns: statistic, p.value, df1, df2 \n\n# joint hypotheses: different null hypotheses\nhypotheses(model, joint = 2:3, hypothesis = 1)\n\n\n\nJoint hypothesis test:\n as.factor(cyl)6 = 1\n as.factor(cyl)8 = 1\n \n    F Pr(&gt;|F|) Df 1 Df 2\n 6.84  0.00411    2   26\n\nColumns: statistic, p.value, df1, df2 \n\nhypotheses(model, joint = 2:3, hypothesis = 1:2)\n\n\n\nJoint hypothesis test:\n as.factor(cyl)6 = 1\n as.factor(cyl)8 = 2\n \n    F Pr(&gt;|F|) Df 1 Df 2\n 7.47  0.00273    2   26\n\nColumns: statistic, p.value, df1, df2 \n\n# joint hypotheses: marginaleffects object\ncmp &lt;- avg_comparisons(model)\nhypotheses(cmp, joint = \"cyl\")\n\n\n\nJoint hypothesis test:\n cyl mean(6) - mean(4) = 0\n cyl mean(8) - mean(4) = 0\n \n   F Pr(&gt;|F|) Df 1 Df 2\n 1.6    0.221    2   26\n\nColumns: statistic, p.value, df1, df2",
    "crumbs": [
      "Model to Meaning",
      "Functions",
      "`hypotheses`"
    ]
  },
  {
    "objectID": "LICENSE.html",
    "href": "LICENSE.html",
    "title": "License",
    "section": "",
    "text": "Copyright (C) 2023 Vincent Arel-Bundock vincent.arel-bundock@umontreal.ca\nThis program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.\nThis program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.\nYou should have received a copy of the GNU General Public License along with this program. If not, see http://www.gnu.org/licenses/.\n\n\nVersion 3, 29 June 2007\nCopyright © 2007 Free Software Foundation, Inc. &lt;http://fsf.org/&gt;\nEveryone is permitted to copy and distribute verbatim copies of this license document, but changing it is not allowed.\n\n\n\nThe GNU General Public License is a free, copyleft license for software and other kinds of works.\nThe licenses for most software and other practical works are designed to take away your freedom to share and change the works. By contrast, the GNU General Public License is intended to guarantee your freedom to share and change all versions of a program–to make sure it remains free software for all its users. We, the Free Software Foundation, use the GNU General Public License for most of our software; it applies also to any other work released this way by its authors. You can apply it to your programs, too.\nWhen we speak of free software, we are referring to freedom, not price. Our General Public Licenses are designed to make sure that you have the freedom to distribute copies of free software (and charge for them if you wish), that you receive source code or can get it if you want it, that you can change the software or use pieces of it in new free programs, and that you know you can do these things.\nTo protect your rights, we need to prevent others from denying you these rights or asking you to surrender the rights. Therefore, you have certain responsibilities if you distribute copies of the software, or if you modify it: responsibilities to respect the freedom of others.\nFor example, if you distribute copies of such a program, whether gratis or for a fee, you must pass on to the recipients the same freedoms that you received. You must make sure that they, too, receive or can get the source code. And you must show them these terms so they know their rights.\nDevelopers that use the GNU GPL protect your rights with two steps: (1) assert copyright on the software, and (2) offer you this License giving you legal permission to copy, distribute and/or modify it.\nFor the developers’ and authors’ protection, the GPL clearly explains that there is no warranty for this free software. For both users’ and authors’ sake, the GPL requires that modified versions be marked as changed, so that their problems will not be attributed erroneously to authors of previous versions.\nSome devices are designed to deny users access to install or run modified versions of the software inside them, although the manufacturer can do so. This is fundamentally incompatible with the aim of protecting users’ freedom to change the software. The systematic pattern of such abuse occurs in the area of products for individuals to use, which is precisely where it is most unacceptable. Therefore, we have designed this version of the GPL to prohibit the practice for those products. If such problems arise substantially in other domains, we stand ready to extend this provision to those domains in future versions of the GPL, as needed to protect the freedom of users.\nFinally, every program is threatened constantly by software patents. States should not allow patents to restrict development and use of software on general-purpose computers, but in those that do, we wish to avoid the special danger that patents applied to a free program could make it effectively proprietary. To prevent this, the GPL assures that patents cannot be used to render the program non-free.\nThe precise terms and conditions for copying, distribution and modification follow.\n\n\n\n\n\n“This License” refers to version 3 of the GNU General Public License.\n“Copyright” also means copyright-like laws that apply to other kinds of works, such as semiconductor masks.\n“The Program” refers to any copyrightable work licensed under this License. Each licensee is addressed as “you”. “Licensees” and “recipients” may be individuals or organizations.\nTo “modify” a work means to copy from or adapt all or part of the work in a fashion requiring copyright permission, other than the making of an exact copy. The resulting work is called a “modified version” of the earlier work or a work “based on” the earlier work.\nA “covered work” means either the unmodified Program or a work based on the Program.\nTo “propagate” a work means to do anything with it that, without permission, would make you directly or secondarily liable for infringement under applicable copyright law, except executing it on a computer or modifying a private copy. Propagation includes copying, distribution (with or without modification), making available to the public, and in some countries other activities as well.\nTo “convey” a work means any kind of propagation that enables other parties to make or receive copies. Mere interaction with a user through a computer network, with no transfer of a copy, is not conveying.\nAn interactive user interface displays “Appropriate Legal Notices” to the extent that it includes a convenient and prominently visible feature that (1) displays an appropriate copyright notice, and (2) tells the user that there is no warranty for the work (except to the extent that warranties are provided), that licensees may convey the work under this License, and how to view a copy of this License. If the interface presents a list of user commands or options, such as a menu, a prominent item in the list meets this criterion.\n\n\n\nThe “source code” for a work means the preferred form of the work for making modifications to it. “Object code” means any non-source form of a work.\nA “Standard Interface” means an interface that either is an official standard defined by a recognized standards body, or, in the case of interfaces specified for a particular programming language, one that is widely used among developers working in that language.\nThe “System Libraries” of an executable work include anything, other than the work as a whole, that (a) is included in the normal form of packaging a Major Component, but which is not part of that Major Component, and (b) serves only to enable use of the work with that Major Component, or to implement a Standard Interface for which an implementation is available to the public in source code form. A “Major Component”, in this context, means a major essential component (kernel, window system, and so on) of the specific operating system (if any) on which the executable work runs, or a compiler used to produce the work, or an object code interpreter used to run it.\nThe “Corresponding Source” for a work in object code form means all the source code needed to generate, install, and (for an executable work) run the object code and to modify the work, including scripts to control those activities. However, it does not include the work’s System Libraries, or general-purpose tools or generally available free programs which are used unmodified in performing those activities but which are not part of the work. For example, Corresponding Source includes interface definition files associated with source files for the work, and the source code for shared libraries and dynamically linked subprograms that the work is specifically designed to require, such as by intimate data communication or control flow between those subprograms and other parts of the work.\nThe Corresponding Source need not include anything that users can regenerate automatically from other parts of the Corresponding Source.\nThe Corresponding Source for a work in source code form is that same work.\n\n\n\nAll rights granted under this License are granted for the term of copyright on the Program, and are irrevocable provided the stated conditions are met. This License explicitly affirms your unlimited permission to run the unmodified Program. The output from running a covered work is covered by this License only if the output, given its content, constitutes a covered work. This License acknowledges your rights of fair use or other equivalent, as provided by copyright law.\nYou may make, run and propagate covered works that you do not convey, without conditions so long as your license otherwise remains in force. You may convey covered works to others for the sole purpose of having them make modifications exclusively for you, or provide you with facilities for running those works, provided that you comply with the terms of this License in conveying all material for which you do not control copyright. Those thus making or running the covered works for you must do so exclusively on your behalf, under your direction and control, on terms that prohibit them from making any copies of your copyrighted material outside their relationship with you.\nConveying under any other circumstances is permitted solely under the conditions stated below. Sublicensing is not allowed; section 10 makes it unnecessary.\n\n\n\nNo covered work shall be deemed part of an effective technological measure under any applicable law fulfilling obligations under article 11 of the WIPO copyright treaty adopted on 20 December 1996, or similar laws prohibiting or restricting circumvention of such measures.\nWhen you convey a covered work, you waive any legal power to forbid circumvention of technological measures to the extent such circumvention is effected by exercising rights under this License with respect to the covered work, and you disclaim any intention to limit operation or modification of the work as a means of enforcing, against the work’s users, your or third parties’ legal rights to forbid circumvention of technological measures.\n\n\n\nYou may convey verbatim copies of the Program’s source code as you receive it, in any medium, provided that you conspicuously and appropriately publish on each copy an appropriate copyright notice; keep intact all notices stating that this License and any non-permissive terms added in accord with section 7 apply to the code; keep intact all notices of the absence of any warranty; and give all recipients a copy of this License along with the Program.\nYou may charge any price or no price for each copy that you convey, and you may offer support or warranty protection for a fee.\n\n\n\nYou may convey a work based on the Program, or the modifications to produce it from the Program, in the form of source code under the terms of section 4, provided that you also meet all of these conditions:\n\na) The work must carry prominent notices stating that you modified it, and giving a relevant date.\nb) The work must carry prominent notices stating that it is released under this License and any conditions added under section 7. This requirement modifies the requirement in section 4 to “keep intact all notices”.\nc) You must license the entire work, as a whole, under this License to anyone who comes into possession of a copy. This License will therefore apply, along with any applicable section 7 additional terms, to the whole of the work, and all its parts, regardless of how they are packaged. This License gives no permission to license the work in any other way, but it does not invalidate such permission if you have separately received it.\nd) If the work has interactive user interfaces, each must display Appropriate Legal Notices; however, if the Program has interactive interfaces that do not display Appropriate Legal Notices, your work need not make them do so.\n\nA compilation of a covered work with other separate and independent works, which are not by their nature extensions of the covered work, and which are not combined with it such as to form a larger program, in or on a volume of a storage or distribution medium, is called an “aggregate” if the compilation and its resulting copyright are not used to limit the access or legal rights of the compilation’s users beyond what the individual works permit. Inclusion of a covered work in an aggregate does not cause this License to apply to the other parts of the aggregate.\n\n\n\nYou may convey a covered work in object code form under the terms of sections 4 and 5, provided that you also convey the machine-readable Corresponding Source under the terms of this License, in one of these ways:\n\na) Convey the object code in, or embodied in, a physical product (including a physical distribution medium), accompanied by the Corresponding Source fixed on a durable physical medium customarily used for software interchange.\nb) Convey the object code in, or embodied in, a physical product (including a physical distribution medium), accompanied by a written offer, valid for at least three years and valid for as long as you offer spare parts or customer support for that product model, to give anyone who possesses the object code either (1) a copy of the Corresponding Source for all the software in the product that is covered by this License, on a durable physical medium customarily used for software interchange, for a price no more than your reasonable cost of physically performing this conveying of source, or (2) access to copy the Corresponding Source from a network server at no charge.\nc) Convey individual copies of the object code with a copy of the written offer to provide the Corresponding Source. This alternative is allowed only occasionally and noncommercially, and only if you received the object code with such an offer, in accord with subsection 6b.\nd) Convey the object code by offering access from a designated place (gratis or for a charge), and offer equivalent access to the Corresponding Source in the same way through the same place at no further charge. You need not require recipients to copy the Corresponding Source along with the object code. If the place to copy the object code is a network server, the Corresponding Source may be on a different server (operated by you or a third party) that supports equivalent copying facilities, provided you maintain clear directions next to the object code saying where to find the Corresponding Source. Regardless of what server hosts the Corresponding Source, you remain obligated to ensure that it is available for as long as needed to satisfy these requirements.\ne) Convey the object code using peer-to-peer transmission, provided you inform other peers where the object code and Corresponding Source of the work are being offered to the general public at no charge under subsection 6d.\n\nA separable portion of the object code, whose source code is excluded from the Corresponding Source as a System Library, need not be included in conveying the object code work.\nA “User Product” is either (1) a “consumer product”, which means any tangible personal property which is normally used for personal, family, or household purposes, or (2) anything designed or sold for incorporation into a dwelling. In determining whether a product is a consumer product, doubtful cases shall be resolved in favor of coverage. For a particular product received by a particular user, “normally used” refers to a typical or common use of that class of product, regardless of the status of the particular user or of the way in which the particular user actually uses, or expects or is expected to use, the product. A product is a consumer product regardless of whether the product has substantial commercial, industrial or non-consumer uses, unless such uses represent the only significant mode of use of the product.\n“Installation Information” for a User Product means any methods, procedures, authorization keys, or other information required to install and execute modified versions of a covered work in that User Product from a modified version of its Corresponding Source. The information must suffice to ensure that the continued functioning of the modified object code is in no case prevented or interfered with solely because modification has been made.\nIf you convey an object code work under this section in, or with, or specifically for use in, a User Product, and the conveying occurs as part of a transaction in which the right of possession and use of the User Product is transferred to the recipient in perpetuity or for a fixed term (regardless of how the transaction is characterized), the Corresponding Source conveyed under this section must be accompanied by the Installation Information. But this requirement does not apply if neither you nor any third party retains the ability to install modified object code on the User Product (for example, the work has been installed in ROM).\nThe requirement to provide Installation Information does not include a requirement to continue to provide support service, warranty, or updates for a work that has been modified or installed by the recipient, or for the User Product in which it has been modified or installed. Access to a network may be denied when the modification itself materially and adversely affects the operation of the network or violates the rules and protocols for communication across the network.\nCorresponding Source conveyed, and Installation Information provided, in accord with this section must be in a format that is publicly documented (and with an implementation available to the public in source code form), and must require no special password or key for unpacking, reading or copying.\n\n\n\n“Additional permissions” are terms that supplement the terms of this License by making exceptions from one or more of its conditions. Additional permissions that are applicable to the entire Program shall be treated as though they were included in this License, to the extent that they are valid under applicable law. If additional permissions apply only to part of the Program, that part may be used separately under those permissions, but the entire Program remains governed by this License without regard to the additional permissions.\nWhen you convey a copy of a covered work, you may at your option remove any additional permissions from that copy, or from any part of it. (Additional permissions may be written to require their own removal in certain cases when you modify the work.) You may place additional permissions on material, added by you to a covered work, for which you have or can give appropriate copyright permission.\nNotwithstanding any other provision of this License, for material you add to a covered work, you may (if authorized by the copyright holders of that material) supplement the terms of this License with terms:\n\na) Disclaiming warranty or limiting liability differently from the terms of sections 15 and 16 of this License; or\nb) Requiring preservation of specified reasonable legal notices or author attributions in that material or in the Appropriate Legal Notices displayed by works containing it; or\nc) Prohibiting misrepresentation of the origin of that material, or requiring that modified versions of such material be marked in reasonable ways as different from the original version; or\nd) Limiting the use for publicity purposes of names of licensors or authors of the material; or\ne) Declining to grant rights under trademark law for use of some trade names, trademarks, or service marks; or\nf) Requiring indemnification of licensors and authors of that material by anyone who conveys the material (or modified versions of it) with contractual assumptions of liability to the recipient, for any liability that these contractual assumptions directly impose on those licensors and authors.\n\nAll other non-permissive additional terms are considered “further restrictions” within the meaning of section 10. If the Program as you received it, or any part of it, contains a notice stating that it is governed by this License along with a term that is a further restriction, you may remove that term. If a license document contains a further restriction but permits relicensing or conveying under this License, you may add to a covered work material governed by the terms of that license document, provided that the further restriction does not survive such relicensing or conveying.\nIf you add terms to a covered work in accord with this section, you must place, in the relevant source files, a statement of the additional terms that apply to those files, or a notice indicating where to find the applicable terms.\nAdditional terms, permissive or non-permissive, may be stated in the form of a separately written license, or stated as exceptions; the above requirements apply either way.\n\n\n\nYou may not propagate or modify a covered work except as expressly provided under this License. Any attempt otherwise to propagate or modify it is void, and will automatically terminate your rights under this License (including any patent licenses granted under the third paragraph of section 11).\nHowever, if you cease all violation of this License, then your license from a particular copyright holder is reinstated (a) provisionally, unless and until the copyright holder explicitly and finally terminates your license, and (b) permanently, if the copyright holder fails to notify you of the violation by some reasonable means prior to 60 days after the cessation.\nMoreover, your license from a particular copyright holder is reinstated permanently if the copyright holder notifies you of the violation by some reasonable means, this is the first time you have received notice of violation of this License (for any work) from that copyright holder, and you cure the violation prior to 30 days after your receipt of the notice.\nTermination of your rights under this section does not terminate the licenses of parties who have received copies or rights from you under this License. If your rights have been terminated and not permanently reinstated, you do not qualify to receive new licenses for the same material under section 10.\n\n\n\nYou are not required to accept this License in order to receive or run a copy of the Program. Ancillary propagation of a covered work occurring solely as a consequence of using peer-to-peer transmission to receive a copy likewise does not require acceptance. However, nothing other than this License grants you permission to propagate or modify any covered work. These actions infringe copyright if you do not accept this License. Therefore, by modifying or propagating a covered work, you indicate your acceptance of this License to do so.\n\n\n\nEach time you convey a covered work, the recipient automatically receives a license from the original licensors, to run, modify and propagate that work, subject to this License. You are not responsible for enforcing compliance by third parties with this License.\nAn “entity transaction” is a transaction transferring control of an organization, or substantially all assets of one, or subdividing an organization, or merging organizations. If propagation of a covered work results from an entity transaction, each party to that transaction who receives a copy of the work also receives whatever licenses to the work the party’s predecessor in interest had or could give under the previous paragraph, plus a right to possession of the Corresponding Source of the work from the predecessor in interest, if the predecessor has it or can get it with reasonable efforts.\nYou may not impose any further restrictions on the exercise of the rights granted or affirmed under this License. For example, you may not impose a license fee, royalty, or other charge for exercise of rights granted under this License, and you may not initiate litigation (including a cross-claim or counterclaim in a lawsuit) alleging that any patent claim is infringed by making, using, selling, offering for sale, or importing the Program or any portion of it.\n\n\n\nA “contributor” is a copyright holder who authorizes use under this License of the Program or a work on which the Program is based. The work thus licensed is called the contributor’s “contributor version”.\nA contributor’s “essential patent claims” are all patent claims owned or controlled by the contributor, whether already acquired or hereafter acquired, that would be infringed by some manner, permitted by this License, of making, using, or selling its contributor version, but do not include claims that would be infringed only as a consequence of further modification of the contributor version. For purposes of this definition, “control” includes the right to grant patent sublicenses in a manner consistent with the requirements of this License.\nEach contributor grants you a non-exclusive, worldwide, royalty-free patent license under the contributor’s essential patent claims, to make, use, sell, offer for sale, import and otherwise run, modify and propagate the contents of its contributor version.\nIn the following three paragraphs, a “patent license” is any express agreement or commitment, however denominated, not to enforce a patent (such as an express permission to practice a patent or covenant not to sue for patent infringement). To “grant” such a patent license to a party means to make such an agreement or commitment not to enforce a patent against the party.\nIf you convey a covered work, knowingly relying on a patent license, and the Corresponding Source of the work is not available for anyone to copy, free of charge and under the terms of this License, through a publicly available network server or other readily accessible means, then you must either (1) cause the Corresponding Source to be so available, or (2) arrange to deprive yourself of the benefit of the patent license for this particular work, or (3) arrange, in a manner consistent with the requirements of this License, to extend the patent license to downstream recipients. “Knowingly relying” means you have actual knowledge that, but for the patent license, your conveying the covered work in a country, or your recipient’s use of the covered work in a country, would infringe one or more identifiable patents in that country that you have reason to believe are valid.\nIf, pursuant to or in connection with a single transaction or arrangement, you convey, or propagate by procuring conveyance of, a covered work, and grant a patent license to some of the parties receiving the covered work authorizing them to use, propagate, modify or convey a specific copy of the covered work, then the patent license you grant is automatically extended to all recipients of the covered work and works based on it.\nA patent license is “discriminatory” if it does not include within the scope of its coverage, prohibits the exercise of, or is conditioned on the non-exercise of one or more of the rights that are specifically granted under this License. You may not convey a covered work if you are a party to an arrangement with a third party that is in the business of distributing software, under which you make payment to the third party based on the extent of your activity of conveying the work, and under which the third party grants, to any of the parties who would receive the covered work from you, a discriminatory patent license (a) in connection with copies of the covered work conveyed by you (or copies made from those copies), or (b) primarily for and in connection with specific products or compilations that contain the covered work, unless you entered into that arrangement, or that patent license was granted, prior to 28 March 2007.\nNothing in this License shall be construed as excluding or limiting any implied license or other defenses to infringement that may otherwise be available to you under applicable patent law.\n\n\n\nIf conditions are imposed on you (whether by court order, agreement or otherwise) that contradict the conditions of this License, they do not excuse you from the conditions of this License. If you cannot convey a covered work so as to satisfy simultaneously your obligations under this License and any other pertinent obligations, then as a consequence you may not convey it at all. For example, if you agree to terms that obligate you to collect a royalty for further conveying from those to whom you convey the Program, the only way you could satisfy both those terms and this License would be to refrain entirely from conveying the Program.\n\n\n\nNotwithstanding any other provision of this License, you have permission to link or combine any covered work with a work licensed under version 3 of the GNU Affero General Public License into a single combined work, and to convey the resulting work. The terms of this License will continue to apply to the part which is the covered work, but the special requirements of the GNU Affero General Public License, section 13, concerning interaction through a network will apply to the combination as such.\n\n\n\nThe Free Software Foundation may publish revised and/or new versions of the GNU General Public License from time to time. Such new versions will be similar in spirit to the present version, but may differ in detail to address new problems or concerns.\nEach version is given a distinguishing version number. If the Program specifies that a certain numbered version of the GNU General Public License “or any later version” applies to it, you have the option of following the terms and conditions either of that numbered version or of any later version published by the Free Software Foundation. If the Program does not specify a version number of the GNU General Public License, you may choose any version ever published by the Free Software Foundation.\nIf the Program specifies that a proxy can decide which future versions of the GNU General Public License can be used, that proxy’s public statement of acceptance of a version permanently authorizes you to choose that version for the Program.\nLater license versions may give you additional or different permissions. However, no additional obligations are imposed on any author or copyright holder as a result of your choosing to follow a later version.\n\n\n\nTHERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW. EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU. SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.\n\n\n\nIN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.\n\n\n\nIf the disclaimer of warranty and limitation of liability provided above cannot be given local legal effect according to their terms, reviewing courts shall apply local law that most closely approximates an absolute waiver of all civil liability in connection with the Program, unless a warranty or assumption of liability accompanies a copy of the Program in return for a fee.",
    "crumbs": [
      "Model to Meaning",
      "License"
    ]
  },
  {
    "objectID": "LICENSE.html#gnu-general-public-license",
    "href": "LICENSE.html#gnu-general-public-license",
    "title": "License",
    "section": "",
    "text": "Version 3, 29 June 2007\nCopyright © 2007 Free Software Foundation, Inc. &lt;http://fsf.org/&gt;\nEveryone is permitted to copy and distribute verbatim copies of this license document, but changing it is not allowed.",
    "crumbs": [
      "Model to Meaning",
      "License"
    ]
  },
  {
    "objectID": "LICENSE.html#preamble",
    "href": "LICENSE.html#preamble",
    "title": "License",
    "section": "",
    "text": "The GNU General Public License is a free, copyleft license for software and other kinds of works.\nThe licenses for most software and other practical works are designed to take away your freedom to share and change the works. By contrast, the GNU General Public License is intended to guarantee your freedom to share and change all versions of a program–to make sure it remains free software for all its users. We, the Free Software Foundation, use the GNU General Public License for most of our software; it applies also to any other work released this way by its authors. You can apply it to your programs, too.\nWhen we speak of free software, we are referring to freedom, not price. Our General Public Licenses are designed to make sure that you have the freedom to distribute copies of free software (and charge for them if you wish), that you receive source code or can get it if you want it, that you can change the software or use pieces of it in new free programs, and that you know you can do these things.\nTo protect your rights, we need to prevent others from denying you these rights or asking you to surrender the rights. Therefore, you have certain responsibilities if you distribute copies of the software, or if you modify it: responsibilities to respect the freedom of others.\nFor example, if you distribute copies of such a program, whether gratis or for a fee, you must pass on to the recipients the same freedoms that you received. You must make sure that they, too, receive or can get the source code. And you must show them these terms so they know their rights.\nDevelopers that use the GNU GPL protect your rights with two steps: (1) assert copyright on the software, and (2) offer you this License giving you legal permission to copy, distribute and/or modify it.\nFor the developers’ and authors’ protection, the GPL clearly explains that there is no warranty for this free software. For both users’ and authors’ sake, the GPL requires that modified versions be marked as changed, so that their problems will not be attributed erroneously to authors of previous versions.\nSome devices are designed to deny users access to install or run modified versions of the software inside them, although the manufacturer can do so. This is fundamentally incompatible with the aim of protecting users’ freedom to change the software. The systematic pattern of such abuse occurs in the area of products for individuals to use, which is precisely where it is most unacceptable. Therefore, we have designed this version of the GPL to prohibit the practice for those products. If such problems arise substantially in other domains, we stand ready to extend this provision to those domains in future versions of the GPL, as needed to protect the freedom of users.\nFinally, every program is threatened constantly by software patents. States should not allow patents to restrict development and use of software on general-purpose computers, but in those that do, we wish to avoid the special danger that patents applied to a free program could make it effectively proprietary. To prevent this, the GPL assures that patents cannot be used to render the program non-free.\nThe precise terms and conditions for copying, distribution and modification follow.",
    "crumbs": [
      "Model to Meaning",
      "License"
    ]
  },
  {
    "objectID": "LICENSE.html#terms-and-conditions",
    "href": "LICENSE.html#terms-and-conditions",
    "title": "License",
    "section": "",
    "text": "“This License” refers to version 3 of the GNU General Public License.\n“Copyright” also means copyright-like laws that apply to other kinds of works, such as semiconductor masks.\n“The Program” refers to any copyrightable work licensed under this License. Each licensee is addressed as “you”. “Licensees” and “recipients” may be individuals or organizations.\nTo “modify” a work means to copy from or adapt all or part of the work in a fashion requiring copyright permission, other than the making of an exact copy. The resulting work is called a “modified version” of the earlier work or a work “based on” the earlier work.\nA “covered work” means either the unmodified Program or a work based on the Program.\nTo “propagate” a work means to do anything with it that, without permission, would make you directly or secondarily liable for infringement under applicable copyright law, except executing it on a computer or modifying a private copy. Propagation includes copying, distribution (with or without modification), making available to the public, and in some countries other activities as well.\nTo “convey” a work means any kind of propagation that enables other parties to make or receive copies. Mere interaction with a user through a computer network, with no transfer of a copy, is not conveying.\nAn interactive user interface displays “Appropriate Legal Notices” to the extent that it includes a convenient and prominently visible feature that (1) displays an appropriate copyright notice, and (2) tells the user that there is no warranty for the work (except to the extent that warranties are provided), that licensees may convey the work under this License, and how to view a copy of this License. If the interface presents a list of user commands or options, such as a menu, a prominent item in the list meets this criterion.\n\n\n\nThe “source code” for a work means the preferred form of the work for making modifications to it. “Object code” means any non-source form of a work.\nA “Standard Interface” means an interface that either is an official standard defined by a recognized standards body, or, in the case of interfaces specified for a particular programming language, one that is widely used among developers working in that language.\nThe “System Libraries” of an executable work include anything, other than the work as a whole, that (a) is included in the normal form of packaging a Major Component, but which is not part of that Major Component, and (b) serves only to enable use of the work with that Major Component, or to implement a Standard Interface for which an implementation is available to the public in source code form. A “Major Component”, in this context, means a major essential component (kernel, window system, and so on) of the specific operating system (if any) on which the executable work runs, or a compiler used to produce the work, or an object code interpreter used to run it.\nThe “Corresponding Source” for a work in object code form means all the source code needed to generate, install, and (for an executable work) run the object code and to modify the work, including scripts to control those activities. However, it does not include the work’s System Libraries, or general-purpose tools or generally available free programs which are used unmodified in performing those activities but which are not part of the work. For example, Corresponding Source includes interface definition files associated with source files for the work, and the source code for shared libraries and dynamically linked subprograms that the work is specifically designed to require, such as by intimate data communication or control flow between those subprograms and other parts of the work.\nThe Corresponding Source need not include anything that users can regenerate automatically from other parts of the Corresponding Source.\nThe Corresponding Source for a work in source code form is that same work.\n\n\n\nAll rights granted under this License are granted for the term of copyright on the Program, and are irrevocable provided the stated conditions are met. This License explicitly affirms your unlimited permission to run the unmodified Program. The output from running a covered work is covered by this License only if the output, given its content, constitutes a covered work. This License acknowledges your rights of fair use or other equivalent, as provided by copyright law.\nYou may make, run and propagate covered works that you do not convey, without conditions so long as your license otherwise remains in force. You may convey covered works to others for the sole purpose of having them make modifications exclusively for you, or provide you with facilities for running those works, provided that you comply with the terms of this License in conveying all material for which you do not control copyright. Those thus making or running the covered works for you must do so exclusively on your behalf, under your direction and control, on terms that prohibit them from making any copies of your copyrighted material outside their relationship with you.\nConveying under any other circumstances is permitted solely under the conditions stated below. Sublicensing is not allowed; section 10 makes it unnecessary.\n\n\n\nNo covered work shall be deemed part of an effective technological measure under any applicable law fulfilling obligations under article 11 of the WIPO copyright treaty adopted on 20 December 1996, or similar laws prohibiting or restricting circumvention of such measures.\nWhen you convey a covered work, you waive any legal power to forbid circumvention of technological measures to the extent such circumvention is effected by exercising rights under this License with respect to the covered work, and you disclaim any intention to limit operation or modification of the work as a means of enforcing, against the work’s users, your or third parties’ legal rights to forbid circumvention of technological measures.\n\n\n\nYou may convey verbatim copies of the Program’s source code as you receive it, in any medium, provided that you conspicuously and appropriately publish on each copy an appropriate copyright notice; keep intact all notices stating that this License and any non-permissive terms added in accord with section 7 apply to the code; keep intact all notices of the absence of any warranty; and give all recipients a copy of this License along with the Program.\nYou may charge any price or no price for each copy that you convey, and you may offer support or warranty protection for a fee.\n\n\n\nYou may convey a work based on the Program, or the modifications to produce it from the Program, in the form of source code under the terms of section 4, provided that you also meet all of these conditions:\n\na) The work must carry prominent notices stating that you modified it, and giving a relevant date.\nb) The work must carry prominent notices stating that it is released under this License and any conditions added under section 7. This requirement modifies the requirement in section 4 to “keep intact all notices”.\nc) You must license the entire work, as a whole, under this License to anyone who comes into possession of a copy. This License will therefore apply, along with any applicable section 7 additional terms, to the whole of the work, and all its parts, regardless of how they are packaged. This License gives no permission to license the work in any other way, but it does not invalidate such permission if you have separately received it.\nd) If the work has interactive user interfaces, each must display Appropriate Legal Notices; however, if the Program has interactive interfaces that do not display Appropriate Legal Notices, your work need not make them do so.\n\nA compilation of a covered work with other separate and independent works, which are not by their nature extensions of the covered work, and which are not combined with it such as to form a larger program, in or on a volume of a storage or distribution medium, is called an “aggregate” if the compilation and its resulting copyright are not used to limit the access or legal rights of the compilation’s users beyond what the individual works permit. Inclusion of a covered work in an aggregate does not cause this License to apply to the other parts of the aggregate.\n\n\n\nYou may convey a covered work in object code form under the terms of sections 4 and 5, provided that you also convey the machine-readable Corresponding Source under the terms of this License, in one of these ways:\n\na) Convey the object code in, or embodied in, a physical product (including a physical distribution medium), accompanied by the Corresponding Source fixed on a durable physical medium customarily used for software interchange.\nb) Convey the object code in, or embodied in, a physical product (including a physical distribution medium), accompanied by a written offer, valid for at least three years and valid for as long as you offer spare parts or customer support for that product model, to give anyone who possesses the object code either (1) a copy of the Corresponding Source for all the software in the product that is covered by this License, on a durable physical medium customarily used for software interchange, for a price no more than your reasonable cost of physically performing this conveying of source, or (2) access to copy the Corresponding Source from a network server at no charge.\nc) Convey individual copies of the object code with a copy of the written offer to provide the Corresponding Source. This alternative is allowed only occasionally and noncommercially, and only if you received the object code with such an offer, in accord with subsection 6b.\nd) Convey the object code by offering access from a designated place (gratis or for a charge), and offer equivalent access to the Corresponding Source in the same way through the same place at no further charge. You need not require recipients to copy the Corresponding Source along with the object code. If the place to copy the object code is a network server, the Corresponding Source may be on a different server (operated by you or a third party) that supports equivalent copying facilities, provided you maintain clear directions next to the object code saying where to find the Corresponding Source. Regardless of what server hosts the Corresponding Source, you remain obligated to ensure that it is available for as long as needed to satisfy these requirements.\ne) Convey the object code using peer-to-peer transmission, provided you inform other peers where the object code and Corresponding Source of the work are being offered to the general public at no charge under subsection 6d.\n\nA separable portion of the object code, whose source code is excluded from the Corresponding Source as a System Library, need not be included in conveying the object code work.\nA “User Product” is either (1) a “consumer product”, which means any tangible personal property which is normally used for personal, family, or household purposes, or (2) anything designed or sold for incorporation into a dwelling. In determining whether a product is a consumer product, doubtful cases shall be resolved in favor of coverage. For a particular product received by a particular user, “normally used” refers to a typical or common use of that class of product, regardless of the status of the particular user or of the way in which the particular user actually uses, or expects or is expected to use, the product. A product is a consumer product regardless of whether the product has substantial commercial, industrial or non-consumer uses, unless such uses represent the only significant mode of use of the product.\n“Installation Information” for a User Product means any methods, procedures, authorization keys, or other information required to install and execute modified versions of a covered work in that User Product from a modified version of its Corresponding Source. The information must suffice to ensure that the continued functioning of the modified object code is in no case prevented or interfered with solely because modification has been made.\nIf you convey an object code work under this section in, or with, or specifically for use in, a User Product, and the conveying occurs as part of a transaction in which the right of possession and use of the User Product is transferred to the recipient in perpetuity or for a fixed term (regardless of how the transaction is characterized), the Corresponding Source conveyed under this section must be accompanied by the Installation Information. But this requirement does not apply if neither you nor any third party retains the ability to install modified object code on the User Product (for example, the work has been installed in ROM).\nThe requirement to provide Installation Information does not include a requirement to continue to provide support service, warranty, or updates for a work that has been modified or installed by the recipient, or for the User Product in which it has been modified or installed. Access to a network may be denied when the modification itself materially and adversely affects the operation of the network or violates the rules and protocols for communication across the network.\nCorresponding Source conveyed, and Installation Information provided, in accord with this section must be in a format that is publicly documented (and with an implementation available to the public in source code form), and must require no special password or key for unpacking, reading or copying.\n\n\n\n“Additional permissions” are terms that supplement the terms of this License by making exceptions from one or more of its conditions. Additional permissions that are applicable to the entire Program shall be treated as though they were included in this License, to the extent that they are valid under applicable law. If additional permissions apply only to part of the Program, that part may be used separately under those permissions, but the entire Program remains governed by this License without regard to the additional permissions.\nWhen you convey a copy of a covered work, you may at your option remove any additional permissions from that copy, or from any part of it. (Additional permissions may be written to require their own removal in certain cases when you modify the work.) You may place additional permissions on material, added by you to a covered work, for which you have or can give appropriate copyright permission.\nNotwithstanding any other provision of this License, for material you add to a covered work, you may (if authorized by the copyright holders of that material) supplement the terms of this License with terms:\n\na) Disclaiming warranty or limiting liability differently from the terms of sections 15 and 16 of this License; or\nb) Requiring preservation of specified reasonable legal notices or author attributions in that material or in the Appropriate Legal Notices displayed by works containing it; or\nc) Prohibiting misrepresentation of the origin of that material, or requiring that modified versions of such material be marked in reasonable ways as different from the original version; or\nd) Limiting the use for publicity purposes of names of licensors or authors of the material; or\ne) Declining to grant rights under trademark law for use of some trade names, trademarks, or service marks; or\nf) Requiring indemnification of licensors and authors of that material by anyone who conveys the material (or modified versions of it) with contractual assumptions of liability to the recipient, for any liability that these contractual assumptions directly impose on those licensors and authors.\n\nAll other non-permissive additional terms are considered “further restrictions” within the meaning of section 10. If the Program as you received it, or any part of it, contains a notice stating that it is governed by this License along with a term that is a further restriction, you may remove that term. If a license document contains a further restriction but permits relicensing or conveying under this License, you may add to a covered work material governed by the terms of that license document, provided that the further restriction does not survive such relicensing or conveying.\nIf you add terms to a covered work in accord with this section, you must place, in the relevant source files, a statement of the additional terms that apply to those files, or a notice indicating where to find the applicable terms.\nAdditional terms, permissive or non-permissive, may be stated in the form of a separately written license, or stated as exceptions; the above requirements apply either way.\n\n\n\nYou may not propagate or modify a covered work except as expressly provided under this License. Any attempt otherwise to propagate or modify it is void, and will automatically terminate your rights under this License (including any patent licenses granted under the third paragraph of section 11).\nHowever, if you cease all violation of this License, then your license from a particular copyright holder is reinstated (a) provisionally, unless and until the copyright holder explicitly and finally terminates your license, and (b) permanently, if the copyright holder fails to notify you of the violation by some reasonable means prior to 60 days after the cessation.\nMoreover, your license from a particular copyright holder is reinstated permanently if the copyright holder notifies you of the violation by some reasonable means, this is the first time you have received notice of violation of this License (for any work) from that copyright holder, and you cure the violation prior to 30 days after your receipt of the notice.\nTermination of your rights under this section does not terminate the licenses of parties who have received copies or rights from you under this License. If your rights have been terminated and not permanently reinstated, you do not qualify to receive new licenses for the same material under section 10.\n\n\n\nYou are not required to accept this License in order to receive or run a copy of the Program. Ancillary propagation of a covered work occurring solely as a consequence of using peer-to-peer transmission to receive a copy likewise does not require acceptance. However, nothing other than this License grants you permission to propagate or modify any covered work. These actions infringe copyright if you do not accept this License. Therefore, by modifying or propagating a covered work, you indicate your acceptance of this License to do so.\n\n\n\nEach time you convey a covered work, the recipient automatically receives a license from the original licensors, to run, modify and propagate that work, subject to this License. You are not responsible for enforcing compliance by third parties with this License.\nAn “entity transaction” is a transaction transferring control of an organization, or substantially all assets of one, or subdividing an organization, or merging organizations. If propagation of a covered work results from an entity transaction, each party to that transaction who receives a copy of the work also receives whatever licenses to the work the party’s predecessor in interest had or could give under the previous paragraph, plus a right to possession of the Corresponding Source of the work from the predecessor in interest, if the predecessor has it or can get it with reasonable efforts.\nYou may not impose any further restrictions on the exercise of the rights granted or affirmed under this License. For example, you may not impose a license fee, royalty, or other charge for exercise of rights granted under this License, and you may not initiate litigation (including a cross-claim or counterclaim in a lawsuit) alleging that any patent claim is infringed by making, using, selling, offering for sale, or importing the Program or any portion of it.\n\n\n\nA “contributor” is a copyright holder who authorizes use under this License of the Program or a work on which the Program is based. The work thus licensed is called the contributor’s “contributor version”.\nA contributor’s “essential patent claims” are all patent claims owned or controlled by the contributor, whether already acquired or hereafter acquired, that would be infringed by some manner, permitted by this License, of making, using, or selling its contributor version, but do not include claims that would be infringed only as a consequence of further modification of the contributor version. For purposes of this definition, “control” includes the right to grant patent sublicenses in a manner consistent with the requirements of this License.\nEach contributor grants you a non-exclusive, worldwide, royalty-free patent license under the contributor’s essential patent claims, to make, use, sell, offer for sale, import and otherwise run, modify and propagate the contents of its contributor version.\nIn the following three paragraphs, a “patent license” is any express agreement or commitment, however denominated, not to enforce a patent (such as an express permission to practice a patent or covenant not to sue for patent infringement). To “grant” such a patent license to a party means to make such an agreement or commitment not to enforce a patent against the party.\nIf you convey a covered work, knowingly relying on a patent license, and the Corresponding Source of the work is not available for anyone to copy, free of charge and under the terms of this License, through a publicly available network server or other readily accessible means, then you must either (1) cause the Corresponding Source to be so available, or (2) arrange to deprive yourself of the benefit of the patent license for this particular work, or (3) arrange, in a manner consistent with the requirements of this License, to extend the patent license to downstream recipients. “Knowingly relying” means you have actual knowledge that, but for the patent license, your conveying the covered work in a country, or your recipient’s use of the covered work in a country, would infringe one or more identifiable patents in that country that you have reason to believe are valid.\nIf, pursuant to or in connection with a single transaction or arrangement, you convey, or propagate by procuring conveyance of, a covered work, and grant a patent license to some of the parties receiving the covered work authorizing them to use, propagate, modify or convey a specific copy of the covered work, then the patent license you grant is automatically extended to all recipients of the covered work and works based on it.\nA patent license is “discriminatory” if it does not include within the scope of its coverage, prohibits the exercise of, or is conditioned on the non-exercise of one or more of the rights that are specifically granted under this License. You may not convey a covered work if you are a party to an arrangement with a third party that is in the business of distributing software, under which you make payment to the third party based on the extent of your activity of conveying the work, and under which the third party grants, to any of the parties who would receive the covered work from you, a discriminatory patent license (a) in connection with copies of the covered work conveyed by you (or copies made from those copies), or (b) primarily for and in connection with specific products or compilations that contain the covered work, unless you entered into that arrangement, or that patent license was granted, prior to 28 March 2007.\nNothing in this License shall be construed as excluding or limiting any implied license or other defenses to infringement that may otherwise be available to you under applicable patent law.\n\n\n\nIf conditions are imposed on you (whether by court order, agreement or otherwise) that contradict the conditions of this License, they do not excuse you from the conditions of this License. If you cannot convey a covered work so as to satisfy simultaneously your obligations under this License and any other pertinent obligations, then as a consequence you may not convey it at all. For example, if you agree to terms that obligate you to collect a royalty for further conveying from those to whom you convey the Program, the only way you could satisfy both those terms and this License would be to refrain entirely from conveying the Program.\n\n\n\nNotwithstanding any other provision of this License, you have permission to link or combine any covered work with a work licensed under version 3 of the GNU Affero General Public License into a single combined work, and to convey the resulting work. The terms of this License will continue to apply to the part which is the covered work, but the special requirements of the GNU Affero General Public License, section 13, concerning interaction through a network will apply to the combination as such.\n\n\n\nThe Free Software Foundation may publish revised and/or new versions of the GNU General Public License from time to time. Such new versions will be similar in spirit to the present version, but may differ in detail to address new problems or concerns.\nEach version is given a distinguishing version number. If the Program specifies that a certain numbered version of the GNU General Public License “or any later version” applies to it, you have the option of following the terms and conditions either of that numbered version or of any later version published by the Free Software Foundation. If the Program does not specify a version number of the GNU General Public License, you may choose any version ever published by the Free Software Foundation.\nIf the Program specifies that a proxy can decide which future versions of the GNU General Public License can be used, that proxy’s public statement of acceptance of a version permanently authorizes you to choose that version for the Program.\nLater license versions may give you additional or different permissions. However, no additional obligations are imposed on any author or copyright holder as a result of your choosing to follow a later version.\n\n\n\nTHERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW. EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU. SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.\n\n\n\nIN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.\n\n\n\nIf the disclaimer of warranty and limitation of liability provided above cannot be given local legal effect according to their terms, reviewing courts shall apply local law that most closely approximates an absolute waiver of all civil liability in connection with the Program, unless a warranty or assumption of liability accompanies a copy of the Program in return for a fee.",
    "crumbs": [
      "Model to Meaning",
      "License"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "",
    "section": "",
    "text": "The marginaleffects package for R and Python offers a single point of entry to easily interpret the results of over 100 classes of models, using a simple and consistent user interface. Its benefits include:\n\nPowerful: It can compute and plot predictions; comparisons (contrasts, risk ratios, etc.); slopes; and conduct hypothesis and equivalence tests for over 100 different classes of models in R.\nSimple: All functions share a simple and unified interface.\nDocumented: Each function is thoroughly documented with abundant examples. The Marginal Effects Zoo website includes 20,000+ words of vignettes and case studies.\nEfficient: Some operations can be up to 1000 times faster and use 30 times less memory than with the margins package.\n\nValid: When possible, numerical results are checked against alternative software like Stata or other R packages.\nThin: The R package requires relatively few dependencies.\nStandards-compliant: marginaleffects follows “tidy” principles and returns simple data frames that work with all standard R functions. The outputs are easy to program with and feed to other packages like ggplot2 or modelsummary.\nExtensible: Adding support for new models is very easy, often requiring less than 10 lines of new code. Please submit feature requests on Github.\nActive development: Bugs are fixed promptly.\n\nTo cite marginaleffects in publications please use:\nArel-Bundock V, Greifer N, Heiss A (Forthcoming). “How to Interpret Statistical Models Using marginaleffects in R and Python.” Journal of Statistical Software.\nA BibTeX entry for LaTeX users is:\n@Article{,\n    title = {How to Interpret Statistical Models Using {marginaleffects} in {R} and {Python}},\n    author = {Vincent Arel-Bundock and Noah Greifer and Andrew Heiss},\n    year = {Forthcoming},\n    journal = {Journal of Statistical Software},\n}",
    "crumbs": [
      "Model to Meaning",
      "Home"
    ]
  }
]